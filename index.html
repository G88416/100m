<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate PRNG & Lotto Analyzer</title>
    <style>
        /* (Keep all your existing CSS styles) */
        /* Added some additional styles for new elements */
        .histogram {
            display: flex;
            height: 200px;
            align-items: flex-end;
            gap: 2px;
            margin: 1rem 0;
            padding: 1rem 0;
            border-top: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }
        
        .histogram-bar {
            flex: 1;
            background-color: var(--primary);
            min-width: 5px;
            position: relative;
        }
        
        .histogram-bar-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
        }
        
        .frequency-table {
            width: 100%;
            margin: 1rem 0;
        }
        
        .frequency-table th, .frequency-table td {
            padding: 6px;
            text-align: center;
        }
        
        .hot-number {
            background-color: #ffebee;
            font-weight: bold;
        }
        
        .cold-number {
            background-color: #e3f2fd;
            font-weight: bold;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- (Keep all your existing HTML structure) -->
    
    <script>
        // Global variables
        let prngReverseWorker = null;
        let lottoReverseWorker = null;
        let stopPRNGReverseFlag = false;
        let stopLottoReverseFlag = false;
        let currentPRNGAlgorithm = 'lcg';
        let currentLottoGameType = 'powerball';
        
        // Tab functionality
        function openTab(evt, tabName) {
            const tabContents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove("active");
            }
            
            const tabs = document.getElementsByClassName("tab");
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
            }
            
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
            
            // Store current tab state
            if (tabName.includes('prng')) {
                currentPRNGAlgorithm = document.getElementById(tabName === 'prng-generate' ? 'prng-algorithm' : 'reverse-prng-algorithm').value;
            } else if (tabName.includes('lotto')) {
                currentLottoGameType = document.getElementById(tabName === 'lotto-generate' ? 'lotto-game-type' : 'lotto-reverse-game-type').value;
            }
        }
        
        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // PRNG algorithm change
            document.getElementById('prng-algorithm').addEventListener('change', function() {
                currentPRNGAlgorithm = this.value;
                document.getElementById('lcg-params').style.display = currentPRNGAlgorithm === 'lcg' ? 'block' : 'none';
                updatePRNGAlgorithmInfo();
            });
            
            // Reverse PRNG algorithm change
            document.getElementById('reverse-prng-algorithm').addEventListener('change', function() {
                currentPRNGAlgorithm = this.value;
                document.getElementById('reverse-prng-params').style.display = currentPRNGAlgorithm === 'lcg' ? 'block' : 'none';
            });
            
            // Lotto game type change
            document.getElementById('lotto-game-type').addEventListener('change', function() {
                currentLottoGameType = this.value;
                document.getElementById('lotto-custom-params').style.display = 
                    currentLottoGameType === 'custom' ? 'block' : 'none';
            });
            
            // Reverse lotto game type change
            document.getElementById('lotto-reverse-game-type').addEventListener('change', function() {
                currentLottoGameType = this.value;
                document.getElementById('lotto-custom-reverse-params').style.display = 
                    currentLottoGameType === 'custom-reverse' ? 'block' : 'none';
            });
            
            // Compare mode change
            document.getElementById('compare-mode').addEventListener('change', function() {
                const mode = this.value;
                document.getElementById('prng-compare-fields').style.display = mode === 'prng' ? 'block' : 'none';
                document.getElementById('lotto-compare-fields').style.display = mode === 'lotto' ? 'block' : 'none';
            });
            
            // Set random seeds by default
            setRandomSeeds();
            
            // Initial setup
            updatePRNGAlgorithmInfo();
        });
        
        // Set random seeds for all seed inputs
        function setRandomSeeds() {
            const randomSeed = Math.floor(Math.random() * 1000000);
            document.getElementById('prng-seed').value = randomSeed;
            document.getElementById('lotto-seed').value = randomSeed;
            document.getElementById('compare-prng-seed').value = randomSeed;
            document.getElementById('compare-lotto-seed').value = randomSeed;
        }
        
        // PRNG implementations (keep your existing class implementations)
        // ... (LCG, Xorshift32, Mulberry32, MersenneTwister, PCG classes remain the same)
        
        // Generate PRNG numbers based on selected algorithm
        function generatePRNGNumbers() {
            const algorithm = document.getElementById('prng-algorithm').value;
            const seed = parseInt(document.getElementById('prng-seed').value) || 12345;
            const count = parseInt(document.getElementById('prng-count').value) || 10;
            const min = parseInt(document.getElementById('prng-min').value) || 0;
            const max = parseInt(document.getElementById('prng-max').value) || 100;
            
            if (min >= max) {
                alert("Max value must be greater than min value");
                return;
            }
            
            let prng;
            let numbers = [];
            
            // Initialize the appropriate PRNG
            try {
                switch (algorithm) {
                    case 'lcg':
                        const a = parseInt(document.getElementById('lcg-multiplier').value) || 1664525;
                        const c = parseInt(document.getElementById('lcg-increment').value) || 1013904223;
                        const m = parseInt(document.getElementById('lcg-modulus').value) || 4294967296;
                        prng = new LCG(seed, a, c, m);
                        break;
                    case 'mt':
                        prng = new MersenneTwister(seed);
                        break;
                    case 'xorshift':
                        prng = new Xorshift32(seed);
                        break;
                    case 'pcg':
                        prng = new PCG(seed);
                        break;
                    case 'mulberry32':
                        prng = new Mulberry32(seed);
                        break;
                    default:
                        throw new Error('Invalid algorithm selected');
                }
                
                // Generate numbers
                for (let i = 0; i < count; i++) {
                    let num;
                    if (algorithm === 'mulberry32') {
                        num = prng.next(); // Returns 0-1
                        num = min + Math.floor(num * (max - min + 1));
                    } else {
                        num = prng.next();
                        // Scale to desired range
                        num = min + (num % (max - min + 1));
                    }
                    numbers.push(num);
                }
                
                // Display results
                document.getElementById('prng-generated-numbers').value = numbers.join('\n');
                calculatePRNGStats(numbers, min, max);
                
            } catch (error) {
                alert("Error generating numbers: " + error.message);
                console.error(error);
            }
        }
        
        // Calculate statistics for generated numbers
        function calculatePRNGStats(numbers, min, max) {
            if (numbers.length === 0) return;
            
            const sum = numbers.reduce((a, b) => a + b, 0);
            const avg = sum / numbers.length;
            const foundMin = Math.min(...numbers);
            const foundMax = Math.max(...numbers);
            const range = max - min + 1;
            
            // Check for duplicates
            const unique = new Set(numbers);
            const duplicates = numbers.length - unique.size;
            
            // Calculate frequency distribution
            const frequency = {};
            for (let i = min; i <= max; i++) {
                frequency[i] = 0;
            }
            
            numbers.forEach(n => {
                if (n >= min && n <= max) {
                    frequency[n]++;
                }
            });
            
            // Convert frequency to array for sorting
            const frequencyArray = Object.keys(frequency).map(key => ({
                number: parseInt(key),
                count: frequency[key]
            }));
            
            // Sort by frequency (descending)
            frequencyArray.sort((a, b) => b.count - a.count);
            
            // Create frequency table HTML
            let frequencyHTML = `
                <table class="frequency-table">
                    <tr>
                        <th>Number</th>
                        <th>Count</th>
                        <th>Percentage</th>
                    </tr>
            `;
            
            frequencyArray.forEach(item => {
                const percentage = ((item.count / numbers.length) * 100).toFixed(2);
                const isHot = item.count > (numbers.length / range) * 1.5;
                const isCold = item.count < (numbers.length / range) * 0.5;
                
                frequencyHTML += `
                    <tr ${isHot ? 'class="hot-number"' : isCold ? 'class="cold-number"' : ''}>
                        <td>${item.number}</td>
                        <td>${item.count}</td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            });
            
            frequencyHTML += `</table>`;
            
            // Create histogram
            let histogramHTML = '<div class="histogram">';
            const maxFrequency = Math.max(...Object.values(frequency));
            
            frequencyArray.slice(0, 20).forEach(item => {
                const height = (item.count / maxFrequency) * 100;
                histogramHTML += `
                    <div class="histogram-bar" style="height: ${height}%">
                        <span class="histogram-bar-label">${item.number}</span>
                    </div>
                `;
            });
            
            histogramHTML += '</div>';
            
            // Display stats
            let stats = `
                <p>Count: ${numbers.length}</p>
                <p>Average: ${avg.toFixed(2)} (range ${min}-${max})</p>
                <p>Min: ${foundMin}, Max: ${foundMax}</p>
                <p>Duplicates: ${duplicates}</p>
                <p>Unique values: ${unique.size} (${((unique.size / numbers.length) * 100).toFixed(1)}% unique)</p>
                <p>Expected uniform frequency: ${(numbers.length / range).toFixed(2)} per number</p>
                
                <h4>Frequency Distribution</h4>
                ${histogramHTML}
                ${frequencyHTML}
            `;
            
            document.getElementById('prng-stats-content').innerHTML = stats;
        }
        
        // Generate lotto numbers
        function generateLottoNumbers() {
            const gameType = document.getElementById('lotto-game-type').value;
            const seedInput = document.getElementById('lotto-seed').value;
            const seed = seedInput ? parseInt(seedInput) : Math.floor(Math.random() * 1000000);
            const drawCount = parseInt(document.getElementById('lotto-draw-count').value) || 1;
            
            let mainPool, mainPick, bonusPool, bonusPick;
            
            // Set parameters based on game type
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('lotto-main-numbers').value) || 69;
                mainPick = parseInt(document.getElementById('lotto-pick-numbers').value) || 5;
                bonusPool = parseInt(document.getElementById('lotto-bonus-numbers').value) || 26;
                bonusPick = parseInt(document.getElementById('lotto-pick-bonus').value) || 1;
                
                if (mainPick > mainPool) {
                    alert("Cannot pick more numbers than are in the pool");
                    return;
                }
                if (bonusPick > bonusPool) {
                    alert("Cannot pick more bonus numbers than are in the bonus pool");
                    return;
                }
            } else {
                switch (gameType) {
                    case 'powerball':
                        mainPool = 69;
                        mainPick = 5;
                        bonusPool = 26;
                        bonusPick = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        mainPick = 5;
                        bonusPool = 25;
                        bonusPick = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        mainPick = 5;
                        bonusPool = 12;
                        bonusPick = 2;
                        break;
                }
            }
            
            try {
                // Generate draws
                let results = [];
                const prng = new Xorshift32(seed);
                
                for (let d = 0; d < drawCount; d++) {
                    // Generate main numbers
                    let mainNumbers = generateLottoDraw(mainPool, mainPick, prng);
                    
                    // Generate bonus numbers
                    let bonusNumbers = [];
                    if (bonusPool > 0 && bonusPick > 0) {
                        // Use a different seed variation for bonus numbers
                        const bonusSeed = seed + 1000000 + d;
                        const bonusPrng = new Xorshift32(bonusSeed);
                        bonusNumbers = generateLottoDraw(bonusPool, bonusPick, bonusPrng);
                    }
                    
                    results.push({
                        main: mainNumbers,
                        bonus: bonusNumbers
                    });
                }
                
                // Display results
                displayLottoResults(results, gameType);
                
                // Show generation details
                document.getElementById('lotto-gen-details').innerHTML = `
                    <p>Game: ${gameType}</p>
                    <p>Seed used: ${seed}</p>
                    <p>Main numbers: ${mainPick} from ${mainPool}</p>
                    ${bonusPool > 0 ? `<p>Bonus numbers: ${bonusPick} from ${bonusPool}</p>` : ''}
                    <p>Total draws generated: ${drawCount}</p>
                `;
                
                // Calculate and display frequency analysis
                calculateLottoFrequency(results, mainPool, bonusPool);
                
            } catch (error) {
                alert("Error generating lotto numbers: " + error.message);
                console.error(error);
            }
        }
        
        // Calculate frequency of lotto numbers
        function calculateLottoFrequency(results, mainPool, bonusPool) {
            const mainFrequency = {};
            const bonusFrequency = {};
            
            // Initialize frequency counters
            for (let i = 1; i <= mainPool; i++) mainFrequency[i] = 0;
            if (bonusPool > 0) {
                for (let i = 1; i <= bonusPool; i++) bonusFrequency[i] = 0;
            }
            
            // Count frequencies
            results.forEach(draw => {
                draw.main.forEach(num => mainFrequency[num]++);
                if (draw.bonus) {
                    draw.bonus.forEach(num => bonusFrequency[num]++);
                }
            });
            
            // Create frequency tables
            let mainHTML = createFrequencyTable(mainFrequency, results.length, "Main Numbers");
            let bonusHTML = bonusPool > 0 ? 
                createFrequencyTable(bonusFrequency, results.length, "Bonus Numbers") : "";
            
            document.getElementById('lotto-gen-details').innerHTML += `
                <h4>Number Frequency Analysis</h4>
                ${mainHTML}
                ${bonusHTML}
            `;
        }
        
        // Create HTML for a frequency table
        function createFrequencyTable(frequency, totalDraws, title) {
            // Convert to array and sort
            const freqArray = Object.keys(frequency).map(key => ({
                number: parseInt(key),
                count: frequency[key],
                percentage: (frequency[key] / totalDraws * 100).toFixed(2)
            }));
            
            freqArray.sort((a, b) => b.count - a.count);
            
            // Create table HTML
            let html = `
                <h5>${title}</h5>
                <table class="frequency-table">
                    <tr>
                        <th>Number</th>
                        <th>Drawn</th>
                        <th>Percentage</th>
                    </tr>
            `;
            
            freqArray.forEach(item => {
                const expected = (totalDraws / Object.keys(frequency).length).toFixed(2);
                const isHot = item.count > expected * 1.5;
                const isCold = item.count < expected * 0.5;
                
                html += `
                    <tr ${isHot ? 'class="hot-number"' : isCold ? 'class="cold-number"' : ''}>
                        <td>${item.number}</td>
                        <td>${item.count}</td>
                        <td>${item.percentage}%</td>
                    </tr>
                `;
            });
            
            html += `</table>`;
            return html;
        }
        
        // Reverse engineer PRNG seed
        function reverseEngineerPRNG() {
            const algorithm = document.getElementById('reverse-prng-algorithm').value;
            const targetNumbersText = document.getElementById('prng-target-numbers').value.trim();
            
            if (!targetNumbersText) {
                alert('Please enter observed numbers to analyze');
                return;
            }
            
            const targetNumbers = targetNumbersText.split('\n').map(num => parseInt(num.trim()));
            if (targetNumbers.some(isNaN)) {
                alert('Please enter valid numbers (one per line)');
                return;
            }
            
            if (targetNumbers.length < 3) {
                alert('Please enter at least 3 numbers for reliable reverse engineering');
                return;
            }
            
            // Show progress
            const progressBar = document.getElementById('prng-progress-bar');
            const progressContainer = document.getElementById('prng-reverse-progress');
            const stopButton = document.getElementById('prng-stop-button');
            const statusElement = document.getElementById('prng-reverse-status');
            
            progressContainer.style.display = 'block';
            stopButton.style.display = 'inline-block';
            statusElement.className = 'status info';
            statusElement.textContent = 'Starting reverse engineering...';
            
            // Use Web Worker if available for better performance
            if (window.Worker) {
                if (prngReverseWorker) {
                    prngReverseWorker.terminate();
                }
                
                // Create inline worker
                const workerCode = `
                    ${LCG.toString()}
                    ${Xorshift32.toString()}
                    ${Mulberry32.toString()}
                    
                    onmessage = function(e) {
                        const { algorithm, targetNumbers, knownParams } = e.data;
                        const maxAttempts = 1000000;
                        let foundSeed = null;
                        
                        for (let seed = 0; seed < maxAttempts; seed++) {
                            // Update progress every 10000 attempts
                            if (seed % 10000 === 0) {
                                const progress = Math.min(100, (seed / maxAttempts) * 100);
                                postMessage({ type: 'progress', value: progress });
                            }
                            
                            let prng;
                            switch (algorithm) {
                                case 'lcg':
                                    prng = new LCG(
                                        seed,
                                        knownParams.multiplier || 1664525,
                                        knownParams.increment || 1013904223,
                                        knownParams.modulus || 4294967296
                                    );
                                    break;
                                case 'xorshift32':
                                    prng = new Xorshift32(seed);
                                    break;
                                case 'mulberry32':
                                    prng = new Mulberry32(seed);
                                    break;
                            }
                            
                            // Check if this seed generates the target sequence
                            let match = true;
                            for (let i = 0; i < targetNumbers.length; i++) {
                                const generated = prng.next();
                                if (generated !== targetNumbers[i]) {
                                    match = false;
                                    break;
                                }
                            }
                            
                            if (match) {
                                foundSeed = seed;
                                break;
                            }
                        }
                        
                        postMessage({
                            type: 'result',
                            seed: foundSeed,
                            attempts: maxAttempts
                        });
                    };
                `;
                
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                prngReverseWorker = new Worker(URL.createObjectURL(blob));
                
                prngReverseWorker.onmessage = function(e) {
                    if (e.data.type === 'progress') {
                        progressBar.style.width = `${e.data.value}%`;
                        statusElement.textContent = `Searching... ${e.data.value}% complete`;
                    } else if (e.data.type === 'result') {
                        if (e.data.seed !== null) {
                            handlePRNGReverseResult(e.data.seed, targetNumbers, algorithm);
                        } else {
                            statusElement.className = 'status error';
                            statusElement.textContent = `No matching seed found in ${e.data.attempts.toLocaleString()} attempts. Try with more known parameters or more observed numbers.`;
                        }
                        stopPRNGReverseEngineer();
                    }
                };
                
                prngReverseWorker.postMessage({
                    algorithm: algorithm,
                    targetNumbers: targetNumbers,
                    knownParams: getKnownPRNGParams()
                });
            } else {
                // Fallback to main thread (may freeze UI for large searches)
                stopPRNGReverseFlag = false;
                findPRNGSeedBruteForce(algorithm, targetNumbers);
            }
        }
        
        // Brute-force PRNG seed search (fallback when Web Workers not available)
        function findPRNGSeedBruteForce(algorithm, targetNumbers) {
            const progressBar = document.getElementById('prng-progress-bar');
            const statusElement = document.getElementById('prng-reverse-status');
            const maxAttempts = 100000;
            const batchSize = 1000;
            let foundSeed = null;
            
            // Show initial progress
            progressBar.style.width = '0%';
            statusElement.textContent = 'Starting brute-force search...';
            
            // Process in batches to keep UI responsive
            function processBatch(startSeed, endSeed) {
                if (stopPRNGReverseFlag) {
                    statusElement.textContent = 'Search stopped by user';
                    return;
                }
                
                const knownParams = getKnownPRNGParams();
                
                for (let seed = startSeed; seed < endSeed; seed++) {
                    // Update progress
                    if (seed % 1000 === 0) {
                        const progress = Math.min(100, (seed / maxAttempts) * 100);
                        progressBar.style.width = `${progress}%`;
                        statusElement.textContent = `Searching... ${progress.toFixed(1)}% complete (seed ${seed})`;
                    }
                    
                    let prng;
                    switch (algorithm) {
                        case 'lcg':
                            prng = new LCG(
                                seed,
                                knownParams.multiplier || 1664525,
                                knownParams.increment || 1013904223,
                                knownParams.modulus || 4294967296
                            );
                            break;
                        case 'xorshift32':
                            prng = new Xorshift32(seed);
                            break;
                        case 'mulberry32':
                            prng = new Mulberry32(seed);
                            break;
                    }
                    
                    // Check if this seed generates the target sequence
                    let match = true;
                    for (let i = 0; i < targetNumbers.length; i++) {
                        const generated = prng.next();
                        if (generated !== targetNumbers[i]) {
                            match = false;
                            break;
                        }
                    }
                    
                    if (match) {
                        foundSeed = seed;
                        break;
                    }
                }
                
                if (foundSeed !== null || endSeed >= maxAttempts) {
                    // Search complete
                    if (foundSeed !== null) {
                        handlePRNGReverseResult(foundSeed, targetNumbers, algorithm);
                    } else {
                        statusElement.className = 'status error';
                        statusElement.textContent = `No matching seed found in ${maxAttempts.toLocaleString()} attempts. Try with more known parameters or more observed numbers.`;
                    }
                    stopPRNGReverseEngineer();
                } else {
                    // Process next batch
                    setTimeout(() => processBatch(endSeed, endSeed + batchSize), 0);
                }
            }
            
            // Start processing
            processBatch(0, batchSize);
        }
        
        // Handle PRNG reverse engineering results
        function handlePRNGReverseResult(seed, targetNumbers, algorithm) {
            const resultsElement = document.getElementById('prng-seed-results');
            const verificationElement = document.getElementById('prng-seed-verification');
            const statusElement = document.getElementById('prng-reverse-status');
            
            // Generate numbers from found seed to verify
            let generatedNumbers = [];
            let prng;
            const knownParams = getKnownPRNGParams();
            
            switch (algorithm) {
                case 'lcg':
                    prng = new LCG(
                        seed,
                        knownParams.multiplier || 1664525,
                        knownParams.increment || 1013904223,
                        knownParams.modulus || 4294967296
                    );
                    break;
                case 'xorshift32':
                    prng = new Xorshift32(seed);
                    break;
                case 'mulberry32':
                    prng = new Mulberry32(seed);
                    break;
            }
            
            // Generate more numbers than we matched to show predictions
            for (let i = 0; i < targetNumbers.length + 10; i++) {
                generatedNumbers.push(prng.next());
            }
            
            // Highlight the matched sequence
            let verificationText = '';
            for (let i = 0; i < generatedNumbers.length; i++) {
                if (i < targetNumbers.length) {
                    verificationText += `[${generatedNumbers[i]}] `; // Highlight matched numbers
                } else {
                    verificationText += `${generatedNumbers[i]} `;
                }
                if ((i + 1) % 10 === 0) verificationText += '\n';
            }
            
            // Display results
            resultsElement.innerHTML = `
                <p><strong>Found seed:</strong> ${seed}</p>
                <p>Next predicted numbers:</p>
                <p>${generatedNumbers.slice(targetNumbers.length, targetNumbers.length + 10).join(', ')}</p>
                <p>Algorithm parameters:</p>
                <pre>${JSON.stringify(getPRNGParameters(algorithm, seed, knownParams), null, 2)}</pre>
            `;
            
            verificationElement.value = verificationText.trim();
            
            statusElement.className = 'status success';
            statusElement.textContent = `Found matching seed: ${seed}`;
        }
        
        // Get PRNG parameters for display
        function getPRNGParameters(algorithm, seed, knownParams) {
            const params = { seed };
            
            switch (algorithm) {
                case 'lcg':
                    params.multiplier = knownParams.multiplier || 1664525;
                    params.increment = knownParams.increment || 1013904223;
                    params.modulus = knownParams.modulus || 4294967296;
                    params.formula = `Xₙ₊₁ = (${params.multiplier} × Xₙ + ${params.increment}) mod ${params.modulus}`;
                    break;
                case 'xorshift32':
                    params.operations = [
                        'x ^= x << 13',
                        'x ^= x >> 17',
                        'x ^= x << 5'
                    ];
                    break;
                case 'mulberry32':
                    params.algorithm = `
                        function mulberry32(a) {
                            a |= 0;
                            a = a + 0x6D2B79F5 | 0;
                            let t = Math.imul(a ^ a >>> 15, 1 | a);
                            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                            return ((t ^ t >>> 14) >>> 0) / 4294967296;
                        }`;
                    break;
            }
            
            return params;
        }
        
        // Stop PRNG reverse engineering
        function stopPRNGReverseEngineer() {
            stopPRNGReverseFlag = true;
            if (prngReverseWorker) {
                prngReverseWorker.terminate();
                prngReverseWorker = null;
            }
            
            document.getElementById('prng-stop-button').style.display = 'none';
        }
        
        // Clear PRNG reverse engineering results
        function clearPRNGReverse() {
            document.getElementById('prng-target-numbers').value = '';
            document.getElementById('prng-seed-results').innerHTML = 'Seed candidates will appear here after analysis.';
            document.getElementById('prng-seed-verification').value = '';
            document.getElementById('prng-reverse-status').className = 'status info';
            document.getElementById('prng-reverse-status').textContent = 'Enter observed numbers to begin reverse engineering.';
            document.getElementById('prng-reverse-progress').style.display = 'none';
            document.getElementById('prng-progress-bar').style.width = '0%';
            document.getElementById('prng-stop-button').style.display = 'none';
            stopPRNGReverseFlag = false;
        }
        
        // Compare sequences
        function compareSequences() {
            const mode = document.getElementById('compare-mode').value;
            const resultsElement = document.getElementById('compare-results');
            const statsElement = document.getElementById('compare-stats');
            
            if (mode === 'prng') {
                const seed = parseInt(document.getElementById('compare-prng-seed').value);
                const count = parseInt(document.getElementById('compare-prng-count').value) || 10;
                const observedText = document.getElementById('compare-prng-observed').value.trim();
                
                if (!observedText) {
                    alert('Please enter observed numbers to compare');
                    return;
                }
                
                const observedNumbers = observedText.split('\n').map(num => parseInt(num.trim()));
                if (observedNumbers.some(isNaN)) {
                    alert('Please enter valid numbers (one per line)');
                    return;
                }
                
                // Generate numbers from seed
                const prng = new Xorshift32(seed);
                const generatedNumbers = [];
                for (let i = 0; i < count; i++) {
                    generatedNumbers.push(prng.next());
                }
                
                // Compare
                let matches = 0;
                let comparison = '';
                const minLength = Math.min(observedNumbers.length, generatedNumbers.length);
                
                for (let i = 0; i < minLength; i++) {
                    const match = observedNumbers[i] === generatedNumbers[i];
                    if (match) matches++;
                    comparison += `${i+1}. Observed: ${observedNumbers[i]}, Generated: ${generatedNumbers[i]} ${match ? '✅' : '❌'}\n`;
                }
                
                // Display results
                resultsElement.innerHTML = `<pre>${comparison}</pre>`;
                statsElement.innerHTML = `
                    <p>Matches: ${matches} of ${minLength} (${(matches/minLength*100).toFixed(1)}%)</p>
                    <p>Sequence length: ${minLength}</p>
                    <p>Seed used: ${seed}</p>
                `;
            } else {
                // Lotto comparison mode
                const seed = parseInt(document.getElementById('compare-lotto-seed').value);
                const drawCount = parseInt(document.getElementById('compare-lotto-draws').value) || 10;
                const observedText = document.getElementById('compare-lotto-observed').value.trim();
                
                if (!observedText) {
                    alert('Please enter observed draws to compare');
                    return;
                }
                
                // Parse observed draws
                const observedDraws = [];
                const lines = observedText.split('\n');
                
                for (const line of lines) {
                    const parts = line.split('|');
                    if (parts.length === 0) continue;
                    
                    const main = parts[0].split(',').map(num => parseInt(num.trim()));
                    if (main.some(isNaN)) {
                        alert(`Invalid main numbers in line: ${line}`);
                        return;
                    }
                    
                    let bonus = [];
                    if (parts.length > 1) {
                        bonus = parts[1].split(',').map(num => parseInt(num.trim()));
                        if (bonus.some(isNaN)) {
                            alert(`Invalid bonus numbers in line: ${line}`);
                            return;
                        }
                    }
                    
                    observedDraws.push({ main, bonus });
                }
                
                if (observedDraws.length === 0) {
                    alert('No valid draws found');
                    return;
                }
                
                // Generate draws from seed
                const generatedDraws = [];
                const prng = new Xorshift32(seed);
                
                for (let d = 0; d < drawCount; d++) {
                    // Generate main numbers (5 from 69)
                    let mainNumbers = generateLottoDraw(69, 5, prng);
                    
                    // Generate bonus numbers (1 from 26)
                    const bonusSeed = seed + 1000000 + d;
                    const bonusPrng = new Xorshift32(bonusSeed);
                    let bonusNumbers = generateLottoDraw(26, 1, bonusPrng);
                    
                    generatedDraws.push({
                        main: mainNumbers,
                        bonus: bonusNumbers
                    });
                }
                
                // Compare
                let mainMatches = 0;
                let bonusMatches = 0;
                let comparison = '';
                const minLength = Math.min(observedDraws.length, generatedDraws.length);
                
                for (let i = 0; i < minLength; i++) {
                    const obs = observedDraws[i];
                    const gen = generatedDraws[i];
                    
                    // Count matches in main numbers
                    const mainMatchCount = obs.main.filter(num => gen.main.includes(num)).length;
                    mainMatches += mainMatchCount;
                    
                    // Count matches in bonus numbers
                    let bonusMatchCount = 0;
                    if (obs.bonus.length > 0 && gen.bonus.length > 0) {
                        bonusMatchCount = obs.bonus.filter(num => gen.bonus.includes(num)).length;
                        bonusMatches += bonusMatchCount;
                    }
                    
                    comparison += `Draw ${i+1}: Main ${mainMatchCount}/5, Bonus ${bonusMatchCount}/${obs.bonus.length}\n`;
                }
                
                // Display results
                resultsElement.innerHTML = `<pre>${comparison}</pre>`;
                statsElement.innerHTML = `
                    <p>Total main number matches: ${mainMatches} (avg ${(mainMatches/minLength).toFixed(1)} per draw)</p>
                    ${bonusMatches > 0 ? `<p>Total bonus number matches: ${bonusMatches} (avg ${(bonusMatches/minLength).toFixed(1)} per draw)</p>` : ''}
                    <p>Draws compared: ${minLength}</p>
                    <p>Seed used: ${seed}</p>
                `;
            }
        }
        
        // Helper function to get known PRNG parameters
        function getKnownPRNGParams() {
            return {
                multiplier: parseInt(document.getElementById('known-multiplier').value) || null,
                increment: parseInt(document.getElementById('known-increment').value) || null,
                modulus: parseInt(document.getElementById('known-modulus').value) || null
            };
        }
        
        // Update PRNG algorithm information
        function updatePRNGAlgorithmInfo() {
            const algorithm = document.getElementById('prng-algorithm').value;
            let info = '';
            
            switch (algorithm) {
                case 'lcg':
                    info = `
                        <h4>Linear Congruential Generator (LCG)</h4>
                        <p>One of the oldest and simplest PRNG algorithms defined by the recurrence relation:</p>
                        <p><strong>X<sub>n+1</sub> = (a × X<sub>n</sub> + c) mod m</strong></p>
                        <p>Default parameters (Borland C/C++):</p>
                        <ul>
                            <li>Multiplier (a): 1664525</li>
                            <li>Increment (c): 1013904223</li>
                            <li>Modulus (m): 2<sup>32</sup> (4294967296)</li>
                        </ul>
                        <p class="status warning">Warning: LCGs are not cryptographically secure and can be predictable with enough output.</p>
                    `;
                    break;
                    
                case 'mt':
                    info = `
                        <h4>Mersenne Twister</h4>
                        <p>A widely used PRNG with a period of 2<sup>19937</sup>-1. Provides fast generation of high-quality pseudo-random numbers.</p>
                        <p>Advantages:</p>
                        <ul>
                            <li>Very long period</li>
                            <li>Good statistical properties</li>
                            <li>Fast generation</li>
                        </ul>
                        <p>Used in many programming languages and applications including Python, Ruby, and MATLAB.</p>
                    `;
                    break;
                    
                case 'xorshift':
                    info = `
                        <h4>Xorshift</h4>
                        <p>A class of PRNGs using bitwise XOR and shift operations. Very fast but requires careful parameter selection.</p>
                        <p>Basic Xorshift32 operation:</p>
                        <pre class="code">x ^= x << 13;
x ^= x >> 17;
x ^= x << 5;</pre>
                        <p>Period: 2<sup>32</sup>-1</p>
                        <p class="status info">Note: While fast, Xorshift fails some statistical tests. Consider Xorshift* or Xorshift+ variants for better quality.</p>
                    `;
                    break;
                    
                case 'pcg':
                    info = `
                        <h4>PCG (Permuted Congruential Generator)</h4>
                        <p>A family of PRNGs that combines LCG with permutation functions to improve statistical quality.</p>
                        <p>Features:</p>
                        <ul>
                            <li>Excellent statistical properties</li>
                            <li>Small memory footprint</li>
                            <li>Predictable output (if needed)</li>
                        </ul>
                        <p>Variants include PCG-XSH-RR (good general purpose) and PCG-XSH-RS (faster but slightly lower quality).</p>
                    `;
                    break;
                    
                case 'mulberry32':
                    info = `
                        <h4>Mulberry32</h4>
                        <p>A simple 32-bit PRNG with good distribution characteristics.</p>
                        <p>Implementation:</p>
                        <pre class="code">function mulberry32(a) {
    a |= 0;
    a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
}</pre>
                        <p>Period: 2<sup>32</sup></p>
                        <p class="status info">Note: This is a simple generator suitable for games and simulations but not for cryptographic purposes.</p>
                    `;
                    break;
            }
            
            document.getElementById('prng-algorithm-info').innerHTML = info;
        }
    </script>
</body>
</html>
