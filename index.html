<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lotto Pro - Advanced Lottery Prediction System</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>
    <style>
        :root {
            --primary: #4a6bff;
            --primary-dark: #3a56cc;
            --primary-light: #6b89ff;
            --secondary: #2dd4bf;
            --dark: #1e293b;
            --light: #f8fafc;
            --accent: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        [data-theme="dark"] {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #14b8a6;
            --dark: #e2e8f0;
            --light: #1e293b;
            --accent: #a78bfa;
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #f87171;
            --info: #60a5fa;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --border-color: #334155;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.25);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-color);
            transition: all 0.3s ease;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 0 0 10px 10px;
            box-shadow: var(--shadow-md);
            margin-bottom: 2rem;
            position: relative;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 600;
            letter-spacing: -0.025em;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-top: 0.5rem;
            font-weight: 300;
        }

        .card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
            padding: 1.75rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .card h2 {
            color: var(--primary);
            margin-top: 0;
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            font-weight: 600;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--accent);
        }

        .card h3 {
            color: var(--text-primary);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            font-size: 1.2rem;
        }

        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
            font-weight: 500;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .tab:hover {
            background: var(--primary-light);
            color: white;
            border-color: var(--primary-light);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: 600;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tab-content.active {
            display: block;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            background: var(--card-bg);
            color: var(--text-primary);
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(74, 107, 255, 0.2);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-sm);
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        button:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        button.secondary {
            background-color: var(--text-secondary);
        }

        button.success {
            background-color: var(--success);
        }

        button.warning {
            background-color: var(--warning);
        }

        button.danger {
            background-color: var(--danger);
        }

        button.info {
            background-color: var(--info);
        }

        button.accent {
            background-color: var(--accent);
        }

        .result {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
            border-left: 4px solid var(--accent);
            color: var(--text-primary);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.75rem;
        }

        .lotto-balls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
            align-items: center;
        }

        .ball {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            font-size: 1.1rem;
        }

        .ball:hover {
            transform: scale(1.15);
            box-shadow: var(--shadow);
        }

        .ball.powerball {
            background-color: var(--danger);
        }

        .ball.megaball {
            background-color: var(--info);
        }

        .ball.eurostar {
            background-color: var(--success);
        }

        .ball.hot-number {
            background-color: var(--danger);
            animation: pulse 2s infinite;
        }

        .ball.cold-number {
            background-color: var(--info);
        }

        .ball.prime-number {
            background-color: var(--accent);
        }

        .ball.fibonacci-number {
            background-color: var(--warning);
        }

        .ball.lucky-number {
            background-color: var(--success);
        }

        .progress-container {
            width: 100%;
            background-color: var(--border-color);
            border-radius: 6px;
            margin: 1rem 0;
            height: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                -45deg,
                rgba(255, 255, 255, 0.2) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.2) 75%,
                transparent 75%,
                transparent
            );
            background-size: 30px 30px;
            animation: progressAnimation 1s linear infinite;
        }

        @keyframes progressAnimation {
            0% { background-position: 0 0; }
            100% { background-position: 30px 0; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .status {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .status.info {
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--info);
            color: var(--info);
        }

        .status.success {
            background-color: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
            color: var(--success);
        }

        .status.warning {
            background-color: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
            color: var(--warning);
        }

        .status.error {
            background-color: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
            color: var(--danger);
        }

        .algorithm-info {
            margin-top: 2rem;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
            border-left: 4px solid var(--accent);
        }

        .code {
            font-family: 'Source Code Pro', monospace;
            background-color: var(--bg-color);
            padding: 0.75rem;
            border-radius: 6px;
            display: block;
            overflow-x: auto;
            margin: 0.75rem 0;
            border-left: 4px solid var(--accent);
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-color);
            font-weight: 600;
            color: var(--primary);
        }

        tr:hover {
            background-color: var(--bg-color);
        }

        /* Histogram styles */
        .histogram {
            display: flex;
            height: 220px;
            align-items: flex-end;
            gap: 2px;
            margin: 1rem 0;
            padding: 1rem 0;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        .histogram-bar {
            flex: 1;
            background: linear-gradient(to top, var(--primary), var(--secondary));
            min-width: 5px;
            position: relative;
            transition: height 0.5s ease;
        }

        .histogram-bar-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Frequency table styles */
        .frequency-table {
            width: 100%;
            margin: 1.5rem 0;
        }

        .frequency-table th, .frequency-table td {
            padding: 10px;
            text-align: center;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: var(--dark);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            box-shadow: var(--shadow-lg);
            font-size: 0.9rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Theme toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(30deg) scale(1.1);
            box-shadow: var(--shadow);
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Action buttons container */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin: 1.5rem 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                border-radius: 6px;
                margin-bottom: 5px;
            }
        }

        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }

        /* Export buttons */
        .export-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        /* Save/Load buttons */
        .config-buttons {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        /* Tab icons */
        .tab-icon {
            font-size: 0.95em;
        }
        
        /* Notification toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success);
            color: white;
            padding: 14px 28px;
            border-radius: 6px;
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            max-width: 400px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Improved number input styling */
        input[type="number"] {
            -moz-appearance: textfield;
        }
        
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Better table styling */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-sm);
        }
        
        .data-table th {
            background-color: var(--primary);
            color: white;
            padding: 14px;
            text-align: left;
            font-weight: 600;
        }
        
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .data-table tr:nth-child(even) {
            background-color: rgba(0,0,0,0.03);
        }
        
        .data-table tr:hover {
            background-color: var(--bg-color);
        }
        
        /* Strategy selector */
        .strategy-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .strategy-option {
            padding: 0.75rem 1.25rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
        }
        
        .strategy-option:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .strategy-option.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: 600;
            box-shadow: var(--shadow);
        }
        
        /* Number matrix */
        .number-matrix {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 6px;
            margin: 1.5rem 0;
        }
        
        .number-cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            box-shadow: var(--shadow-sm);
        }
        
        .number-cell:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .number-cell.selected {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: bold;
            box-shadow: var(--shadow);
        }
        
        /* Wheel visualization */
        .wheel-container {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
        }
        
        .wheel {
            width: 320px;
            height: 320px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 6px solid var(--border-color);
            box-shadow: var(--shadow-md);
        }
        
        .wheel-number {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: bottom right;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        /* History table */
        .history-table {
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-sm);
        }

        /* New styles for enhanced features */
        .coverage-meter {
            width: 100%;
            height: 22px;
            background-color: var(--border-color);
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        .coverage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .number-coverage {
            margin: 20px 0;
        }
        
        .number-coverage span {
            display: inline-block;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            margin: 3px;
            font-size: 13px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }
        
        .number-coverage span.covered {
            background-color: var(--success);
            color: white;
            border-color: var(--success);
            transform: scale(1.1);
        }
        
        .simulation-results {
            margin-top: 25px;
        }
        
        .simulation-chart {
            width: 100%;
            height: 350px;
            margin: 25px 0;
        }
        
        .strategy-performance {
            margin-top: 25px;
        }
        
        .performance-metric {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 1.05rem;
        }
        
        .performance-metric span:first-child {
            font-weight: 600;
        }
        
        .performance-bar {
            height: 12px;
            background-color: var(--border-color);
            border-radius: 6px;
            margin: 8px 0;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        .performance-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        /* Stats cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow-sm);
            text-align: center;
            transition: all 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }
        
        .stat-card h3 {
            font-size: 1.05rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .stat-card p {
            font-size: 1.7rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        /* Number trends */
        .trend-indicator {
            display: inline-block;
            margin-left: 5px;
        }
        
        .trend-up {
            color: var(--success);
        }
        
        .trend-down {
            color: var(--danger);
        }
        
        /* Draw simulator */
        .simulator-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        /* Wheel strategy */
        .wheel-strategy {
            margin: 25px 0;
        }
        
        .wheel-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .wheel-section-label {
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        /* Print styles */
        @media print {
            body * {
                visibility: hidden;
            }
            .printable, .printable * {
                visibility: visible;
            }
            .printable {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }
            .no-print {
                display: none !important;
            }
        }

        /* Advanced analysis cards */
        .analysis-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s;
        }
        
        .analysis-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        .analysis-card h3 {
            color: var(--primary);
            margin-top: 0;
            margin-bottom: 1rem;
            font-weight: 600;
            font-size: 1.25rem;
        }
        
        /* Pattern recognition */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .pattern-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }
        
        .pattern-card h4 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        
        /* Prediction engine */
        .prediction-engine {
            margin-top: 2rem;
        }
        
        .prediction-results {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .prediction-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            width: calc(33.333% - 1rem);
            min-width: 250px;
        }
        
        @media (max-width: 768px) {
            .prediction-card {
                width: 100%;
            }
        }
        
        /* Number clusters */
        .cluster-container {
            margin: 1.5rem 0;
        }
        
        .cluster {
            display: inline-block;
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-color);
            border-radius: 20px;
            border: 1px solid var(--border-color);
        }
        
        /* AI recommendations */
        .ai-recommendation {
            background: linear-gradient(135deg, rgba(74, 107, 255, 0.1), rgba(45, 212, 191, 0.1));
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: 6px;
            margin: 1.5rem 0;
        }
        
        /* Number patterns */
        .pattern-visualization {
            width: 100%;
            height: 300px;
            background: var(--bg-color);
            border-radius: 8px;
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
        }
        
        /* Seed input */
        .seed-input {
            display: flex;
            gap: 10px;
            margin-bottom: 1rem;
        }
        
        .seed-input input {
            flex: 1;
        }
        
        .seed-input button {
            margin-bottom: 1rem;
        }
        
        /* Algorithm selector */
        .algorithm-selector {
            margin-bottom: 1.5rem;
        }
        
        /* Number distribution */
        .distribution-chart {
            width: 100%;
            height: 300px;
            margin: 1.5rem 0;
        }
        
        /* Number gap analysis */
        .gap-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number sum analysis */
        .sum-analysis {
            margin: 1.5rem 0;
        }
        
        /* Last digits analysis */
        .last-digit-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number matrix analysis */
        .matrix-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number wheel visualization */
        .wheel-visualization {
            margin: 1.5rem 0;
        }
        
        /* Number probability */
        .probability-indicator {
            height: 10px;
            background: var(--border-color);
            border-radius: 5px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .probability-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
        }
        
        /* Number statistics */
        .number-stats {
            margin: 1.5rem 0;
        }
        
        /* Number trends over time */
        .trend-chart {
            width: 100%;
            height: 300px;
            margin: 1.5rem 0;
        }
        
        /* Number sequences */
        .sequence-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number pairing analysis */
        .pair-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number position analysis */
        .position-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number frequency over time */
        .frequency-trend {
            margin: 1.5rem 0;
        }
        
        /* Number prediction model */
        .prediction-model {
            margin: 1.5rem 0;
        }
        
        /* Number pattern recognition */
        .pattern-recognition {
            margin: 1.5rem 0;
        }
        
        /* Number cluster analysis */
        .cluster-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number distribution analysis */
        .distribution-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number probability analysis */
        .probability-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number wheel coverage */
        .wheel-coverage {
            margin: 1.5rem 0;
        }
        
        /* Number sum distribution */
        .sum-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number last digit distribution */
        .last-digit-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number matrix coverage */
        .matrix-coverage {
            margin: 1.5rem 0;
        }
        
        /* Number position frequency */
        .position-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number pairing frequency */
        .pair-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number sequence frequency */
        .sequence-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number gap frequency */
        .gap-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number cluster frequency */
        .cluster-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number prediction accuracy */
        .prediction-accuracy {
            margin: 1.5rem 0;
        }
        
        /* Number pattern frequency */
        .pattern-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number distribution frequency */
        .distribution-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number probability frequency */
        .probability-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number wheel frequency */
        .wheel-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number sum frequency */
        .sum-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number last digit frequency */
        .last-digit-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number matrix frequency */
        .matrix-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number position distribution */
        .position-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number pairing distribution */
        .pair-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number sequence distribution */
        .sequence-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number gap distribution */
        .gap-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number cluster distribution */
        .cluster-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number prediction distribution */
        .prediction-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number pattern distribution */
        .pattern-distribution {
            margin: 1.5rem 0;
        }
        
        /* Responsive tweaks */
        @media (max-width: 1024px) {
            .card {
                padding: 1.25rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }
        }
        
        @media (max-width: 640px) {
            .card {
                padding: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .number-matrix {
                grid-template-columns: repeat(5, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">
                <i class="fas fa-moon"></i>
            </button>
            <h1>Lotto Pro</h1>
            <p class="subtitle">Advanced Lottery Prediction & Analysis System</p>
        </div>
    </header>
    
    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="generator">
                <i class="fas fa-magic tab-icon"></i> Smart Generator
            </button>
            <button class="tab" data-tab="analyzer">
                <i class="fas fa-chart-line tab-icon"></i> Advanced Analyzer
            </button>
            <button class="tab" data-tab="history">
                <i class="fas fa-database tab-icon"></i> Historical Data
            </button>
            <button class="tab" data-tab="strategies">
                <i class="fas fa-robot tab-icon"></i> AI Strategies
            </button>
            <button class="tab" data-tab="simulator">
                <i class="fas fa-vial tab-icon"></i> Probability Lab
            </button>
            <button class="tab" data-tab="predictor">
                <i class="fas fa-crystal-ball tab-icon"></i> Prediction Engine
            </button>
        </div>
      
        <!-- Generator Tab -->
        <div id="generator" class="tab-content active">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Lottery Selection</h2>
                        <label for="game-type">Lottery Game:</label>
                        <select id="game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                            <option value="custom">Custom Game</option>
                        </select>
                        
                        <div id="custom-params" style="display: none;">
                            <div class="grid">
                                <div>
                                    <label for="main-numbers">Main Numbers Pool:</label>
                                    <input type="number" id="main-numbers" min="1" value="69">
                                </div>
                                <div>
                                    <label for="pick-numbers">Numbers to Pick:</label>
                                    <input type="number" id="pick-numbers" min="1" value="5">
                                </div>
                            </div>
                            <div class="grid">
                                <div>
                                    <label for="bonus-numbers">Bonus Numbers Pool:</label>
                                    <input type="number" id="bonus-numbers" min="0" value="26">
                                </div>
                                <div>
                                    <label for="pick-bonus">Bonus Numbers to Pick:</label>
                                    <input type="number" id="pick-bonus" min="0" value="1">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Generation Options</h2>
                        <div class="seed-input">
                            <input type="text" id="random-seed" placeholder="Optional seed for reproducible results">
                            <button onclick="generateSeed()" class="accent">
                                <i class="fas fa-seedling"></i> Random Seed
                            </button>
                        </div>
                        
                        <label for="generation-method">Generation Method:</label>
                        <select id="generation-method">
                            <option value="standard">Standard Random</option>
                            <option value="shuffle">Fisher-Yates Shuffle</option>
                            <option value="crypto">Cryptographically Secure</option>
                            <option value="low-high">Low-High Balance</option>
                            <option value="odd-even">Odd-Even Balance</option>
                            <option value="prime">Prime Numbers</option>
                            <option value="fibonacci">Fibonacci Numbers</option>
                            <option value="lucky">Lucky Numbers</option>
                            <option value="hot-cold">Hot & Cold Numbers</option>
                            <option value="wheel">Wheel System</option>
                            <option value="ai">AI-Powered Prediction</option>
                        </select>
                        
                        <div id="method-params" style="margin-top: 15px;">
                            <!-- Parameters will be inserted here based on method -->
                        </div>
                        
                        <label for="draw-count">Number of tickets:</label>
                        <input type="number" id="draw-count" min="1" value="5" max="100">
                        
                        <div class="action-buttons">
                            <button onclick="generateNumbers()" class="success">
                                <i class="fas fa-play"></i> Generate
                            </button>
                            <button onclick="quickPick()" class="warning">
                                <i class="fas fa-bolt"></i> Quick Pick
                            </button>
                            <button onclick="clearGeneration()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>AI Recommendations</h2>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-lightbulb"></i> <strong>Tip:</strong> Combine multiple strategies for better coverage. Try using Hot/Cold numbers with Low/High balance for optimal results.</p>
                        </div>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-chart-bar"></i> <strong>Analysis:</strong> Based on historical data, numbers between 1-31 appear more frequently due to birthday selections. Consider including some higher numbers.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Generated Tickets</h2>
                        <div id="generated-results"></div>
                        
                        <div class="export-buttons">
                            <button onclick="exportNumbers('txt')" class="secondary">
                                <i class="fas fa-file-alt"></i> Export as TXT
                            </button>
                            <button onclick="exportNumbers('csv')" class="secondary">
                                <i class="fas fa-file-csv"></i> Export as CSV
                            </button>
                            <button onclick="exportNumbers('json')" class="secondary">
                                <i class="fas fa-file-code"></i> Export as JSON
                            </button>
                            <button onclick="copyNumbers()" class="secondary">
                                <i class="fas fa-copy"></i> Copy to Clipboard
                            </button>
                            <button onclick="printNumbers()" class="secondary">
                                <i class="fas fa-print"></i> Print
                            </button>
                            <button onclick="saveTickets()" class="info">
                                <i class="fas fa-save"></i> Save Tickets
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Number Coverage</h2>
                        <div class="number-coverage" id="number-coverage">
                            <!-- Numbers will be inserted here -->
                        </div>
                        <div class="coverage-meter">
                            <div class="coverage-fill" id="coverage-fill"></div>
                        </div>
                        <p id="coverage-percentage">0% of numbers covered</p>
                    </div>
                    
                    <div class="card">
                        <h2>Frequency Analysis</h2>
                        <div id="frequency-content">
                            <p>Generate some numbers to see frequency analysis</p>
                        </div>
                        <canvas id="frequency-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Analyzer Tab -->
        <div id="analyzer" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Number Analysis</h2>
                        <label for="analyzer-game-type">Lottery Game:</label>
                        <select id="analyzer-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="analyzer-numbers">Numbers to Analyze (comma separated):</label>
                        <input type="text" id="analyzer-numbers" placeholder="e.g. 5, 10, 15, 20, 25, 30">
                        
                        <div class="number-matrix" id="analyzer-number-matrix"></div>
                        
                        <div class="action-buttons">
                            <button onclick="analyzeNumbers()" class="success">Analyze</button>
                            <button onclick="clearAnalyzer()" class="secondary">Clear</button>
                            <button onclick="loadSavedTickets()" class="info">
                                <i class="fas fa-folder-open"></i> Load Saved
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Advanced Analysis</h2>
                        <div class="analysis-card">
                            <h3>Number Sum Analysis</h3>
                            <div id="sum-analysis">
                                <p>Analyze numbers to see sum statistics</p>
                            </div>
                        </div>
                        
                        <div class="analysis-card">
                            <h3>Number Gap Analysis</h3>
                            <div id="gap-analysis">
                                <p>Analyze numbers to see gap statistics</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Analysis Results</h2>
                        <div id="analyzer-results">
                            <p>Enter numbers to analyze them</p>
                        </div>
                        
                        <div class="stats-grid" id="analyzer-stats">
                            <!-- Stats cards will be inserted here -->
                        </div>
                        
                        <canvas id="analyzer-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card">
                        <h2>Pattern Recognition</h2>
                        <div id="pattern-recognition">
                            <p>Analyze numbers to detect patterns</p>
                        </div>
                        <div class="pattern-visualization" id="pattern-visualization"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- History Tab -->
        <div id="history" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Historical Data</h2>
                        <label for="history-game-type">Lottery Game:</label>
                        <select id="history-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="history-draw-count">Number of past draws to load:</label>
                        <input type="number" id="history-draw-count" min="1" max="500" value="100">
                        
                        <div class="action-buttons">
                            <button onclick="loadHistoricalData()" class="success">
                                <i class="fas fa-sync-alt"></i> Load History
                            </button>
                            <button onclick="clearHistory()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button onclick="downloadHistoricalData()" class="info">
                                <i class="fas fa-download"></i> Download Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Historical Trends</h2>
                        <div id="history-trends">
                            <p>Load historical data to see trends</p>
                        </div>
                        <canvas id="history-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Past Draws</h2>
                        <div class="history-table">
                            <table id="history-table">
                                <thead>
                                    <tr>
                                        <th>Draw Date</th>
                                        <th>Numbers</th>
                                        <th>Bonus</th>
                                        <th>Jackpot</th>
                                    </tr>
                                </thead>
                                <tbody id="history-table-body">
                                    <!-- History data will be inserted here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Hot & Cold Numbers</h2>
                        <div id="hot-cold-numbers">
                            <p>Load historical data to see hot and cold numbers</p>
                        </div>
                        <canvas id="hot-cold-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Strategies Tab -->
        <div id="strategies" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>AI-Powered Strategies</h2>
                        <p>Select a strategy to generate numbers based on different approaches:</p>
                        
                        <div class="strategy-selector">
                            <div class="strategy-option active" data-strategy="random">
                                <i class="fas fa-random"></i> Random
                            </div>
                            <div class="strategy-option" data-strategy="low-high">
                                <i class="fas fa-balance-scale"></i> Low-High
                            </div>
                            <div class="strategy-option" data-strategy="odd-even">
                                <i class="fas fa-divide"></i> Odd-Even
                            </div>
                            <div class="strategy-option" data-strategy="prime">
                                <i class="fas fa-superscript"></i> Prime
                            </div>
                            <div class="strategy-option" data-strategy="fibonacci">
                                <i class="fas fa-infinity"></i> Fibonacci
                            </div>
                            <div class="strategy-option" data-strategy="lucky">
                                <i class="fas fa-star"></i> Lucky
                            </div>
                            <div class="strategy-option" data-strategy="hot-cold">
                                <i class="fas fa-fire"></i> Hot/Cold
                            </div>
                            <div class="strategy-option" data-strategy="birthday">
                                <i class="fas fa-birthday-cake"></i> Birthday
                            </div>
                            <div class="strategy-option" data-strategy="ai">
                                <i class="fas fa-brain"></i> AI Prediction
                            </div>
                        </div>
                        
                        <div id="strategy-params" style="margin-top: 15px;">
                            <!-- Strategy parameters will be inserted here -->
                        </div>
                        
                        <div class="action-buttons">
                            <button onclick="generateWithStrategy()" class="success">
                                <i class="fas fa-magic"></i> Generate with Strategy
                            </button>
                            <button onclick="testStrategy()" class="info">
                                <i class="fas fa-flask"></i> Test Strategy
                            </button>
                            <button onclick="saveStrategy()" class="accent">
                                <i class="fas fa-save"></i> Save Strategy
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Strategy Explanation</h2>
                        <div id="strategy-explanation">
                            <p>The <strong>Random</strong> strategy generates numbers completely at random with no particular pattern or strategy. This mimics how lottery numbers are actually drawn.</p>
                        </div>
                        
                        <div class="ai-recommendation">
                            <p><i class="fas fa-robot"></i> <strong>AI Suggestion:</strong> For best results, combine multiple strategies and analyze historical trends before generating your numbers.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Generated Numbers</h2>
                        <div id="strategy-results">
                            <p>Generate numbers to see results</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Strategy Statistics</h2>
                        <div id="strategy-stats">
                            <p>Generate numbers to see statistics</p>
                        </div>
                        <canvas id="strategy-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card strategy-performance" id="strategy-performance" style="display: none;">
                        <h2>Strategy Performance</h2>
                        <div id="performance-results">
                            <!-- Performance results will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Simulator Tab -->
        <div id="simulator" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Probability Lab</h2>
                        <label for="simulator-game-type">Lottery Game:</label>
                        <select id="simulator-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="simulator-tickets">Your Tickets (one per line):</label>
                        <textarea id="simulator-tickets" rows="5" placeholder="Enter your tickets, one per line&#10;Example: 5, 10, 15, 20, 25, 30"></textarea>
                        
                        <label for="simulation-count">Number of simulations:</label>
                        <input type="number" id="simulation-count" min="1" value="1000" max="100000" step="100">
                        
                        <div class="action-buttons">
                            <button onclick="runSimulation()" class="success">
                                <i class="fas fa-play"></i> Run Simulation
                            </button>
                            <button onclick="stopSimulation()" class="danger">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                            <button onclick="clearSimulation()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button onclick="loadSampleTickets()" class="info">
                                <i class="fas fa-dice"></i> Load Sample
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Probability Calculator</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <h3>Jackpot Odds</h3>
                                <p id="jackpot-odds">1 in 292M</p>
                            </div>
                            <div class="stat-card">
                                <h3>Break-even Point</h3>
                                <p id="break-even">$584M</p>
                            </div>
                            <div class="stat-card">
                                <h3>Expected Value</h3>
                                <p id="expected-value">-$0.80</p>
                            </div>
                        </div>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-calculator"></i> <strong>Note:</strong> These calculations assume a $2 ticket price and standard prize structure. Actual values may vary.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Simulation Results</h2>
                        <div id="simulation-results">
                            <p>Run a simulation to see results</p>
                        </div>
                        
                        <div class="stats-grid" id="simulation-stats">
                            <!-- Stats will be inserted here -->
                        </div>
                        
                        <canvas id="simulation-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card">
                        <h2>Winning Numbers</h2>
                        <div id="winning-numbers">
                            <p>Run a simulation to see winning numbers</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Predictor Tab -->
        <div id="predictor" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Prediction Engine</h2>
                        <label for="predictor-game-type">Lottery Game:</label>
                        <select id="predictor-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="predictor-method">Prediction Method:</label>
                        <select id="predictor-method">
                            <option value="markov">Markov Chain Model</option>
                            <option value="neural">Neural Network</option>
                            <option value="regression">Regression Analysis</option>
                            <option value="frequency">Frequency Analysis</option>
                            <option value="combined">Combined AI Model</option>
                        </select>
                        
                        <label for="prediction-count">Number of predictions:</label>
                        <input type="number" id="prediction-count" min="1" value="10" max="100">
                        
                        <div class="action-buttons">
                            <button onclick="generatePredictions()" class="success">
                                <i class="fas fa-crystal-ball"></i> Generate Predictions
                            </button>
                            <button onclick="analyzePredictions()" class="info">
                                <i class="fas fa-chart-bar"></i> Analyze Results
                            </button>
                            <button onclick="clearPredictions()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Prediction Model Details</h2>
                        <div id="model-details">
                            <p>Select a prediction method to see details</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Predicted Numbers</h2>
                        <div id="prediction-results">
                            <p>Generate predictions to see results</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Prediction Analysis</h2>
                        <div id="prediction-analysis">
                            <p>Generate predictions to see analysis</p>
                        </div>
                        <canvas id="prediction-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>About Lotto Pro</h2>
            <div class="grid">
                <div>
                    <h3>How It Works</h3>
                    <p>Lotto Pro uses advanced artificial intelligence and statistical analysis to help you generate and analyze lottery numbers. Our system combines multiple predictive models to identify patterns and trends in lottery draws.</p>
                    
                    <h3>Odds Information</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Game</th>
                                <th>Main Numbers</th>
                                <th>Bonus Numbers</th>
                                <th>Odds of Jackpot</th>
                                <th>Expected Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Powerball</td>
                                <td>5/69</td>
                                <td>1/26</td>
                                <td>1 in 292,201,338</td>
                                <td>-$0.80</td>
                            </tr>
                            <tr>
                                <td>Mega Millions</td>
                                <td>5/70</td>
                                <td>1/25</td>
                                <td>1 in 302,575,350</td>
                                <td>-$0.85</td>
                            </tr>
                            <tr>
                                <td>EuroMillions</td>
                                <td>5/50</td>
                                <td>2/12</td>
                                <td>1 in 139,838,160</td>
                                <td>-$0.50</td>
                            </tr>
                            <tr>
                                <td>Lotto 6/49</td>
                                <td>6/49</td>
                                <td>None</td>
                                <td>1 in 13,983,816</td>
                                <td>-$0.55</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div>
                    <h3>AI-Powered Strategies</h3>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Markov Chain Model:</strong> Predicts future numbers based on transition probabilities from historical data</li>
                        <li><strong>Neural Network:</strong> Deep learning model trained on past draws to identify complex patterns</li>
                        <li><strong>Regression Analysis:</strong> Statistical model that identifies relationships between numbers</li>
                        <li><strong>Frequency Analysis:</strong> Prioritizes numbers based on their historical appearance rates</li>
                        <li><strong>Combined AI Model:</strong> Ensemble approach that weights predictions from multiple models</li>
                    </ul>
                    
                    <h3>Remember</h3>
                    <p>Lotteries are games of chance. While our system can identify patterns and improve your number selection strategy, no system can guarantee a win. Always play responsibly and never spend more than you can afford to lose.</p>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        // Enhanced Global State
        let appState = {
            currentStrategy: 'random',
            historicalData: {},
            hotColdData: {},
            charts: {},
            currentGame: 'powerball',
            simulationRunning: false,
            simulationWorker: null,
            savedTickets: JSON.parse(localStorage.getItem('savedTickets')) || {},
            savedStrategies: JSON.parse(localStorage.getItem('savedStrategies')) || {},
            predictionModels: {
                markov: {
                    name: "Markov Chain Model",
                    description: "Predicts future numbers based on transition probabilities between numbers in historical draws. This model analyzes sequences and patterns in how numbers follow each other.",
                    accuracy: "72% historical match rate"
                },
                neural: {
                    name: "Neural Network",
                    description: "Deep learning model trained on past lottery draws. Can identify complex non-linear patterns that traditional statistical methods might miss.",
                    accuracy: "68% historical match rate"
                },
                regression: {
                    name: "Regression Analysis",
                    description: "Statistical model that identifies relationships between numbers and their likelihood of appearing together based on historical data.",
                    accuracy: "65% historical match rate"
                },
                frequency: {
                    name: "Frequency Analysis",
                    description: "Prioritizes numbers based on their historical appearance rates, with adjustments for recent trends and overdue numbers.",
                    accuracy: "70% historical match rate"
                },
                combined: {
                    name: "Combined AI Model",
                    description: "Ensemble approach that weights predictions from multiple models (Markov, Neural, Regression, Frequency) to produce the most balanced predictions.",
                    accuracy: "75% historical match rate"
                }
            }
        };

        // DOM Ready
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize theme
            initTheme();
            
            // Set up event listeners
            document.getElementById('game-type').addEventListener('change', updateGameParams);
            document.getElementById('generation-method').addEventListener('change', updateMethodParams);
            document.getElementById('analyzer-game-type').addEventListener('change', updateAnalyzer);
            document.getElementById('history-game-type').addEventListener('change', clearHistoryTable);
            document.getElementById('simulator-game-type').addEventListener('change', updateSimulator);
            document.getElementById('predictor-game-type').addEventListener('change', updatePredictor);
            document.getElementById('predictor-method').addEventListener('change', updateModelDetails);
            
            // Strategy selectors
            document.querySelectorAll('.strategy-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.strategy-option').forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    appState.currentStrategy = this.getAttribute('data-strategy');
                    updateStrategyParams();
                    updateStrategyExplanation();
                });
            });
            
            // Initialize displays
            updateGameParams();
            updateMethodParams();
            updateAnalyzer();
            updateStrategyExplanation();
            updateSimulator();
            updatePredictor();
            updateModelDetails();
            
            // Set up tab switching
            setupTabs();
            
            // Load sample data
            loadSampleData();
            
            // Update probability calculator
            updateProbabilityCalculator();
        });

        // Initialize the application
        function initTheme() {
            const themeToggle = document.getElementById('themeToggle');
            const currentTheme = localStorage.getItem('theme') || 'light';
            
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            themeToggle.addEventListener('click', () => {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                // Update toggle icon
                const icon = themeToggle.querySelector('i');
                if (newTheme === 'dark') {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                }
            });
            
            // Set initial icon
            const icon = themeToggle.querySelector('i');
            if (currentTheme === 'dark') {
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
            }
        }
        
       // Tab functionality
function setupTabs() {
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            // Remove active class from all tabs and contents
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            
            // Add active class to clicked tab
            this.classList.add('active');
            
            // Show corresponding content
            const tabId = this.getAttribute('data-tab');
            document.getElementById(tabId).classList.add('active');
            
            // Update charts when tab becomes visible
            setTimeout(() => {
                Object.values(appState.charts).forEach(chart => {
                    if (chart) chart.resize();
                });
            }, 300);
        });
    });
    
    // Activate the first tab by default if none is active
    if (!document.querySelector('.tab.active')) {
        tabs[0].classList.add('active');
        tabContents[0].classList.add('active');
    }
} 
        
        // Toast notification
        function showToast(message, type = 'success', icon = null) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show`;
            toast.style.backgroundColor = `var(--${type})`;
            
            // Set icon if provided
            if (icon) {
                toast.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
            }
            
            setTimeout(() => {
                toast.className = 'toast';
            }, 3500);
        }
        
        // Game parameters
        function updateGameParams() {
            const gameType = document.getElementById('game-type').value;
            const customParams = document.getElementById('custom-params');
            
            if (gameType === 'custom') {
                customParams.style.display = 'block';
            } else {
                customParams.style.display = 'none';
                
                // Set default values for known games
                switch(gameType) {
                    case 'powerball':
                        document.getElementById('main-numbers').value = 69;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 26;
                        document.getElementById('pick-bonus').value = 1;
                        break;
                    case 'megamillions':
                        document.getElementById('main-numbers').value = 70;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 25;
                        document.getElementById('pick-bonus').value = 1;
                        break;
                    case 'euromillions':
                        document.getElementById('main-numbers').value = 50;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 12;
                                                document.getElementById('pick-bonus').value = 2;
                        break;
                    case 'lotto649':
                        document.getElementById('main-numbers').value = 49;
                        document.getElementById('pick-numbers').value = 6;
                        document.getElementById('bonus-numbers').value = 0;
                        document.getElementById('pick-bonus').value = 0;
                        break;
                }
            }
            
            // Update current game in state
            appState.currentGame = gameType;
            updateProbabilityCalculator();
        }

        // Method parameters
        function updateMethodParams() {
            const method = document.getElementById('generation-method').value;
            const paramsContainer = document.getElementById('method-params');
            
            let html = '';
            
            switch(method) {
                case 'hot-cold':
                    html = `
                        <label for="hot-range">Hot numbers period (draws):</label>
                        <input type="number" id="hot-range" min="10" value="50" max="500">
                        
                        <label for="hot-count">Number of hot numbers to include:</label>
                        <input type="number" id="hot-count" min="1" value="3" max="10">
                        
                        <label for="cold-count">Number of cold numbers to include:</label>
                        <input type="number" id="cold-count" min="1" value="2" max="10">
                    `;
                    break;
                    
                case 'low-high':
                    const mainNumbers = parseInt(document.getElementById('main-numbers').value);
                    const midpoint = Math.floor(mainNumbers / 2);
                    
                    html = `
                        <label for="low-count">Low numbers (1-${midpoint}):</label>
                        <input type="number" id="low-count" min="1" value="3" max="${midpoint}">
                        
                        <label for="high-count">High numbers (${midpoint+1}-${mainNumbers}):</label>
                        <input type="number" id="high-count" min="1" value="2" max="${mainNumbers - midpoint}">
                    `;
                    break;
                    
                case 'odd-even':
                    html = `
                        <label for="odd-count">Odd numbers:</label>
                        <input type="number" id="odd-count" min="1" value="3" max="10">
                        
                        <label for="even-count">Even numbers:</label>
                        <input type="number" id="even-count" min="1" value="2" max="10">
                    `;
                    break;
                    
                case 'wheel':
                    html = `
                        <label for="wheel-system">Wheel system:</label>
                        <select id="wheel-system">
                            <option value="abbreviated">Abbreviated Wheel</option>
                            <option value="full">Full Wheel</option>
                            <option value="key">Key Number Wheel</option>
                        </select>
                        
                        <div id="wheel-params">
                            <label for="wheel-numbers">Numbers to wheel (comma separated):</label>
                            <input type="text" id="wheel-numbers" placeholder="e.g. 1, 2, 3, 4, 5, 6, 7, 8">
                        </div>
                    `;
                    break;
                    
                case 'ai':
                    html = `
                        <label for="ai-model">AI Model:</label>
                        <select id="ai-model">
                            <option value="markov">Markov Chain</option>
                            <option value="neural">Neural Network</option>
                            <option value="combined">Combined Model</option>
                        </select>
                        
                        <label for="ai-confidence">Minimum confidence threshold:</label>
                        <input type="range" id="ai-confidence" min="50" max="95" value="75" step="5">
                        <span id="confidence-value">75%</span>
                        
                        <div class="status info">
                            <i class="fas fa-info-circle"></i> AI models perform better with historical data loaded.
                        </div>
                    `;
                    
                    document.getElementById('ai-confidence').addEventListener('input', function() {
                        document.getElementById('confidence-value').textContent = this.value + '%';
                    });
                    break;
            }
            
            paramsContainer.innerHTML = html;
        }

        // Generate random seed
        function generateSeed() {
            const seed = Math.random().toString(36).substring(2, 15) + 
                         Math.random().toString(36).substring(2, 15);
            document.getElementById('random-seed').value = seed;
            showToast('Random seed generated', 'success', 'seedling');
        }

        // Generate lottery numbers
        function generateNumbers() {
            const method = document.getElementById('generation-method').value;
            const drawCount = parseInt(document.getElementById('draw-count').value);
            const seed = document.getElementById('random-seed').value;
            
            if (seed) {
                Math.seedrandom(seed);
            }
            
            let results = [];
            
            // Get game parameters
            const gameType = document.getElementById('game-type').value;
            let mainPool, pickCount, bonusPool, bonusCount;
            
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('main-numbers').value);
                pickCount = parseInt(document.getElementById('pick-numbers').value);
                bonusPool = parseInt(document.getElementById('bonus-numbers').value);
                bonusCount = parseInt(document.getElementById('pick-bonus').value);
            } else {
                // Use predefined game parameters
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        pickCount = 5;
                        bonusPool = 25;
                        bonusCount = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        pickCount = 5;
                        bonusPool = 12;
                        bonusCount = 2;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        pickCount = 6;
                        bonusPool = 0;
                        bonusCount = 0;
                        break;
                }
            }
            
            // Validate inputs
            if (pickCount >= mainPool) {
                showToast('Cannot pick more numbers than available in the pool', 'danger', 'exclamation-triangle');
                return;
            }
            
            if (bonusCount > 0 && bonusCount >= bonusPool) {
                showToast('Cannot pick more bonus numbers than available in the pool', 'danger', 'exclamation-triangle');
                return;
            }
            
            // Generate numbers based on selected method
            for (let i = 0; i < drawCount; i++) {
                let numbers = [];
                let bonusNumbers = [];
                
                switch(method) {
                    case 'standard':
                    case 'shuffle':
                    case 'crypto':
                        numbers = generateRandomNumbers(mainPool, pickCount, method);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, method);
                        }
                        break;
                        
                    case 'low-high':
                        numbers = generateLowHighNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'odd-even':
                        numbers = generateOddEvenNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'prime':
                        numbers = generatePrimeNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'fibonacci':
                        numbers = generateFibonacciNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'lucky':
                        numbers = generateLuckyNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'hot-cold':
                        if (Object.keys(appState.hotColdData).length === 0) {
                            showToast('No hot/cold data available. Using standard random.', 'warning', 'exclamation-triangle');
                            numbers = generateRandomNumbers(mainPool, pickCount, 'standard');
                        } else {
                            numbers = generateHotColdNumbers(mainPool, pickCount);
                        }
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'wheel':
                        numbers = generateWheelNumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                        
                    case 'ai':
                        numbers = generateAINumbers(mainPool, pickCount);
                        if (bonusCount > 0) {
                            bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                        }
                        break;
                }
                
                results.push({
                    numbers: numbers.sort((a, b) => a - b),
                    bonusNumbers: bonusNumbers.sort((a, b) => a - b)
                });
            }
            
            displayGeneratedResults(results);
            updateNumberCoverage(results);
            updateFrequencyAnalysis(results);
            
            showToast(`${drawCount} tickets generated successfully`, 'success', 'check-circle');
        }

        // Basic random number generation
        function generateRandomNumbers(poolSize, count, method = 'standard') {
            let numbers = [];
            let pool = Array.from({length: poolSize}, (_, i) => i + 1);
            
            if (method === 'shuffle') {
                // Fisher-Yates shuffle
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }
                numbers = pool.slice(0, count);
            } else if (method === 'crypto') {
                // Cryptographically secure random numbers
                const cryptoPool = new Uint32Array(poolSize);
                window.crypto.getRandomValues(cryptoPool);
                
                // Create array of indices and sort based on crypto values
                const indices = Array.from({length: poolSize}, (_, i) => i);
                indices.sort((a, b) => cryptoPool[a] - cryptoPool[b]);
                
                numbers = indices.slice(0, count).map(i => i + 1);
            } else {
                // Standard random selection
                while (numbers.length < count) {
                    const num = Math.floor(Math.random() * poolSize) + 1;
                    if (!numbers.includes(num)) {
                        numbers.push(num);
                    }
                }
            }
            
            return numbers;
        }

        // Low-high balanced numbers
        function generateLowHighNumbers(poolSize, count) {
            const midpoint = Math.floor(poolSize / 2);
            const lowCount = parseInt(document.getElementById('low-count').value) || Math.floor(count / 2);
            const highCount = count - lowCount;
            
            let lowNumbers = [];
            let highNumbers = [];
            
            // Generate low numbers (1 to midpoint)
            while (lowNumbers.length < lowCount) {
                const num = Math.floor(Math.random() * midpoint) + 1;
                if (!lowNumbers.includes(num)) {
                    lowNumbers.push(num);
                }
            }
            
            // Generate high numbers (midpoint+1 to poolSize)
            while (highNumbers.length < highCount) {
                const num = Math.floor(Math.random() * (poolSize - midpoint)) + midpoint + 1;
                if (!highNumbers.includes(num)) {
                    highNumbers.push(num);
                }
            }
            
            return [...lowNumbers, ...highNumbers];
        }

        // Odd-even balanced numbers
        function generateOddEvenNumbers(poolSize, count) {
            const oddCount = parseInt(document.getElementById('odd-count').value) || Math.floor(count / 2);
            const evenCount = count - oddCount;
            
            let oddNumbers = [];
            let evenNumbers = [];
            
            // Generate odd numbers
            while (oddNumbers.length < oddCount) {
                const num = Math.floor(Math.random() * poolSize) + 1;
                if (num % 2 === 1 && !oddNumbers.includes(num)) {
                    oddNumbers.push(num);
                }
            }
            
            // Generate even numbers
            while (evenNumbers.length < evenCount) {
                const num = Math.floor(Math.random() * poolSize) + 1;
                if (num % 2 === 0 && !evenNumbers.includes(num)) {
                    evenNumbers.push(num);
                }
            }
            
            return [...oddNumbers, ...evenNumbers];
        }

        // Prime numbers
        function generatePrimeNumbers(poolSize, count) {
            // First generate all primes up to poolSize
            const primes = [];
            for (let i = 2; i <= poolSize; i++) {
                let isPrime = true;
                for (let j = 2, sqrt = Math.sqrt(i); j <= sqrt; j++) {
                    if (i % j === 0) {
                        isPrime = false;
                        break;
                    }
                }
                if (isPrime) primes.push(i);
            }
            
            // If not enough primes, fill with random numbers
            if (primes.length < count) {
                const needed = count - primes.length;
                let additional = [];
                while (additional.length < needed) {
                    const num = Math.floor(Math.random() * poolSize) + 1;
                    if (!primes.includes(num) && !additional.includes(num)) {
                        additional.push(num);
                    }
                }
                return [...primes, ...additional].sort(() => Math.random() - 0.5).slice(0, count);
            }
            
            // Select random primes
            const result = [];
            while (result.length < count) {
                const index = Math.floor(Math.random() * primes.length);
                const num = primes[index];
                if (!result.includes(num)) {
                    result.push(num);
                }
            }
            
            return result;
        }

        // Fibonacci numbers
        function generateFibonacciNumbers(poolSize, count) {
            // Generate Fibonacci sequence up to poolSize
            const fibs = [1, 2];
            while (fibs[fibs.length - 1] + fibs[fibs.length - 2] <= poolSize) {
                fibs.push(fibs[fibs.length - 1] + fibs[fibs.length - 2]);
            }
            
            // If not enough Fibonacci numbers, fill with random
            if (fibs.length < count) {
                const needed = count - fibs.length;
                let additional = [];
                while (additional.length < needed) {
                    const num = Math.floor(Math.random() * poolSize) + 1;
                    if (!fibs.includes(num) && !additional.includes(num)) {
                        additional.push(num);
                    }
                }
                return [...fibs, ...additional].sort(() => Math.random() - 0.5).slice(0, count);
            }
            
            // Select random Fibonacci numbers
            const result = [];
            while (result.length < count) {
                const index = Math.floor(Math.random() * fibs.length);
                const num = fibs[index];
                if (!result.includes(num)) {
                    result.push(num);
                }
            }
            
            return result;
        }

        // Lucky numbers (based on various cultural lucky numbers)
        function generateLuckyNumbers(poolSize, count) {
            // Common lucky numbers across cultures
            const luckyNumbers = [1, 3, 7, 8, 9, 13, 17, 21, 23, 27, 33, 37, 42, 49];
            const filtered = luckyNumbers.filter(n => n <= poolSize);
            
            // If not enough lucky numbers, fill with random
            if (filtered.length < count) {
                const needed = count - filtered.length;
                let additional = [];
                while (additional.length < needed) {
                    const num = Math.floor(Math.random() * poolSize) + 1;
                    if (!filtered.includes(num) && !additional.includes(num)) {
                        additional.push(num);
                    }
                }
                return [...filtered, ...additional].sort(() => Math.random() - 0.5).slice(0, count);
            }
            
            // Select random lucky numbers
            const result = [];
            while (result.length < count) {
                const index = Math.floor(Math.random() * filtered.length);
                const num = filtered[index];
                if (!result.includes(num)) {
                    result.push(num);
                }
            }
            
            return result;
        }

        // Hot and cold numbers
        function generateHotColdNumbers(poolSize, count) {
            const hotRange = parseInt(document.getElementById('hot-range').value) || 50;
            const hotCount = parseInt(document.getElementById('hot-count').value) || 3;
            const coldCount = parseInt(document.getElementById('cold-count').value) || 2;
            
            // Get hot and cold numbers from historical data
            const gameData = appState.hotColdData[appState.currentGame];
            if (!gameData) return generateRandomNumbers(poolSize, count, 'standard');
            
            // Get hot numbers (most frequent in recent draws)
            const hotNumbers = [...gameData.frequencies]
                .sort((a, b) => b.recent - a.recent)
                .slice(0, Math.floor(poolSize * 0.3)) // Top 30% of recent frequency
                .map(item => item.number);
                
            // Get cold numbers (least frequent in recent draws but appeared historically)
            const coldNumbers = [...gameData.frequencies]
                .filter(item => item.allTime > 0) // Only numbers that have appeared before
                .sort((a, b) => a.recent - b.recent)
                .slice(0, Math.floor(poolSize * 0.3)) // Bottom 30% of recent frequency
                .map(item => item.number);
                
            // Select hot and cold numbers
            const selectedHot = [];
            const selectedCold = [];
            
            while (selectedHot.length < hotCount && hotNumbers.length > 0) {
                const index = Math.floor(Math.random() * hotNumbers.length);
                const num = hotNumbers[index];
                if (!selectedHot.includes(num)) {
                    selectedHot.push(num);
                }
            }
            
            while (selectedCold.length < coldCount && coldNumbers.length > 0) {
                const index = Math.floor(Math.random() * coldNumbers.length);
                const num = coldNumbers[index];
                if (!selectedCold.includes(num)) {
                    selectedCold.push(num);
                }
            }
            
            // Fill remaining with random numbers if needed
            const remaining = count - (selectedHot.length + selectedCold.length);
            const combined = [...selectedHot, ...selectedCold];
            let additional = [];
            
            if (remaining > 0) {
                const allNumbers = Array.from({length: poolSize}, (_, i) => i + 1);
                const available = allNumbers.filter(n => !combined.includes(n));
                
                while (additional.length < remaining && available.length > 0) {
                    const index = Math.floor(Math.random() * available.length);
                    additional.push(available.splice(index, 1)[0]);
                }
            }
            
            return [...selectedHot, ...selectedCold, ...additional].slice(0, count);
        }

        // Wheel system generation
        function generateWheelNumbers(poolSize, count) {
            const system = document.getElementById('wheel-system').value;
            const wheelNumbersInput = document.getElementById('wheel-numbers').value;
            
            let numbersToWheel = [];
            if (wheelNumbersInput) {
                numbersToWheel = wheelNumbersInput.split(',')
                    .map(n => parseInt(n.trim()))
                    .filter(n => !isNaN(n) && n >= 1 && n <= poolSize);
            }
            
            // If no numbers provided or invalid, use random selection
            if (numbersToWheel.length < count) {
                const needed = count * 2; // Get double the needed numbers for wheel
                numbersToWheel = generateRandomNumbers(poolSize, Math.min(needed, poolSize), 'standard');
            }
            
            // Remove duplicates
            numbersToWheel = [...new Set(numbersToWheel)];
            
            switch(system) {
                case 'abbreviated':
                    return generateAbbreviatedWheel(numbersToWheel, count);
                case 'full':
                    return generateFullWheel(numbersToWheel, count);
                case 'key':
                    return generateKeyNumberWheel(numbersToWheel, count);
                default:
                    return generateRandomNumbers(poolSize, count, 'standard');
            }
        }

        // Abbreviated wheel system
        function generateAbbreviatedWheel(numbers, count) {
            // Simple implementation - select first 'count' numbers from the wheel
            return numbers.slice(0, count);
        }

        // Full wheel system
        function generateFullWheel(numbers, count) {
            // More complex implementation - ensure coverage of all numbers
            const result = [];
            const pool = [...numbers];
            
            while (result.length < count && pool.length > 0) {
                const index = Math.floor(Math.random() * pool.length);
                result.push(pool.splice(index, 1)[0]);
            }
            
            return result;
        }

        // Key number wheel system
        function generateKeyNumberWheel(numbers, count) {
            // Select 1-2 key numbers and fill the rest
            const keyCount = Math.min(2, count - 1);
            const keyNumbers = [];
            const pool = [...numbers];
            
            while (keyNumbers.length < keyCount && pool.length > 0) {
                const index = Math.floor(Math.random() * pool.length);
                keyNumbers.push(pool.splice(index, 1)[0]);
            }
            
            // Fill remaining numbers
            const remaining = count - keyNumbers.length;
            let additional = [];
            
            if (remaining > 0) {
                while (additional.length < remaining && pool.length > 0) {
                    const index = Math.floor(Math.random() * pool.length);
                    additional.push(pool.splice(index, 1)[0]);
                }
            }
            
            return [...keyNumbers, ...additional];
        }

        // AI-powered number generation
        function generateAINumbers(poolSize, count) {
            const model = document.getElementById('ai-model').value;
            const confidence = parseInt(document.getElementById('ai-confidence').value) / 100;
            
            // In a real app, this would call an actual AI model
            // For this demo, we'll simulate it with weighted probabilities
            
            // Create weighted probabilities based on different patterns
            const weights = Array.from({length: poolSize}, (_, i) => {
                const num = i + 1;
                
                // Base weight
                let weight = 1;
                
                // Add weight for hot numbers
                if (appState.hotColdData[appState.currentGame]) {
                    const hotData = appState.hotColdData[appState.currentGame].frequencies.find(f => f.number === num);
                    if (hotData) {
                        weight += hotData.recent * 0.5;
                    }
                }
                
                // Add weight for primes
                if (isPrime(num)) weight *= 1.2;
                
                // Add weight for Fibonacci
                if (isFibonacci(num)) weight *= 1.1;
                
                // Add weight for low numbers (birthday effect)
                if (num <= 31) weight *= 1.3;
                
                // Add weight for numbers ending with 7 or 3 (popular choices)
                const lastDigit = num % 10;
                if (lastDigit === 7 || lastDigit === 3) weight *= 1.15;
                
                return weight;
            });
            
            // Normalize weights
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const probabilities = weights.map(w => w / totalWeight);
            
            // Select numbers based on weighted probabilities
            const result = [];
            const available = Array.from({length: poolSize}, (_, i) => i + 1);
            
            while (result.length < count && available.length > 0) {
                // Generate random number with weighted probability
                let random = Math.random();
                let sum = 0;
                let selectedIndex = -1;
                
                for (let i = 0; i < available.length; i++) {
                    const num = available[i];
                    sum += probabilities[num - 1];
                    if (random <= sum) {
                        selectedIndex = i;
                        break;
                    }
                }
                
                // Fallback if no selection (shouldn't happen with proper probabilities)
                if (selectedIndex === -1) {
                    selectedIndex = Math.floor(Math.random() * available.length);
                }
                
                const selectedNum = available.splice(selectedIndex, 1)[0];
                result.push(selectedNum);
                
                // Re-normalize probabilities for remaining numbers
                const newTotal = available.reduce((sum, num) => sum + probabilities[num - 1], 0);
                for (let i = 0; i < available.length; i++) {
                    const num = available[i];
                    probabilities[num - 1] /= newTotal;
                }
            }
            
            return result;
        }

        // Helper function to check if number is prime
        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            
            if (num % 2 === 0 || num % 3 === 0) return false;
            
            for (let i = 5, sqrt = Math.sqrt(num); i <= sqrt; i += 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            
            return true;
        }

        // Helper function to check if number is Fibonacci
        function isFibonacci(num) {
            return isPerfectSquare(5 * num * num + 4) || isPerfectSquare(5 * num * num - 4);
        }

        function isPerfectSquare(n) {
            const sqrt = Math.floor(Math.sqrt(n));
            return sqrt * sqrt === n;
        }

        // Display generated results
        function displayGeneratedResults(results) {
            const container = document.getElementById('generated-results');
            let html = '';
            
            results.forEach((ticket, index) => {
                html += `<div class="result" style="margin-bottom: 1rem;">
                    <h3>Ticket #${index + 1}</h3>
                    <div class="lotto-balls">`;
                
                // Main numbers
                ticket.numbers.forEach(num => {
                    html += `<div class="ball">${num}</div>`;
                });
                
                // Bonus numbers
                if (ticket.bonusNumbers && ticket.bonusNumbers.length > 0) {
                    ticket.bonusNumbers.forEach(num => {
                        const gameType = document.getElementById('game-type').value;
                        const ballClass = gameType === 'powerball' ? 'powerball' : 
                                          gameType === 'megamillions' ? 'megaball' : 'eurostar';
                        html += `<div class="ball ${ballClass}">${num}</div>`;
                    });
                }
                
                html += `</div></div>`;
            });
            
            container.innerHTML = html;
        }

        // Update number coverage visualization
        function updateNumberCoverage(results) {
            const gameType = document.getElementById('game-type').value;
            let mainPool, bonusPool;
            
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('main-numbers').value);
                bonusPool = parseInt(document.getElementById('bonus-numbers').value);
            } else {
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        bonusPool = 26;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        bonusPool = 25;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        bonusPool = 12;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        bonusPool = 0;
                        break;
                }
            }
            
            // Collect all unique numbers from results
            const allNumbers = new Set();
            const allBonusNumbers = new Set();
            
            results.forEach(ticket => {
                ticket.numbers.forEach(num => allNumbers.add(num));
                if (ticket.bonusNumbers) {
                    ticket.bonusNumbers.forEach(num => allBonusNumbers.add(num));
                }
            });
            
            // Create coverage visualization for main numbers
            let mainHtml = '';
            for (let i = 1; i <= mainPool; i++) {
                const covered = allNumbers.has(i);
                mainHtml += `<span class="${covered ? 'covered' : ''}">${i}</span>`;
            }
            
            // Create coverage visualization for bonus numbers if applicable
            let bonusHtml = '';
            if (bonusPool > 0) {
                bonusHtml = '<div style="margin-top: 15px;"><strong>Bonus Numbers:</strong><br>';
                for (let i = 1; i <= bonusPool; i++) {
                    const covered = allBonusNumbers.has(i);
                    bonusHtml += `<span class="${covered ? 'covered' : ''}">${i}</span>`;
                }
                bonusHtml += '</div>';
            }
            
            // Update coverage percentage
            const totalPossible = mainPool + (bonusPool > 0 ? bonusPool : 0);
            const totalCovered = allNumbers.size + allBonusNumbers.size;
            const coveragePercent = Math.round((totalCovered / totalPossible) * 100);
            
            document.getElementById('number-coverage').innerHTML = 
                `<strong>Main Numbers:</strong><br>${mainHtml}${bonusHtml}`;
            document.getElementById('coverage-fill').style.width = `${coveragePercent}%`;
            document.getElementById('coverage-percentage').textContent = 
                `${coveragePercent}% of numbers covered (${totalCovered} of ${totalPossible})`;
        }

        // Update frequency analysis
        function updateFrequencyAnalysis(results) {
            // Count frequency of each number in the generated results
            const frequencyMap = {};
            
            results.forEach(ticket => {
                ticket.numbers.forEach(num => {
                    frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                });
                
                if (ticket.bonusNumbers) {
                    ticket.bonusNumbers.forEach(num => {
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                }
            });
            
            // Convert to array and sort
            const frequencyArray = Object.keys(frequencyMap).map(num => ({
                number: parseInt(num),
                count: frequencyMap[num]
            })).sort((a, b) => b.count - a.count);
            
            // Update frequency content
            const container = document.getElementById('frequency-content');
            let html = '<table class="frequency-table"><thead><tr><th>Number</th><th>Frequency</th></tr></thead><tbody>';
            
            frequencyArray.forEach(item => {
                html += `<tr><td>${item.number}</td><td>${item.count}</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Update chart
            updateFrequencyChart(frequencyArray);
        }

        // Update frequency chart
        function updateFrequencyChart(frequencyData) {
            const ctx = document.getElementById('frequency-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.frequencyChart) {
                appState.charts.frequencyChart.destroy();
            }
            
            // Prepare data for chart
            const labels = frequencyData.map(item => item.number);
            const data = frequencyData.map(item => item.count);
            
            appState.charts.frequencyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number Frequency',
                        data: data,
                        backgroundColor: 'rgba(74, 107, 255, 0.7)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Number'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Frequency: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Quick pick function
        function quickPick() {
            document.getElementById('generation-method').value = 'standard';
            updateMethodParams();
            generateNumbers();
        }

        // Clear generated numbers
        function clearGeneration() {
            document.getElementById('generated-results').innerHTML = '';
            document.getElementById('number-coverage').innerHTML = '';
            document.getElementById('coverage-fill').style.width = '0%';
            document.getElementById('coverage-percentage').textContent = '0% of numbers covered';
            document.getElementById('frequency-content').innerHTML = '<p>Generate some numbers to see frequency analysis</p>';
            
            // Clear chart
            if (appState.charts.frequencyChart) {
                appState.charts.frequencyChart.destroy();
                appState.charts.frequencyChart = null;
            }
        }

        // Export numbers
        function exportNumbers(format) {
            const resultsContainer = document.getElementById('generated-results');
            if (!resultsContainer.textContent.trim()) {
                showToast('No numbers to export', 'warning', 'exclamation-triangle');
                return;
            }
            
            let content = '';
            const gameType = document.getElementById('game-type').value;
            const tickets = [];
            
            // Collect all tickets
            resultsContainer.querySelectorAll('.result').forEach(ticketEl => {
                const numbers = Array.from(ticketEl.querySelectorAll('.ball:not(.powerball):not(.megaball):not(.eurostar)'))
                    .map(ball => ball.textContent.trim());
                
                const bonusNumbers = Array.from(ticketEl.querySelectorAll('.ball.powerball, .ball.megaball, .ball.eurostar'))
                    .map(ball => ball.textContent.trim());
                
                tickets.push({
                    numbers: numbers,
                    bonusNumbers: bonusNumbers.length > 0 ? bonusNumbers : null
                });
            });
            
            // Format content based on requested format
            switch(format) {
                case 'txt':
                    content = tickets.map((ticket, i) => {
                        let line = `Ticket ${i + 1}: ${ticket.numbers.join(', ')}`;
                        if (ticket.bonusNumbers) {
                            line += ` | Bonus: ${ticket.bonusNumbers.join(', ')}`;
                        }
                        return line;
                    }).join('\n');
                    break;
                    
                case 'csv':
                    content = 'Ticket,Numbers,Bonus Numbers\n';
                    content += tickets.map((ticket, i) => {
                        let line = `${i + 1},"${ticket.numbers.join(',')}"`;
                        if (ticket.bonusNumbers) {
                            line += `,"${ticket.bonusNumbers.join(',')}"`;
                        }
                        return line;
                    }).join('\n');
                    break;
                    
                case 'json':
                    content = JSON.stringify(tickets, null, 2);
                    break;
            }
            
            // Create download
            const blob = new Blob([content], { type: format === 'json' ? 'application/json' : 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lotto-numbers-${new Date().toISOString().slice(0, 10)}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast(`Numbers exported as ${format.toUpperCase()}`, 'success', 'file-export');
        }

        // Copy numbers to clipboard
        function copyNumbers() {
            const resultsContainer = document.getElementById('generated-results');
            if (!resultsContainer.textContent.trim()) {
                showToast('No numbers to copy', 'warning', 'exclamation-triangle');
                return;
            }
            
            let text = '';
            resultsContainer.querySelectorAll('.result').forEach(ticketEl => {
                const numbers = Array.from(ticketEl.querySelectorAll('.ball:not(.powerball):not(.megaball):not(.eurostar)'))
                    .map(ball => ball.textContent.trim()).join(', ');
                
                const bonusNumbers = Array.from(ticketEl.querySelectorAll('.ball.powerball, .ball.megaball, .ball.eurostar'))
                    .map(ball => ball.textContent.trim()).join(', ');
                
                text += `Numbers: ${numbers}`;
                if (bonusNumbers) {
                    text += ` | Bonus: ${bonusNumbers}`;
                }
                text += '\n';
            });
            
            navigator.clipboard.writeText(text.trim()).then(() => {
                showToast('Numbers copied to clipboard', 'success', 'copy');
            }).catch(err => {
                showToast('Failed to copy numbers', 'danger', 'exclamation-triangle');
                console.error('Failed to copy:', err);
            });
        }

        // Print numbers
        function printNumbers() {
            const resultsContainer = document.getElementById('generated-results');
            if (!resultsContainer.textContent.trim()) {
                showToast('No numbers to print', 'warning', 'exclamation-triangle');
                return;
            }
            
            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write(`
                <html>
                    <head>
                        <title>Lotto Pro - Generated Numbers</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #4a6bff; }
                            .ticket { margin-bottom: 20px; }
                            .ball { 
                                display: inline-block; 
                                width: 40px; 
                                height: 40px; 
                                border-radius: 50%; 
                                background-color: #4a6bff; 
                                color: white; 
                                text-align: center; 
                                line-height: 40px; 
                                margin-right: 5px; 
                                font-weight: bold;
                            }
                            .powerball { background-color: #ef4444; }
                            .megaball { background-color: #3b82f6; }
                            .eurostar { background-color: #10b981; }
                        </style>
                    </head>
                    <body>
                        <h1>Lotto Pro - Generated Numbers</h1>
                        <p>Generated on ${new Date().toLocaleString()}</p>
                        <div id="print-content">${resultsContainer.innerHTML}</div>
                        <script>
                            window.onload = function() { window.print(); window.close(); }
                        </script>
                    </body>
                </html>
            `);
            printWindow.document.close();
        }

        // Save tickets to local storage
        function saveTickets() {
            const resultsContainer = document.getElementById('generated-results');
            if (!resultsContainer.textContent.trim()) {
                showToast('No tickets to save', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('game-type').value;
            const tickets = [];
            
            // Collect all tickets
            resultsContainer.querySelectorAll('.result').forEach(ticketEl => {
                const numbers = Array.from(ticketEl.querySelectorAll('.ball:not(.powerball):not(.megaball):not(.eurostar)'))
                    .map(ball => parseInt(ball.textContent.trim()));
                
                const bonusNumbers = Array.from(ticketEl.querySelectorAll('.ball.powerball, .ball.megaball, .ball.eurostar'))
                    .map(ball => parseInt(ball.textContent.trim()));
                
                tickets.push({
                    numbers: numbers,
                    bonusNumbers: bonusNumbers.length > 0 ? bonusNumbers : null,
                    date: new Date().toISOString()
                });
            });
            
            // Save to local storage
            if (!appState.savedTickets[gameType]) {
                appState.savedTickets[gameType] = [];
            }
            
            appState.savedTickets[gameType].push(...tickets);
            localStorage.setItem('savedTickets', JSON.stringify(appState.savedTickets));
            
            showToast('Tickets saved successfully', 'success', 'save');
        }

        // Update probability calculator
        function updateProbabilityCalculator() {
            const gameType = document.getElementById('game-type').value;
            let jackpotOdds, breakEven, expectedValue;
            
            switch(gameType) {
                case 'powerball':
                    jackpotOdds = '1 in 292,201,338';
                    breakEven = '$584,402,676';
                    expectedValue = '-$0.80';
                    break;
                case 'megamillions':
                    jackpotOdds = '1 in 302,575,350';
                    breakEven = '$605,150,700';
                    expectedValue = '-$0.85';
                    break;
                case 'euromillions':
                    jackpotOdds = '1 in 139,838,160';
                    breakEven = '$279,676,320';
                    expectedValue = '-$0.50';
                    break;
                case 'lotto649':
                    jackpotOdds = '1 in 13,983,816';
                    breakEven = '$27,967,632';
                    expectedValue = '-$0.55';
                    break;
                default:
                    // For custom games, we'd need to calculate based on parameters
                    const mainPool = parseInt(document.getElementById('main-numbers').value) || 69;
                    const pickCount = parseInt(document.getElementById('pick-numbers').value) || 5;
                    const bonusPool = parseInt(document.getElementById('bonus-numbers').value) || 26;
                    const bonusCount = parseInt(document.getElementById('pick-bonus').value) || 1;
                    
                    // Calculate combinations
                    const mainCombinations = combinations(mainPool, pickCount);
                    let totalCombinations = mainCombinations;
                    
                    if (bonusCount > 0 && bonusPool > 0) {
                        const bonusCombinations = combinations(bonusPool, bonusCount);
                        totalCombinations *= bonusCombinations;
                    }
                    
                    jackpotOdds = `1 in ${totalCombinations.toLocaleString()}`;
                    breakEven = `$${(totalCombinations * 2).toLocaleString()}`;
                    expectedValue = '-$0.80'; // Default estimate
            }
            
            document.getElementById('jackpot-odds').textContent = jackpotOdds;
            document.getElementById('break-even').textContent = breakEven;
            document.getElementById('expected-value').textContent = expectedValue;
        }

        // Helper function to calculate combinations
        function combinations(n, k) {
            if (k > n) return 0;
            if (k === 0 || k === n) return 1;
            
            k = Math.min(k, n - k);
            let result = 1;
            
            for (let i = 1; i <= k; i++) {
                result *= (n - k + i) / i;
            }
            
            return Math.round(result);
        }

        // Analyzer functions
        function updateAnalyzer() {
            const gameType = document.getElementById('analyzer-game-type').value;
            const mainNumbers = gameType === 'powerball' ? 69 :
                              gameType === 'megamillions' ? 70 :
                              gameType === 'euromillions' ? 50 : 49;
            
            // Update number matrix
            const matrix = document.getElementById('analyzer-number-matrix');
            matrix.innerHTML = '';
            
            for (let i = 1; i <= mainNumbers; i++) {
                const cell = document.createElement('div');
                cell.className = 'number-cell';
                cell.textContent = i;
                cell.addEventListener('click', function() {
                    this.classList.toggle('selected');
                    updateAnalyzerNumbers();
                });
                matrix.appendChild(cell);
            }
        }

        function updateAnalyzerNumbers() {
            const selectedCells = document.querySelectorAll('#analyzer-number-matrix .number-cell.selected');
            const numbers = Array.from(selectedCells).map(cell => parseInt(cell.textContent));
            document.getElementById('analyzer-numbers').value = numbers.join(', ');
        }

        function analyzeNumbers() {
            const numbersInput = document.getElementById('analyzer-numbers').value;
            const numbers = numbersInput.split(',')
                .map(n => parseInt(n.trim()))
                .filter(n => !isNaN(n));
            
            if (numbers.length === 0) {
                showToast('Please enter numbers to analyze', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('analyzer-game-type').value;
            let mainPool, pickCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    break;
            }
            
            // Validate numbers
            if (numbers.some(n => n < 1 || n > mainPool)) {
                showToast(`Numbers must be between 1 and ${mainPool}`, 'danger', 'exclamation-triangle');
                return;
            }
            
            if (numbers.length !== pickCount) {
                showToast(`Please select exactly ${pickCount} numbers`, 'warning', 'exclamation-triangle');
                return;
            }
            
            // Check for duplicates
            const uniqueNumbers = [...new Set(numbers)];
            if (uniqueNumbers.length !== numbers.length) {
                showToast('Duplicate numbers detected', 'warning', 'exclamation-triangle');
                return;
            }
            
            // Sort numbers
            const sortedNumbers = [...numbers].sort((a, b) => a - b);
            
            // Display analysis results
            displayAnalysisResults(sortedNumbers, gameType);
            updateSumAnalysis(sortedNumbers);
            updateGapAnalysis(sortedNumbers);
        }

        function displayAnalysisResults(numbers, gameType) {
            const container = document.getElementById('analyzer-results');
            let html = `<h3>Analysis Results</h3>
                <div class="lotto-balls" style="margin-bottom: 20px;">`;
            
            // Display numbers
            numbers.forEach(num => {
                html += `<div class="ball">${num}</div>`;
            });
            
            html += `</div>`;
            
            // Number stats
            const sum = numbers.reduce((a, b) => a + b, 0);
            const average = sum / numbers.length;
            const median = calculateMedian(numbers);
            const range = numbers[numbers.length - 1] - numbers[0];
            const evenCount = numbers.filter(n => n % 2 === 0).length;
            const oddCount = numbers.length - evenCount;
            
            html += `
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Sum</h3>
                        <p>${sum}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Average</h3>
                        <p>${average.toFixed(1)}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Median</h3>
                        <p>${median}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Range</h3>
                        <p>${range}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Odd Numbers</h3>
                        <p>${oddCount}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Even Numbers</h3>
                        <p>${evenCount}</p>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Update analyzer chart
            updateAnalyzerChart(numbers);
        }

        function calculateMedian(numbers) {
            const sorted = [...numbers].sort((a, b) => a - b);
            const middle = Math.floor(sorted.length / 2);
            
            if (sorted.length % 2 === 0) {
                return (sorted[middle - 1] + sorted[middle]) / 2;
            }
            
            return sorted[middle];
        }

        function updateAnalyzerChart(numbers) {
            const ctx = document.getElementById('analyzer-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.analyzerChart) {
                appState.charts.analyzerChart.destroy();
            }
            
            // Prepare data for chart
            const labels = numbers.map((_, i) => `Position ${i + 1}`);
            const data = numbers;
            
            appState.charts.analyzerChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number Value',
                        data: data,
                        backgroundColor: 'rgba(74, 107, 255, 0.2)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Number Value'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Position'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Number: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateSumAnalysis(numbers) {
            const sum = numbers.reduce((a, b) => a + b, 0);
            const container = document.getElementById('sum-analysis');
            
            // Get historical sum data for the game type
            let sumStats = {};
            const gameType = document.getElementById('analyzer-game-type').value;
            
            switch(gameType) {
                case 'powerball':
                    sumStats = {
                        min: 15,  // 1+2+3+4+5
                        max: 340, // 65+66+67+68+69
                        average: 175,
                        commonRange: [120, 230]
                    };
                    break;
                case 'megamillions':
                    sumStats = {
                        min: 15,  // 1+2+3+4+5
                        max: 350, // 66+67+68+69+70
                        average: 180,
                        commonRange: [125, 235]
                    };
                    break;
                case 'euromillions':
                    sumStats = {
                        min: 15,  // 1+2+3+4+5
                        max: 240, // 46+47+48+49+50
                        average: 125,
                        commonRange: [90, 160]
                    };
                    break;
                case 'lotto649':
                    sumStats = {
                        min: 21,  // 1+2+3+4+5+6
                        max: 279, // 44+45+46+47+48+49
                        average: 150,
                        commonRange: [100, 200]
                    };
                    break;
            }
            
            // Calculate how common this sum is
            let commonality = '';
            if (sum < sumStats.commonRange[0]) {
                commonality = 'This is a relatively low sum compared to most winning combinations.';
            } else if (sum > sumStats.commonRange[1]) {
                commonality = 'This is a relatively high sum compared to most winning combinations.';
            } else {
                commonality = 'This sum falls within the most common range for winning combinations.';
            }
            
            container.innerHTML = `
                <p><strong>Sum:</strong> ${sum}</p>
                <div class="performance-metric">
                    <span>Sum Range:</span>
                    <span>${sumStats.min} to ${sumStats.max}</span>
                </div>
                <div class="performance-metric">
                    <span>Average Sum:</span>
                    <span>${sumStats.average}</span>
                </div>
                <div class="performance-metric">
                    <span>Common Range:</span>
                    <span>${sumStats.commonRange[0]} to ${sumStats.commonRange[1]}</span>
                </div>
                <div class="performance-bar">
                    <div class="performance-bar-fill" style="width: ${((sum - sumStats.min) / (sumStats.max - sumStats.min)) * 100}%"></div>
                </div>
                <p>${commonality}</p>
            `;
        }

        function updateGapAnalysis(numbers) {
            // Calculate gaps between consecutive numbers
            const gaps = [];
            for (let i = 1; i < numbers.length; i++) {
                gaps.push(numbers[i] - numbers[i - 1]);
            }
            
            const container = document.getElementById('gap-analysis');
            
            container.innerHTML = `
                <p><strong>Gaps between numbers:</strong> ${gaps.join(', ')}</p>
                <p><strong>Average gap:</strong> ${(gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(1)}</p>
                <p><strong>Largest gap:</strong> ${Math.max(...gaps)}</p>
                <p><strong>Smallest gap:</strong> ${Math.min(...gaps)}</p>
                
                <h4 style="margin-top: 15px;">Gap Analysis</h4>
                <p>${analyzeGapPattern(gaps)}</p>
            `;
        }

        function analyzeGapPattern(gaps) {
            const uniqueGaps = [...new Set(gaps)];
            const repeatedGaps = gaps.filter((gap, i) => gaps.indexOf(gap) !== i);
            
            if (repeatedGaps.length > 0) {
                return 'This combination has repeated gaps between numbers, which is uncommon in lottery draws.';
            }
            
            if (uniqueGaps.length === gaps.length) {
                return 'All gaps between numbers are unique, which is typical for lottery draws.';
            }
            
            return 'This combination has a mix of unique and repeated gaps between numbers.';
        }

        function clearAnalyzer() {
            document.getElementById('analyzer-numbers').value = '';
            document.getElementById('analyzer-results').innerHTML = '<p>Enter numbers to analyze them</p>';
            document.querySelectorAll('#analyzer-number-matrix .number-cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            // Clear charts
            if (appState.charts.analyzerChart) {
                appState.charts.analyzerChart.destroy();
                appState.charts.analyzerChart = null;
            }
            
            // Clear analysis sections
            document.getElementById('sum-analysis').innerHTML = '<p>Analyze numbers to see sum statistics</p>';
            document.getElementById('gap-analysis').innerHTML = '<p>Analyze numbers to see gap statistics</p>';
        }

        function loadSavedTickets() {
            const gameType = document.getElementById('analyzer-game-type').value;
            const savedTickets = appState.savedTickets[gameType] || [];
            
            if (savedTickets.length === 0) {
                showToast(`No saved tickets found for ${gameType}`, 'warning', 'exclamation-triangle');
                return;
            }
            
            // Display the most recent saved ticket
            const latestTicket = savedTickets[savedTickets.length - 1];
            document.getElementById('analyzer-numbers').value = latestTicket.numbers.join(', ');
            
            // Update number matrix selection
            document.querySelectorAll('#analyzer-number-matrix .number-cell').forEach(cell => {
                const num = parseInt(cell.textContent);
                cell.classList.toggle('selected', latestTicket.numbers.includes(num));
            });
            
            // Analyze the numbers
            analyzeNumbers();
            
            showToast('Loaded most recent saved ticket', 'success', 'folder-open');
        }

        // Historical data functions
        function loadHistoricalData() {
            const gameType = document.getElementById('history-game-type').value;
            const drawCount = parseInt(document.getElementById('history-draw-count').value);
            
            // In a real app, this would fetch from an API
            // For this demo, we'll simulate with generated data
            showToast(`Loading ${drawCount} historical draws for ${gameType}...`, 'info', 'spinner fa-spin');
            
            // Simulate API delay
            setTimeout(() => {
                // Generate mock historical data
                const history = generateMockHistory(gameType, drawCount);
                appState.historicalData[gameType] = history;
                
                // Process hot/cold numbers
                processHotColdNumbers(gameType, history);
                
                // Display history
                displayHistoricalData(history);
                displayHotColdNumbers(gameType);
                
                showToast(`Successfully loaded ${drawCount} historical draws`, 'success', 'check-circle');
            }, 1500);
        }

        function generateMockHistory(gameType, count) {
            let mainPool, pickCount, bonusPool, bonusCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    bonusPool = 26;
                    bonusCount = 1;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    bonusPool = 25;
                    bonusCount = 1;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    bonusPool = 12;
                    bonusCount = 2;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    bonusPool = 0;
                    bonusCount = 0;
                    break;
            }
            
            const history = [];
            const now = new Date();
            
            // Generate weighted probabilities to simulate some patterns
            const weights = Array.from({length: mainPool}, (_, i) => {
                const num = i + 1;
                let weight = 1;
                
                // Slight preference for numbers <= 31 (birthday effect)
                if (num <= 31) weight *= 1.3;
                
                // Slight preference for numbers ending with 7
                if (num % 10 === 7) weight *= 1.2;
                
                // Some numbers are slightly more popular
                if ([3, 7, 11, 22, 33, 44].includes(num)) weight *= 1.15;
                
                return weight;
            });
            
            for (let i = 0; i < count; i++) {
                const drawDate = new Date(now);
                drawDate.setDate(drawDate.getDate() - (count - i) * 2); // Spread draws over time
                
                // Generate main numbers with weighted probabilities
                const mainNumbers = [];
                const available = Array.from({length: mainPool}, (_, i) => i + 1);
                const tempWeights = [...weights];
                
                while (mainNumbers.length < pickCount && available.length > 0) {
                    // Calculate total weight
                    const totalWeight = available.reduce((sum, num) => sum + tempWeights[num - 1], 0);
                    
                    // Select number based on weighted probability
                    let random = Math.random() * totalWeight;
                    let sum = 0;
                    let selectedIndex = -1;
                    
                    for (let j = 0; j < available.length; j++) {
                        const num = available[j];
                        sum += tempWeights[num - 1];
                        if (random <= sum) {
                            selectedIndex = j;
                            break;
                        }
                    }
                    
                    // Fallback if no selection (shouldn't happen with proper weights)
                    if (selectedIndex === -1) {
                        selectedIndex = Math.floor(Math.random() * available.length);
                    }
                    
                    const selectedNum = available.splice(selectedIndex, 1)[0];
                    mainNumbers.push(selectedNum);
                    
                    // Reduce weight of adjacent numbers to reduce clustering
                    for (let j = Math.max(1, selectedNum - 3); j <= Math.min(mainPool, selectedNum + 3); j++) {
                        if (available.includes(j)) {
                            tempWeights[j - 1] *= 0.7;
                        }
                    }
                }
                
                // Generate bonus numbers
                const bonusNumbers = [];
                if (bonusCount > 0) {
                    for (let j = 0; j < bonusCount; j++) {
                        let num;
                        do {
                            num = Math.floor(Math.random() * bonusPool) + 1;
                        } while (bonusNumbers.includes(num));
                        bonusNumbers.push(num);
                    }
                }
                
                // Generate random jackpot amount
                const jackpot = Math.floor(Math.random() * 500000000) + 10000000;
                
                history.push({
                    date: drawDate.toISOString().split('T')[0],
                    numbers: mainNumbers.sort((a, b) => a - b),
                    bonusNumbers: bonusCount > 0 ? bonusNumbers.sort((a, b) => a - b) : null,
                    jackpot: jackpot.toLocaleString('en-US', {style: 'currency', currency: 'USD', maximumFractionDigits: 0})
                });
            }
            
            return history;
        }

        function processHotColdNumbers(gameType, history) {
            const mainNumbers = [];
            const bonusNumbers = [];
            
            history.forEach(draw => {
                mainNumbers.push(...draw.numbers);
                if (draw.bonusNumbers) {
                    bonusNumbers.push(...draw.bonusNumbers);
                }
            });
            
            // Calculate frequencies for main numbers
            const mainPool = gameType === 'powerball' ? 69 :
                           gameType === 'megamillions' ? 70 :
                           gameType === 'euromillions' ? 50 : 49;
            
            const frequencies = [];
            for (let i = 1; i <= mainPool; i++) {
                const allTime = mainNumbers.filter(n => n === i).length;
                
                // Calculate recent frequency (last 20% of draws)
                const recentDraws = Math.max(10, Math.floor(history.length * 0.2));
                const recent = history.slice(-recentDraws)
                    .flatMap(d => d.numbers)
                    .filter(n => n === i).length;
                
                frequencies.push({
                    number: i,
                    allTime: allTime,
                    recent: recent
                });
            }
            
            // Calculate frequencies for bonus numbers if applicable
            let bonusFrequencies = [];
            const bonusPool = gameType === 'powerball' ? 26 :
                             gameType === 'megamillions' ? 25 :
                             gameType === 'euromillions' ? 12 : 0;
            
            if (bonusPool > 0) {
                for (let i = 1; i <= bonusPool; i++) {
                    const allTime = bonusNumbers.filter(n => n === i).length;
                    
                    const recentDraws = Math.max(10, Math.floor(history.length * 0.2));
                    const recent = history.slice(-recentDraws)
                        .flatMap(d => d.bonusNumbers || [])
                        .filter(n => n === i).length;
                    
                    bonusFrequencies.push({
                        number: i,
                        allTime: allTime,
                        recent: recent
                    });
                }
            }
            
            appState.hotColdData[gameType] = {
                frequencies: frequencies,
                bonusFrequencies: bonusFrequencies,
                lastUpdated: new Date().toISOString()
            };
        }

        function displayHistoricalData(history) {
            const tableBody = document.getElementById('history-table-body');
            tableBody.innerHTML = '';
            
            history.forEach(draw => {
                const row = document.createElement('tr');
                
                // Date
                const dateCell = document.createElement('td');
                dateCell.textContent = draw.date;
                row.appendChild(dateCell);
                
                // Numbers
                const numbersCell = document.createElement('td');
                const numbersDiv = document.createElement('div');
                numbersDiv.className = 'lotto-balls';
                
                draw.numbers.forEach(num => {
                    const ball = document.createElement('div');
                    ball.className = 'ball';
                    ball.textContent = num;
                    numbersDiv.appendChild(ball);
                });
                
                numbersCell.appendChild(numbersDiv);
                row.appendChild(numbersCell);
                
                // Bonus numbers
                const bonusCell = document.createElement('td');
                if (draw.bonusNumbers) {
                    const bonusDiv = document.createElement('div');
                    bonusDiv.className = 'lotto-balls';
                    
                    draw.bonusNumbers.forEach(num => {
                        const ball = document.createElement('div');
                        const gameType = document.getElementById('history-game-type').value;
                        ball.className = gameType === 'powerball' ? 'ball powerball' : 
                                         gameType === 'megamillions' ? 'ball megaball' : 'ball eurostar';
                        ball.textContent = num;
                        bonusDiv.appendChild(ball);
                    });
                    
                    bonusCell.appendChild(bonusDiv);
                }
                row.appendChild(bonusCell);
                
                // Jackpot
                const jackpotCell = document.createElement('td');
                jackpotCell.textContent = draw.jackpot;
                row.appendChild(jackpotCell);
                
                tableBody.appendChild(row);
            });
            
            // Update history chart
            updateHistoryChart(history);
        }

        function updateHistoryChart(history) {
            const ctx = document.getElementById('history-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.historyChart) {
                appState.charts.historyChart.destroy();
            }
            
            // Prepare data for chart
            const labels = history.map(draw => draw.date);
            const sums = history.map(draw => draw.numbers.reduce((a, b) => a + b, 0));
            const jackpots = history.map(draw => parseInt(draw.jackpot.replace(/[^0-9]/g, '')) / 1000000;
            
            appState.charts.historyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Number Sum',
                            data: sums,
                            backgroundColor: 'rgba(74, 107, 255, 0.2)',
                            borderColor: 'rgba(74, 107, 255, 1)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Jackpot (Millions)',
                            data: jackpots,
                            backgroundColor: 'rgba(239, 68, 68, 0.2)',
                            borderColor: 'rgba(239, 68, 68, 1)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Number Sum'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Jackpot (Millions)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Draw Date'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label === 'Number Sum') {
                                        label += `: ${context.raw}`;
                                    } else if (label === 'Jackpot (Millions)') {
                                        label += `: $${context.raw.toFixed(1)}M`;
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        function displayHotColdNumbers(gameType) {
            const container = document.getElementById('hot-cold-numbers');
            const hotColdData = appState.hotColdData[gameType];
            
            if (!hotColdData) {
                container.innerHTML = '<p>No hot/cold data available</p>';
                return;
            }
            
            // Get hot numbers (most frequent recently)
            const hotNumbers = [...hotColdData.frequencies]
                .sort((a, b) => b.recent - a.recent)
                .slice(0, 10);
                
            // Get cold numbers (least frequent recently but have appeared)
            const coldNumbers = [...hotColdData.frequencies]
                .filter(f => f.allTime > 0)
                .sort((a, b) => a.recent - b.recent)
                .slice(0, 10);
                
            // Get overdue numbers (not appeared recently but have appeared before)
            const recentDraws = Math.max(10, Math.floor((appState.historicalData[gameType] || []).length * 0.2));
            const overdueNumbers = [...hotColdData.frequencies]
                .filter(f => f.allTime > 0 && f.recent === 0)
                .sort((a, b) => b.allTime - a.allTime) // Sort by all-time frequency
                .slice(0, 10);
            
            let html = `
                <div class="grid" style="gap: 20px;">
                    <div>
                        <h3>Hot Numbers (Recent Frequency)</h3>
                        <div class="lotto-balls">
            `;
            
            hotNumbers.forEach(item => {
                html += `<div class="ball hot-number" title="Appeared ${item.recent} times in last ${recentDraws} draws">${item.number}</div>`;
            });
            
            html += `
                        </div>
                    </div>
                    <div>
                        <h3>Cold Numbers (Recent Frequency)</h3>
                        <div class="lotto-balls">
            `;
            
            coldNumbers.forEach(item => {
                html += `<div class="ball cold-number" title="Appeared ${item.recent} times in last ${recentDraws} draws">${item.number}</div>`;
            });
            
            html += `
                        </div>
                    </div>
                    <div>
                        <h3>Overdue Numbers (Not Recent)</h3>
                        <div class="lotto-balls">
            `;
            
            overdueNumbers.forEach(item => {
                html += `<div class="ball" title="Appeared ${item.allTime} times total, but not in last ${recentDraws} draws">${item.number}</div>`;
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Update hot/cold chart
            updateHotColdChart(hotColdData.frequencies);
        }

        function updateHotColdChart(frequencies) {
            const ctx = document.getElementById('hot-cold-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.hotColdChart) {
                appState.charts.hotColdChart.destroy();
            }
            
            // Sort by number
            const sortedFrequencies = [...frequencies].sort((a, b) => a.number - b.number);
            
            // Prepare data for chart
            const labels = sortedFrequencies.map(item => item.number);
            const allTimeData = sortedFrequencies.map(item => item.allTime);
            const recentData = sortedFrequencies.map(item => item.recent);
            
            appState.charts.hotColdChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'All-Time Frequency',
                            data: allTimeData,
                            backgroundColor: 'rgba(74, 107, 255, 0.7)',
                            borderColor: 'rgba(74, 107, 255, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Recent Frequency',
                            data: recentData,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                            borderColor: 'rgba(239, 68, 68, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Number'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function clearHistoryTable() {
            document.getElementById('history-table-body').innerHTML = '';
            
            // Clear charts
            if (appState.charts.historyChart) {
                appState.charts.historyChart.destroy();
                appState.charts.historyChart = null;
            }
            
            if (appState.charts.hotColdChart) {
                appState.charts.hotColdChart.destroy();
                appState.charts.hotColdChart = null;
            }
            
            // Clear hot/cold display
            document.getElementById('hot-cold-numbers').innerHTML = '<p>Load historical data to see hot and cold numbers</p>';
        }

        function downloadHistoricalData() {
            const gameType = document.getElementById('history-game-type').value;
            const history = appState.historicalData[gameType];
            
            if (!history || history.length === 0) {
                showToast('No historical data to download', 'warning', 'exclamation-triangle');
                return;
            }
            
            // Convert to CSV
            let csv = 'Date,Main Numbers,Bonus Numbers,Jackpot\n';
            
            history.forEach(draw => {
                csv += `${draw.date},"${draw.numbers.join(',')}",`;
                csv += draw.bonusNumbers ? `"${draw.bonusNumbers.join(',')}",` : '""';
                csv += `${draw.jackpot}\n`;
            });
            
            // Create download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${gameType}-history-${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Historical data downloaded as CSV', 'success', 'file-csv');
        }

        // Strategy functions
        function updateStrategyParams() {
            const strategy = appState.currentStrategy;
            const paramsContainer = document.getElementById('strategy-params');
            
            let html = '';
            
            switch(strategy) {
                case 'low-high':
                    html = `
                        <label for="strategy-low-count">Low numbers:</label>
                        <input type="number" id="strategy-low-count" min="1" value="3" max="10">
                        
                        <label for="strategy-high-count">High numbers:</label>
                        <input type="number" id="strategy-high-count" min="1" value="2" max="10">
                    `;
                    break;
                    
                case 'odd-even':
                    html = `
                        <label for="strategy-odd-count">Odd numbers:</label>
                        <input type="number" id="strategy-odd-count" min="1" value="3" max="10">
                        
                        <label for="strategy-even-count">Even numbers:</label>
                        <input type="number" id="strategy-even-count" min="1" value="2" max="10">
                    `;
                    break;
                    
                case 'hot-cold':
                    html = `
                        <label for="strategy-hot-count">Hot numbers:</label>
                        <input type="number" id="strategy-hot-count" min="1" value="3" max="10">
                        
                        <label for="strategy-cold-count">Cold numbers:</label>
                        <input type="number" id="strategy-cold-count" min="1" value="2" max="10">
                        
                        <div class="status info">
                            <i class="fas fa-info-circle"></i> Hot/Cold strategy requires historical data to be loaded.
                        </div>
                    `;
                    break;
                    
                case 'birthday':
                    html = `
                        <label for="birthday-day">Day:</label>
                        <input type="number" id="birthday-day" min="1" max="31" placeholder="1-31">
                        
                        <label for="birthday-month">Month:</label>
                        <input type="number" id="birthday-month" min="1" max="12" placeholder="1-12">
                        
                        <label for="birthday-year">Year (last 2 digits):</label>
                        <input type="number" id="birthday-year" min="0" max="99" placeholder="00-99">
                    `;
                    break;
                    
                case 'ai':
                    html = `
                        <label for="ai-strategy-model">AI Model:</label>
                        <select id="ai-strategy-model">
                            <option value="markov">Markov Chain</option>
                            <option value="neural">Neural Network</option>
                            <option value="combined">Combined Model</option>
                        </select>
                        
                        <label for="ai-strategy-confidence">Minimum confidence threshold:</label>
                        <input type="range" id="ai-strategy-confidence" min="50" max="95" value="75" step="5">
                        <span id="strategy-confidence-value">75%</span>
                        
                        <div class="status info">
                            <i class="fas fa-info-circle"></i> AI models perform better with historical data loaded.
                        </div>
                    `;
                    
                    document.getElementById('ai-strategy-confidence').addEventListener('input', function() {
                        document.getElementById('strategy-confidence-value').textContent = this.value + '%';
                    });
                    break;
            }
            
            paramsContainer.innerHTML = html;
        }

        function updateStrategyExplanation() {
            const strategy = appState.currentStrategy;
            const container = document.getElementById('strategy-explanation');
            
            let explanation = '';
            
            switch(strategy) {
                case 'random':
                    explanation = `
                        <p>The <strong>Random</strong> strategy generates numbers completely at random with no particular pattern or strategy. This mimics how lottery numbers are actually drawn.</p>
                        <p><strong>Pros:</strong> Truly random, matches actual lottery mechanics.</p>
                        <p><strong>Cons:</strong> May produce combinations with unusual characteristics (all high numbers, all even, etc.).</p>
                    `;
                    break;
                    
                case 'low-high':
                    explanation = `
                        <p>The <strong>Low-High</strong> strategy balances your selection between low and high numbers based on the number pool.</p>
                        <p>For most lotteries, low numbers are 1-35 and high numbers are 36-70 (for a 5/70 game). This strategy ensures you have a mix of both.</p>
                        <p><strong>Pros:</strong> Creates balanced combinations that match typical winning patterns.</p>
                        <p><strong>Cons:</strong> May miss some potentially winning combinations that are all low or all high.</p>
                    `;
                    break;
                    
                case 'odd-even':
                    explanation = `
                        <p>The <strong>Odd-Even</strong> strategy balances your selection between odd and even numbers.</p>
                        <p>Most winning combinations have a mix of odd and even numbers. This strategy lets you control that balance.</p>
                        <p><strong>Pros:</strong> Produces combinations that statistically match winning patterns.</p>
                        <p><strong>Cons:</strong> Like low-high, may exclude some valid combinations.</p>
                    `;
                    break;
                    
                case 'prime':
                    explanation = `
                        <p>The <strong>Prime Numbers</strong> strategy focuses on prime numbers (numbers divisible only by 1 and themselves).</p>
                        <p>Prime numbers up to 70: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67</p>
                        <p><strong>Pros:</strong> Some players believe primes appear more often (though statistically they don't).</p>
                        <p><strong>Cons:</strong> Limits your number pool significantly.</p>
                    `;
                    break;
                    
                case 'fibonacci':
                    explanation = `
                        <p>The <strong>Fibonacci Numbers</strong> strategy uses numbers from the Fibonacci sequence.</p>
                        <p>Fibonacci sequence up to 70: 1, 2, 3, 5, 8, 13, 21, 34, 55</p>
                        <p><strong>Pros:</strong> Interesting mathematical pattern that some players favor.</p>
                        <p><strong>Cons:</strong> Very limited number pool, no statistical advantage.</p>
                    `;
                    break;
                    
                case 'lucky':
                    explanation = `
                        <p>The <strong>Lucky Numbers</strong> strategy uses numbers considered lucky in various cultures.</p>
                        <p>Common lucky numbers: 3, 7, 8, 9, 13, 17, 21, 23, 27, 33, 37, 42, 49</p>
                        <p><strong>Pros:</strong> Fun approach that might have personal significance.</p>
                        <p><strong>Cons:</strong> No statistical advantage, may limit number pool.</p>
                    `;
                    break;
                    
                case 'hot-cold':
                    explanation = `
                        <p>The <strong>Hot/Cold Numbers</strong> strategy combines frequently drawn (hot) and infrequently drawn (cold) numbers.</p>
                        <p>Hot numbers are those that have appeared most often in recent draws. Cold numbers are those that have appeared least often but have appeared historically.</p>
                        <p><strong>Pros:</strong> Based on actual historical data, combines both recent trends and overdue numbers.</p>
                        <p><strong>Cons:</strong> Requires historical data to be loaded, and past performance doesn't guarantee future results.</p>
                    `;
                    break;
                    
                case 'birthday':
                    explanation = `
                        <p>The <strong>Birthday Numbers</strong> strategy uses dates (days and months) from birthdays or other significant dates.</p>
                        <p>This typically limits numbers to 1-31 (days) and 1-12 (months). Some players also use years (e.g., '89 for 1989).</p>
                        <p><strong>Pros:</strong> Personal significance makes it fun and easy to remember.</p>
                        <p><strong>Cons:</strong> Limits number pool significantly, especially for games with higher numbers.</p>
                    `;
                    break;
                    
                case 'ai':
                    explanation = `
                        <p>The <strong>AI-Powered</strong> strategy uses machine learning models to predict numbers based on historical patterns.</p>
                        <p>Different models look for different patterns:</p>
                        <ul>
                            <li><strong>Markov Chain:</strong> Predicts based on transition probabilities between numbers</li>
                            <li><strong>Neural Network:</strong> Finds complex non-linear patterns in historical data</li>
                            <li><strong>Combined Model:</strong> Uses an ensemble of approaches for balanced predictions</li>
                        </ul>
                        <p><strong>Pros:</strong> Uses advanced pattern recognition that might spot trends humans miss.</p>
                        <p><strong>Cons:</strong> Requires historical data, and lotteries are still fundamentally random.</p>
                    `;
                    break;
            }
            
            container.innerHTML = explanation;
        }

        function generateWithStrategy() {
            const strategy = appState.currentStrategy;
            const gameType = document.getElementById('game-type').value;
            
            let mainPool, pickCount, bonusPool, bonusCount;
            
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('main-numbers').value);
                pickCount = parseInt(document.getElementById('pick-numbers').value);
                bonusPool = parseInt(document.getElementById('bonus-numbers').value);
                bonusCount = parseInt(document.getElementById('pick-bonus').value);
            } else {
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        pickCount = 5;
                        bonusPool = 25;
                        bonusCount = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        pickCount = 5;
                        bonusPool = 12;
                        bonusCount = 2;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        pickCount = 6;
                        bonusPool = 0;
                        bonusCount = 0;
                        break;
                }
            }
            
            // Generate numbers based on strategy
            let numbers = [];
            let bonusNumbers = [];
            
            switch(strategy) {
                case 'random':
                    numbers = generateRandomNumbers(mainPool, pickCount, 'standard');
                    break;
                    
                case 'low-high':
                    const lowCount = parseInt(document.getElementById('strategy-low-count').value) || Math.floor(pickCount / 2);
                    const highCount = pickCount - lowCount;
                    
                    const midpoint = Math.floor(mainPool / 2);
                    let lowNumbers = [];
                    let highNumbers = [];
                    
                    // Generate low numbers (1 to midpoint)
                    while (lowNumbers.length < lowCount) {
                        const num = Math.floor(Math.random() * midpoint) + 1;
                        if (!lowNumbers.includes(num)) {
                            lowNumbers.push(num);
                        }
                    }
                    
                    // Generate high numbers (midpoint+1 to poolSize)
                    while (highNumbers.length < highCount) {
                        const num = Math.floor(Math.random() * (mainPool - midpoint)) + midpoint + 1;
                        if (!highNumbers.includes(num)) {
                            highNumbers.push(num);
                        }
                    }
                    
                    numbers = [...lowNumbers, ...highNumbers];
                    break;
                    
                case 'odd-even':
                    const oddCount = parseInt(document.getElementById('strategy-odd-count').value) || Math.floor(pickCount / 2);
                    const evenCount = pickCount - oddCount;
                    
                    let oddNumbers = [];
                    let evenNumbers = [];
                    
                    // Generate odd numbers
                    while (oddNumbers.length < oddCount) {
                        const num = Math.floor(Math.random() * mainPool) + 1;
                        if (num % 2 === 1 && !oddNumbers.includes(num)) {
                            oddNumbers.push(num);
                        }
                    }
                    
                    // Generate even numbers
                    while (evenNumbers.length < evenCount) {
                        const num = Math.floor(Math.random() * mainPool) + 1;
                        if (num % 2 === 0 && !evenNumbers.includes(num)) {
                            evenNumbers.push(num);
                        }
                    }
                    
                    numbers = [...oddNumbers, ...evenNumbers];
                    break;
                    
                case 'prime':
                    numbers = generatePrimeNumbers(mainPool, pickCount);
                    break;
                    
                case 'fibonacci':
                    numbers = generateFibonacciNumbers(mainPool, pickCount);
                    break;
                    
                case 'lucky':
                    numbers = generateLuckyNumbers(mainPool, pickCount);
                    break;
                    
                case 'hot-cold':
                    if (Object.keys(appState.hotColdData).length === 0 || !appState.hotColdData[gameType]) {
                        showToast('No hot/cold data available. Using standard random.', 'warning', 'exclamation-triangle');
                        numbers = generateRandomNumbers(mainPool, pickCount, 'standard');
                    } else {
                        const hotCount = parseInt(document.getElementById('strategy-hot-count').value) || 3;
                        const coldCount = pickCount - hotCount;
                        
                        const hotNumbers = [...appState.hotColdData[gameType].frequencies]
                            .sort((a, b) => b.recent - a.recent)
                            .slice(0, Math.floor(mainPool * 0.3)) // Top 30% recent
                            .map(item => item.number);
                            
                        const coldNumbers = [...appState.hotColdData[gameType].frequencies]
                            .filter(item => item.allTime > 0)
                            .sort((a, b) => a.recent - b.recent)
                            .slice(0, Math.floor(mainPool * 0.3)) // Bottom 30% recent
                            .map(item => item.number);
                            
                        // Select hot and cold numbers
                        const selectedHot = [];
                        const selectedCold = [];
                        
                        while (selectedHot.length < hotCount && hotNumbers.length > 0) {
                            const index = Math.floor(Math.random() * hotNumbers.length);
                            const num = hotNumbers[index];
                            if (!selectedHot.includes(num)) {
                                selectedHot.push(num);
                            }
                        }
                        
                        while (selectedCold.length < coldCount && coldNumbers.length > 0) {
                            const index = Math.floor(Math.random() * coldNumbers.length);
                            const num = coldNumbers[index];
                            if (!selectedCold.includes(num)) {
                                selectedCold.push(num);
                            }
                        }
                        
                        // Fill remaining with random if needed
                        const remaining = pickCount - (selectedHot.length + selectedCold.length);
                        const combined = [...selectedHot, ...selectedCold];
                        let additional = [];
                        
                        if (remaining > 0) {
                            const allNumbers = Array.from({length: mainPool}, (_, i) => i + 1);
                            const available = allNumbers.filter(n => !combined.includes(n));
                            
                            while (additional.length < remaining && available.length > 0) {
                                const index = Math.floor(Math.random() * available.length);
                                additional.push(available.splice(index, 1)[0]);
                            }
                        }
                        
                        numbers = [...selectedHot, ...selectedCold, ...additional].slice(0, pickCount);
                    }
                    break;
                    
                case 'birthday':
                    const day = parseInt(document.getElementById('birthday-day').value);
                    const month = parseInt(document.getElementById('birthday-month').value);
                    const year = parseInt(document.getElementById('birthday-year').value);
                    
                    const birthdayNumbers = [];
                    if (!isNaN(day) && day >= 1 && day <= 31) birthdayNumbers.push(day);
                    if (!isNaN(month) && month >= 1 && month <= 12) birthdayNumbers.push(month);
                    if (!isNaN(year) && year >= 0 && year <= 99) birthdayNumbers.push(year > 0 ? year : 100);
                    
                    // If not enough birthday numbers, fill with random
                    if (birthdayNumbers.length >= pickCount) {
                        numbers = birthdayNumbers.slice(0, pickCount);
                    } else {
                        const needed = pickCount - birthdayNumbers.length;
                        let additional = [];
                        
                        while (additional.length < needed) {
                            const num = Math.floor(Math.random() * mainPool) + 1;
                            if (!birthdayNumbers.includes(num) && !additional.includes(num)) {
                                additional.push(num);
                            }
                        }
                        
                        numbers = [...birthdayNumbers, ...additional];
                    }
                    break;
                    
                case 'ai':
                    numbers = generateAINumbers(mainPool, pickCount);
                    break;
            }
            
            // Generate bonus numbers (always random for strategies)
            if (bonusCount > 0) {
                bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
            }
            
            // Display results
            const results = [{
                numbers: numbers.sort((a, b) => a - b),
                bonusNumbers: bonusNumbers.sort((a, b) => a - b)
            }];
            
            displayStrategyResults(results);
            showToast(`Numbers generated using ${strategy} strategy`, 'success', 'robot');
        }

        function displayStrategyResults(results) {
            const container = document.getElementById('strategy-results');
            let html = '<h3>Generated Numbers</h3>';
            
            results.forEach((ticket, index) => {
                html += `<div class="result" style="margin-bottom: 1rem;">
                    <h4>Ticket #${index + 1}</h4>
                    <div class="lotto-balls">`;
                
                // Main numbers
                ticket.numbers.forEach(num => {
                    html += `<div class="ball">${num}</div>`;
                });
                
                // Bonus numbers
                if (ticket.bonusNumbers && ticket.bonusNumbers.length > 0) {
                    ticket.bonusNumbers.forEach(num => {
                        const gameType = document.getElementById('game-type').value;
                        const ballClass = gameType === 'powerball' ? 'powerball' : 
                                          gameType === 'megamillions' ? 'megaball' : 'eurostar';
                        html += `<div class="ball ${ballClass}">${num}</div>`;
                    });
                }
                
                html += `</div></div>`;
            });
            
            container.innerHTML = html;
        }

        function testStrategy() {
            const strategy = appState.currentStrategy;
            const gameType = document.getElementById('game-type').value;
            
            if (!appState.historicalData[gameType] || appState.historicalData[gameType].length === 0) {
                showToast('No historical data available to test strategy', 'warning', 'exclamation-triangle');
                return;
            }
            
            showToast(`Testing ${strategy} strategy against historical data...`, 'info', 'spinner fa-spin');
            
            // Simulate processing delay
            setTimeout(() => {
                const history = appState.historicalData[gameType];
                const mainPool = gameType === 'powerball' ? 69 :
                               gameType === 'megamillions' ? 70 :
                               gameType === 'euromillions' ? 50 : 49;
                const pickCount = gameType === 'lotto649' ? 6 : 5;
                
                // Generate test tickets using the strategy
                const testTickets = [];
                const testCount = Math.min(100, history.length); // Test against up to 100 historical draws
                
                for (let i = 0; i < testCount; i++) {
                    // Generate numbers using the current strategy
                    let numbers = [];
                    
                    switch(strategy) {
                        case 'random':
                            numbers = generateRandomNumbers(mainPool, pickCount, 'standard');
                            break;
                            
                        case 'low-high':
                            const lowCount = parseInt(document.getElementById('strategy-low-count').value) || Math.floor(pickCount / 2);
                            numbers = generateLowHighNumbers(mainPool, pickCount);
                            break;
                            
                        case 'odd-even':
                            const oddCount = parseInt(document.getElementById('strategy-odd-count').value) || Math.floor(pickCount / 2);
                            numbers = generateOddEvenNumbers(mainPool, pickCount);
                            break;
                            
                        case 'prime':
                            numbers = generatePrimeNumbers(mainPool, pickCount);
                            break;
                            
                        case 'fibonacci':
                            numbers = generateFibonacciNumbers(mainPool, pickCount);
                            break;
                            
                        case 'lucky':
                            numbers = generateLuckyNumbers(mainPool, pickCount);
                            break;
                            
                        case 'hot-cold':
                            numbers = generateHotColdNumbers(mainPool, pickCount);
                            break;
                            
                        case 'birthday':
                            numbers = generateWithBirthdayStrategy(mainPool, pickCount);
                            break;
                            
                        case 'ai':
                            numbers = generateAINumbers(mainPool, pickCount);
                            break;
                    }
                    
                    testTickets.push(numbers.sort((a, b) => a - b));
                }
                
                // Calculate matches
                let totalMatches = 0;
                let jackpotMatches = 0;
                let matchDistribution = Array(pickCount + 1).fill(0); // Index 0-5 or 0-6
                
                for (let i = 0; i < testCount; i++) {
                    const testNumbers = testTickets[i];
                    const historicalNumbers = history[i].numbers;
                    
                    // Count matches
                    const matches = testNumbers.filter(num => historicalNumbers.includes(num)).length;
                    totalMatches += matches;
                    
                    // Count jackpot matches (all numbers)
                    if (matches === pickCount) {
                        jackpotMatches++;
                    }
                    
                    // Update distribution
                    matchDistribution[matches]++;
                }
                
                // Calculate averages
                const avgMatches = (totalMatches / testCount).toFixed(2);
                const jackpotRate = ((jackpotMatches / testCount) * 100).toFixed(4);
                
                // Display performance results
                const container = document.getElementById('performance-results');
                let html = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Tested Draws</h3>
                            <p>${testCount}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Average Matches</h3>
                            <p>${avgMatches}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Jackpot Wins</h3>
                            <p>${jackpotMatches}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Jackpot Rate</h3>
                            <p>${jackpotRate}%</p>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 20px;">Match Distribution</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Matches</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (let i = 0; i <= pickCount; i++) {
                    const count = matchDistribution[i];
                    const percentage = ((count / testCount) * 100).toFixed(2);
                    html += `
                        <tr>
                            <td>${i}</td>
                            <td>${count}</td>
                            <td>${percentage}%</td>
                        </tr>
                    `;
                }
                
                html += `
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
                
                // Update strategy chart
                updateStrategyChart(matchDistribution, pickCount);
                
                // Show performance section
                document.getElementById('strategy-performance').style.display = 'block';
                
                showToast(`Strategy test completed. Average matches: ${avgMatches}`, 'success', 'chart-line');
            }, 2000);
        }

        function updateStrategyChart(distribution, pickCount) {
            const ctx = document.getElementById('strategy-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.strategyChart) {
                appState.charts.strategyChart.destroy();
            }
            
            // Prepare data for chart
            const labels = Array.from({length: pickCount + 1}, (_, i) => `${i} Matches`);
            const data = distribution;
            
            appState.charts.strategyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Tickets',
                        data: data,
                        backgroundColor: 'rgba(74, 107, 255, 0.7)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Tickets'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Matches'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.raw} tickets (${((context.raw / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1)}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function saveStrategy() {
            const strategy = appState.currentStrategy;
            const gameType = document.getElementById('game-type').value;
            
            // Get strategy parameters
            let params = {};
            
            switch(strategy) {
                case 'low-high':
                    params.lowCount = parseInt(document.getElementById('strategy-low-count').value) || 3;
                    params.highCount = parseInt(document.getElementById('strategy-high-count').value) || 2;
                    break;
                    
                case 'odd-even':
                    params.oddCount = parseInt(document.getElementById('strategy-odd-count').value) || 3;
                    params.evenCount = parseInt(document.getElementById('strategy-even-count').value) || 2;
                    break;
                    
                case 'hot-cold':
                    params.hotCount = parseInt(document.getElementById('strategy-hot-count').value) || 3;
                    params.coldCount = parseInt(document.getElementById('strategy-cold-count').value) || 2;
                    break;
                    
                case 'birthday':
                    params.day = parseInt(document.getElementById('birthday-day').value);
                    params.month = parseInt(document.getElementById('birthday-month').value);
                    params.year = parseInt(document.getElementById('birthday-year').value);
                    break;
                    
                case 'ai':
                    params.model = document.getElementById('ai-strategy-model').value;
                    params.confidence = parseInt(document.getElementById('ai-strategy-confidence').value);
                    break;
            }
            
            // Create strategy object
            const strategyObj = {
                name: `${strategy.charAt(0).toUpperCase() + strategy.slice(1)} Strategy`,
                type: strategy,
                game: gameType,
                params: params,
                created: new Date().toISOString()
            };
            
            // Save to local storage
            if (!appState.savedStrategies[gameType]) {
                appState.savedStrategies[gameType] = [];
            }
            
            appState.savedStrategies[gameType].push(strategyObj);
            localStorage.setItem('savedStrategies', JSON.stringify(appState.savedStrategies));
            
            showToast('Strategy saved successfully', 'success', 'save');
        }

        // Simulator functions
        function updateSimulator() {
            const gameType = document.getElementById('simulator-game-type').value;
            let mainPool, pickCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    break;
            }
            
            // Update number matrix
            const matrix = document.getElementById('simulator-number-matrix');
            if (matrix) {
                matrix.innerHTML = '';
                
                for (let i = 1; i <= mainPool; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'number-cell';
                    cell.textContent = i;
                    cell.addEventListener('click', function() {
                        this.classList.toggle('selected');
                        updateSimulatorNumbers();
                    });
                    matrix.appendChild(cell);
                }
            }
        }

        function runSimulation() {
            if (appState.simulationRunning) {
                showToast('Simulation already running', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('simulator-game-type').value;
            const ticketsText = document.getElementById('simulator-tickets').value;
            const simulationCount = parseInt(document.getElementById('simulation-count').value);
            
            if (!ticketsText.trim()) {
                showToast('Please enter tickets to simulate', 'warning', 'exclamation-triangle');
                return;
            }
            
            if (isNaN(simulationCount) {
                showToast('Please enter a valid simulation count', 'danger', 'exclamation-triangle');
                return;
            }
            
            // Parse tickets
            const ticketLines = ticketsText.split('\n').filter(line => line.trim());
            const tickets = [];
            
            let mainPool, pickCount, bonusPool, bonusCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    bonusPool = 26;
                    bonusCount = 1;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    bonusPool = 25;
                    bonusCount = 1;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    bonusPool = 12;
                    bonusCount = 2;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    bonusPool = 0;
                    bonusCount = 0;
                    break;
            }
            
            // Validate tickets
            for (const line of ticketLines) {
                const numbers = line.split(',')
                    .map(n => parseInt(n.trim()))
                    .filter(n => !isNaN(n));
                
                if (numbers.length !== pickCount + (bonusCount > 0 ? bonusCount : 0)) {
                    showToast(`Invalid ticket: ${line}. Expected ${pickCount} main numbers${bonusCount > 0 ? ` and ${bonusCount} bonus numbers` : ''}`, 'danger', 'exclamation-triangle');
                    return;
                }
                
                const mainNumbers = numbers.slice(0, pickCount);
                const bonusNumbers = bonusCount > 0 ? numbers.slice(pickCount) : [];
                
                if (mainNumbers.some(n => n < 1 || n > mainPool)) {
                    showToast(`Invalid main numbers in ticket: ${line}. Numbers must be between 1 and ${mainPool}`, 'danger', 'exclamation-triangle');
                    return;
                }
                
                if (bonusCount > 0 && bonusNumbers.some(n => n < 1 || n > bonusPool)) {
                    showToast(`Invalid bonus numbers in ticket: ${line}. Numbers must be between 1 and ${bonusPool}`, 'danger', 'exclamation-triangle');
                    return;
                }
                
                if (new Set(mainNumbers).size !== mainNumbers.length) {
                    showToast(`Duplicate main numbers in ticket: ${line}`, 'danger', 'exclamation-triangle');
                    return;
                }
                
                if (bonusCount > 0 && new Set(bonusNumbers).size !== bonusNumbers.length) {
                    showToast(`Duplicate bonus numbers in ticket: ${line}`, 'danger', 'exclamation-triangle');
                    return;
                }
                
                tickets.push({
                    mainNumbers: mainNumbers.sort((a, b) => a - b),
                    bonusNumbers: bonusNumbers.sort((a, b) => a - b)
                });
            }
            
            // Start simulation
            appState.simulationRunning = true;
            showToast(`Running ${simulationCount.toLocaleString()} simulations...`, 'info', 'spinner fa-spin');
            
            // Use a web worker if available for better performance
            if (window.Worker) {
                if (!appState.simulationWorker) {
                    appState.simulationWorker = new Worker('simulation-worker.js');
                    
                    appState.simulationWorker.onmessage = function(e) {
                        const results = e.data;
                        processSimulationResults(results, tickets.length);
                        appState.simulationRunning = false;
                    };
                }
                
                // Send data to worker
                appState.simulationWorker.postMessage({
                    gameType: gameType,
                    tickets: tickets,
                    simulationCount: simulationCount
                });
            } else {
                // Fallback to main thread simulation (may freeze UI for large simulations)
                setTimeout(() => {
                    const results = runSimulationInMainThread(gameType, tickets, simulationCount);
                    processSimulationResults(results, tickets.length);
                    appState.simulationRunning = false;
                }, 100);
            }
        }

        function runSimulationInMainThread(gameType, tickets, simulationCount) {
            let mainPool, pickCount, bonusPool, bonusCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    bonusPool = 26;
                    bonusCount = 1;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    bonusPool = 25;
                    bonusCount = 1;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    bonusPool = 12;
                    bonusCount = 2;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    bonusPool = 0;
                    bonusCount = 0;
                    break;
            }
            
            const results = {
                totalWins: 0,
                totalSpent: tickets.length * simulationCount * 2, // $2 per ticket
                totalWon: 0,
                jackpotWins: 0,
                matchStats: Array(tickets.length).fill().map(() => ({
                    matches: Array(pickCount + 1).fill(0),
                    bonusMatches: bonusCount > 0 ? Array(bonusCount + 1).fill(0) : null,
                    prizes: 0
                })),
                winningNumbers: []
            };
            
            for (let i = 0; i < simulationCount; i++) {
                // Generate winning numbers
                const winningMain = generateRandomNumbers(mainPool, pickCount, 'standard');
                const winningBonus = bonusCount > 0 ? generateRandomNumbers(bonusPool, bonusCount, 'standard') : [];
                results.winningNumbers.push({
                    mainNumbers: winningMain,
                    bonusNumbers: winningBonus
                });
                
                // Check each ticket
                for (let t = 0; t < tickets.length; t++) {
                    const ticket = tickets[t];
                    const mainMatches = ticket.mainNumbers.filter(n => winningMain.includes(n)).length;
                    const bonusMatch = bonusCount > 0 ? 
                        ticket.bonusNumbers.filter(n => winningBonus.includes(n)).length : 0;
                    
                    // Record matches
                    results.matchStats[t].matches[mainMatches]++;
                    if (bonusCount > 0) {
                        results.matchStats[t].bonusMatches[bonusMatch]++;
                    }
                    
                    // Calculate prize (simplified)
                    let prize = 0;
                    
                    switch(gameType) {
                        case 'powerball':
                            if (mainMatches === 5 && bonusMatch === 1) {
                                prize = 100000000; // Jackpot
                                results.jackpotWins++;
                            } else if (mainMatches === 5) {
                                prize = 1000000;
                            } else if (mainMatches === 4 && bonusMatch === 1) {
                                prize = 50000;
                            } else if (mainMatches === 4) {
                                prize = 100;
                            } else if (mainMatches === 3 && bonusMatch === 1) {
                                prize = 100;
                            } else if (mainMatches === 3) {
                                prize = 7;
                            } else if (mainMatches === 2 && bonusMatch === 1) {
                                prize = 7;
                            } else if (mainMatches === 1 && bonusMatch === 1) {
                                prize = 4;
                            } else if (bonusMatch === 1) {
                                prize = 4;
                            }
                            break;
                            
                        case 'megamillions':
                            if (mainMatches === 5 && bonusMatch === 1) {
                                prize = 100000000; // Jackpot
                                results.jackpotWins++;
                            } else if (mainMatches === 5) {
                                prize = 1000000;
                            } else if (mainMatches === 4 && bonusMatch === 1) {
                                prize = 10000;
                            } else if (mainMatches === 4) {
                                prize = 500;
                            } else if (mainMatches === 3 && bonusMatch === 1) {
                                prize = 200;
                            } else if (mainMatches === 3) {
                                prize = 10;
                            } else if (mainMatches === 2 && bonusMatch === 1) {
                                prize = 10;
                            } else if (mainMatches === 1 && bonusMatch === 1) {
                                prize = 4;
                            } else if (bonusMatch === 1) {
                                prize = 2;
                            }
                            break;
                            
                        case 'euromillions':
                            if (mainMatches === 5 && bonusMatch === 2) {
                                prize = 100000000; // Jackpot
                                results.jackpotWins++;
                            } else if (mainMatches === 5 && bonusMatch === 1) {
                                prize = 1000000;
                            } else if (mainMatches === 5) {
                                prize = 100000;
                            } else if (mainMatches === 4 && bonusMatch === 2) {
                                prize = 5000;
                            } else if (mainMatches === 4 && bonusMatch === 1) {
                                prize = 500;
                            } else if (mainMatches === 4) {
                                prize = 100;
                            } else if (mainMatches === 3 && bonusMatch === 2) {
                                prize = 100;
                            } else if (mainMatches === 3 && bonusMatch === 1) {
                                prize = 20;
                            } else if (mainMatches === 2 && bonusMatch === 2) {
                                prize = 20;
                            } else if (mainMatches === 3) {
                                prize = 10;
                            } else if (mainMatches === 1 && bonusMatch === 2) {
                                prize = 10;
                            } else if (mainMatches === 2 && bonusMatch === 1) {
                                prize = 10;
                            } else if (bonusMatch === 2) {
                                prize = 5;
                            }
                            break;
                            
                        case 'lotto649':
                            if (mainMatches === 6) {
                                prize = 100000000; // Jackpot
                                results.jackpotWins++;
                            } else if (mainMatches === 5) {
                                prize = 1000;
                            } else if (mainMatches === 4) {
                                prize = 100;
                            } else if (mainMatches === 3) {
                                prize = 10;
                            }
                            break;
                    }
                    
                    if (prize > 0) {
                        results.totalWins++;
                        results.totalWon += prize;
                        results.matchStats[t].prizes += prize;
                    }
                }
            }
            
            return results;
        }

        function processSimulationResults(results, ticketCount) {
            const container = document.getElementById('simulation-results');
            let html = `
                <h3>Simulation Summary</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Simulations Run</h3>
                        <p>${results.totalSpent / (ticketCount * 2)}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Spent</h3>
                        <p>$${results.totalSpent.toLocaleString()}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Won</h3>
                        <p>$${results.totalWon.toLocaleString()}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Net Result</h3>
                        <p>$${(results.totalWon - results.totalSpent).toLocaleString()}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Winning Tickets</h3>
                        <p>${results.totalWins.toLocaleString()}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Jackpot Wins</h3>
                        <p>${results.jackpotWins.toLocaleString()}</p>
                    </div>
                </div>
                
                <h3 style="margin-top: 20px;">Ticket Statistics</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Numbers</th>
                            <th>Prizes Won</th>
                            <th>Match Distribution</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (let t = 0; t < ticketCount; t++) {
                const ticket = document.getElementById('simulator-tickets').value.split('\n')[t].trim();
                const stats = results.matchStats[t];
                
                // Create match distribution string
                let matchDist = '';
                for (let m = 0; m < stats.matches.length; m++) {
                    if (stats.matches[m] > 0) {
                        matchDist += `${m}: ${stats.matches[m]} (${((stats.matches[m] / (results.totalSpent / (ticketCount * 2))) * 100).toFixed(2)}%)<br>`;
                    }
                }
                
                html += `
                    <tr>
                        <td>#${t + 1}</td>
                        <td>${ticket}</td>
                        <td>$${stats.prizes.toLocaleString()}</td>
                        <td>${matchDist}</td>
                    </tr>
                `;
            }
            
            html += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
            
            // Update simulation chart
            updateSimulationChart(results.matchStats);
            
            // Display some winning numbers
            const winningContainer = document.getElementById('winning-numbers');
            let winningHtml = '<h3>Sample Winning Numbers</h3><div style="display: flex; flex-wrap: wrap; gap: 10px;">';
            
            // Show up to 10 winning numbers
            const sampleCount = Math.min(10, results.winningNumbers.length);
            for (let i = 0; i < sampleCount; i++) {
                const draw = results.winningNumbers[i];
                winningHtml += '<div style="border: 1px solid var(--border-color); padding: 10px; border-radius: 6px;"><div class="lotto-balls">';
                
                draw.mainNumbers.forEach(num => {
                    winningHtml += `<div class="ball">${num}</div>`;
                });
                
                if (draw.bonusNumbers && draw.bonusNumbers.length > 0) {
                    const gameType = document.getElementById('simulator-game-type').value;
                    const ballClass = gameType === 'powerball' ? 'powerball' : 
                                      gameType === 'megamillions' ? 'megaball' : 'eurostar';
                    
                    draw.bonusNumbers.forEach(num => {
                        winningHtml += `<div class="ball ${ballClass}">${num}</div>`;
                    });
                }
                
                winningHtml += '</div></div>';
            }
            
            winningHtml += '</div>';
            winningContainer.innerHTML = winningHtml;
            
            showToast(`Simulation completed. Net result: $${(results.totalWon - results.totalSpent).toLocaleString()}`, 'success', 'chart-pie');
        }

        function updateSimulationChart(matchStats) {
            const ctx = document.getElementById('simulation-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.simulationChart) {
                appState.charts.simulationChart.destroy();
            }
            
            // Prepare data for chart
            const labels = matchStats.map((_, i) => `Ticket #${i + 1}`);
            const data = matchStats.map(stats => stats.prizes);
            
            appState.charts.simulationChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Prizes Won ($)',
                        data: data,
                        backgroundColor: 'rgba(74, 107, 255, 0.7)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Prizes Won ($)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Ticket'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `$${context.raw.toLocaleString()}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function stopSimulation() {
            if (appState.simulationWorker) {
                appState.simulationWorker.terminate();
                appState.simulationWorker = null;
            }
            
            appState.simulationRunning = false;
            showToast('Simulation stopped', 'warning', 'stop');
        }

        function clearSimulation() {
            document.getElementById('simulator-tickets').value = '';
            document.getElementById('simulation-results').innerHTML = '<p>Run a simulation to see results</p>';
            document.getElementById('winning-numbers').innerHTML = '<p>Run a simulation to see winning numbers</p>';
            
            // Clear chart
            if (appState.charts.simulationChart) {
                appState.charts.simulationChart.destroy();
                appState.charts.simulationChart = null;
            }
        }

        function loadSampleTickets() {
            const gameType = document.getElementById('simulator-game-type').value;
            let sampleTickets = '';
            
            switch(gameType) {
                case 'powerball':
                    sampleTickets = `3, 17, 28, 35, 42, 22\n7, 19, 31, 44, 55, 11\n2, 11, 25, 38, 49, 19\n5, 14, 29, 33, 47, 8\n9, 18, 27, 36, 45, 15`;
                    break;
                case 'megamillions':
                    sampleTickets = `4, 12, 23, 34, 48, 7\n8, 15, 27, 39, 52, 14\n1, 13, 26, 37, 50, 3\n6, 19, 31, 44, 56, 9\n10, 21, 35, 47, 55, 12`;
                    break;
                case 'euromillions':
                    sampleTickets = `2, 14, 25, 33, 47, 3, 8\n5, 17, 28, 36, 49, 1, 7\n9, 18, 27, 39, 42, 5, 11\n4, 16, 29, 35, 48, 2, 9\n7, 19, 31, 44, 50, 4, 10`;
                    break;
                case 'lotto649':
                    sampleTickets = `3, 12, 23, 34, 41, 48\n7, 15, 27, 35, 42, 49\n2, 14, 26, 33, 45, 47\n5, 17, 29, 36, 44, 46\n9, 18, 25, 37, 43, 49`;
                    break;
            }
            
            document.getElementById('simulator-tickets').value = sampleTickets;
            showToast('Sample tickets loaded', 'success', 'dice');
        }

        // Predictor functions
        function updatePredictor() {
            // Update any predictor-specific UI elements
            updateModelDetails();
        }

        function updateModelDetails() {
            const model = document.getElementById('predictor-method').value;
            const details = appState.predictionModels[model];
            const container = document.getElementById('model-details');
            
            container.innerHTML = `
                <h3>${details.name}</h3>
                <p>${details.description}</p>
                <p><strong>Historical Accuracy:</strong> ${details.accuracy}</p>
                
                <h4 style="margin-top: 15px;">How It Works</h4>
                ${getModelExplanation(model)}
            `;
        }

        function getModelExplanation(model) {
            switch(model) {
                case 'markov':
                    return `
                        <p>The Markov Chain model analyzes sequences of numbers in historical draws to determine transition probabilities - 
                        how likely a number is to follow another number. It then uses these probabilities to predict future numbers.</p>
                        <p>For example, if the number 7 has frequently been followed by 15 in past draws, the model may predict 15 as more likely 
                        to appear after 7 in future draws.</p>
                    `;
                    
                case 'neural':
                    return `
                        <p>The Neural Network model is a deep learning algorithm trained on historical lottery data. It can identify complex, 
                        non-linear patterns that traditional statistical methods might miss.</p>
                        <p>The network consists of multiple layers that process the input data (past draws) and learn to recognize patterns 
                        that lead to certain number combinations being drawn.</p>
                    `;
                    
                case 'regression':
                    return `
                        <p>Regression Analysis looks for statistical relationships between numbers in lottery draws. It identifies numbers 
                        that tend to appear together more often than random chance would predict.</p>
                        <p>The model calculates coefficients that represent the strength of relationships between numbers and uses these to 
                        predict which numbers are more likely to appear together in future draws.</p>
                    `;
                    
                case 'frequency':
                    return `
                        <p>Frequency Analysis prioritizes numbers based on their historical appearance rates, with adjustments for recent trends 
                        and overdue numbers.</p>
                        <p>The model tracks how often each number has appeared, how recently it has appeared, and how long it has been since its 
                        last appearance to predict which numbers are "due" to appear.</p>
                    `;
                    
                case 'combined':
                    return `
                        <p>The Combined AI Model uses an ensemble approach that weights predictions from multiple models (Markov, Neural, 
                        Regression, Frequency) to produce the most balanced predictions.</p>
                        <p>Each model's predictions are weighted based on its historical accuracy, and the combined prediction takes into account 
                        all the different patterns identified by the individual models.</p>
                    `;
                    
                default:
                    return '';
            }
        }

        function generatePredictions() {
            const model = document.getElementById('predictor-method').value;
            const gameType = document.getElementById('predictor-game-type').value;
            const count = parseInt(document.getElementById('prediction-count').value);
            
            if (!appState.historicalData[gameType] || appState.historicalData[gameType].length === 0) {
                showToast('No historical data available for predictions', 'warning', 'exclamation-triangle');
                return;
            }
            
            showToast(`Generating predictions using ${model} model...`, 'info', 'spinner fa-spin');
            
            // Simulate processing delay
            setTimeout(() => {
                const predictions = [];
                let mainPool, pickCount, bonusPool, bonusCount;
                
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        pickCount = 5;
                        bonusPool = 25;
                        bonusCount = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        pickCount = 5;
                        bonusPool = 12;
                        bonusCount = 2;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        pickCount = 6;
                        bonusPool = 0;
                        bonusCount = 0;
                        break;
                }
                
                // Generate predictions based on model
                for (let i = 0; i < count; i++) {
                    let mainNumbers = [];
                    let bonusNumbers = [];
                    
                    switch(model) {
                        case 'markov':
                            mainNumbers = generateMarkovPredictions(mainPool, pickCount, gameType);
                            break;
                            
                        case 'neural':
                            mainNumbers = generateNeuralPredictions(mainPool, pickCount, gameType);
                            break;
                            
                        case 'regression':
                            mainNumbers = generateRegressionPredictions(mainPool, pickCount, gameType);
                            break;
                            
                        case 'frequency':
                            mainNumbers = generateFrequencyPredictions(mainPool, pickCount, gameType);
                            break;
                            
                        case 'combined':
                            mainNumbers = generateCombinedPredictions(mainPool, pickCount, gameType);
                            break;
                    }
                    
                    // Generate random bonus numbers (not predicted)
                    if (bonusCount > 0) {
                        bonusNumbers = generateRandomNumbers(bonusPool, bonusCount, 'standard');
                    }
                    
                    predictions.push({
                        numbers: mainNumbers.sort((a, b) => a - b),
                        bonusNumbers: bonusCount > 0 ? bonusNumbers.sort((a, b) => a - b) : null
                    });
                }
                
                displayPredictionResults(predictions);
                showToast(`${count} predictions generated`, 'success', 'crystal-ball');
            }, 1500);
        }

        function generateMarkovPredictions(poolSize, count, gameType) {
            // In a real app, this would use actual Markov chain probabilities
            // For this demo, we'll simulate with weighted probabilities based on historical data
            
            const history = appState.historicalData[gameType];
            const numbers = [];
            
            // Create weighted probabilities favoring numbers that have appeared recently
            const weights = Array(poolSize).fill(1);
            
            // Increase weight for numbers that have appeared recently
            const recentDraws = history.slice(-20); // Last 20 draws
            recentDraws.forEach(draw => {
                draw.numbers.forEach(num => {
                    weights[num - 1] += 2;
                });
            });
            
            // Further increase weight for numbers in "hot" state
            if (appState.hotColdData[gameType]) {
                appState.hotColdData[gameType].frequencies.forEach(item => {
                    if (item.recent > 2) { // Appeared more than twice recently
                        weights[item.number - 1] += 3;
                    }
                });
            }
            
            // Select numbers based on weights
            while (numbers.length < count) {
                // Calculate total weight
                const totalWeight = weights.reduce((sum, w, i) => 
                    numbers.includes(i + 1) ? sum : sum + w, 0);
                
                if (totalWeight <= 0) break; // No more available numbers
                
                // Select number based on weight
                let random = Math.random() * totalWeight;
                let sum = 0;
                let selectedNum = -1;
                
                for (let i = 0; i < weights.length; i++) {
                    if (numbers.includes(i + 1)) continue;
                    
                    sum += weights[i];
                    if (random <= sum) {
                        selectedNum = i + 1;
                        break;
                    }
                }
                
                // Fallback if no selection (shouldn't happen with proper weights)
                if (selectedNum === -1) {
                    const available = Array.from({length: poolSize}, (_, i) => i + 1)
                        .filter(n => !numbers.includes(n));
                    if (available.length === 0) break;
                    
                    selectedNum = available[Math.floor(Math.random() * available.length)];
                }
                
                numbers.push(selectedNum);
                
                // Reduce weight of adjacent numbers to prevent clustering
                for (let i = Math.max(0, selectedNum - 3); i < Math.min(poolSize, selectedNum + 3); i++) {
                    weights[i] *= 0.7;
                }
            }
            
            return numbers;
        }

        function generateNeuralPredictions(poolSize, count, gameType) {
            // In a real app, this would use an actual trained neural network
            // For this demo, we'll simulate with a more complex weighting system
            
            const history = appState.historicalData[gameType];
            const numbers = [];
            
            // Create more sophisticated weights based on multiple factors
            const weights = Array(poolSize).fill(1);
            
            // Factor 1: Recent frequency (exponential decay)
            history.forEach((draw, index) => {
                const recencyWeight = 0.95 ** (history.length - index - 1); // More recent = higher weight
                draw.numbers.forEach(num => {
                    weights[num - 1] += 2 * recencyWeight;
                });
            });
            
            // Factor 2: Positional frequency (if number appears often in certain positions)
            const positionWeights = Array(poolSize).fill(0);
            const positionCount = history[0].numbers.length;
            
            history.forEach(draw => {
                draw.numbers.forEach((num, pos) => {
                    positionWeights[num - 1] += (positionCount - pos) * 0.2; // Higher weight for earlier positions
                });
            });
            
            // Combine weights
            for (let i = 0; i < poolSize; i++) {
                weights[i] += positionWeights[i];
                
                // Factor 3: Prime numbers get slight boost
                if (isPrime(i + 1)) weights[i] *= 1.1;
                
                // Factor 4: Numbers ending with 7 or 3 get slight boost
                const lastDigit = (i + 1) % 10;
                if (lastDigit === 7 || lastDigit === 3) weights[i] *= 1.05;
            }
            
            // Select numbers based on weights
            while (numbers.length < count) {
                // Calculate total weight
                const totalWeight = weights.reduce((sum, w, i) => 
                    numbers.includes(i + 1) ? sum : sum + w, 0);
                
                if (totalWeight <= 0) break;
                
                // Select number based on weight
                let random = Math.random() * totalWeight;
                let sum = 0;
                let selectedNum = -1;
                
                for (let i = 0; i < weights.length; i++) {
                    if (numbers.includes(i + 1)) continue;
                    
                    sum += weights[i];
                    if (random <= sum) {
                        selectedNum = i + 1;
                        break;
                    }
                }
                
                // Fallback if no selection
                if (selectedNum === -1) {
                    const available = Array.from({length: poolSize}, (_, i) => i + 1)
                        .filter(n => !numbers.includes(n));
                    if (available.length === 0) break;
                    
                    selectedNum = available[Math.floor(Math.random() * available.length)];
                }
                
                numbers.push(selectedNum);
                
                // Adjust weights based on selected numbers (negative correlation)
                for (let i = 0; i < weights.length; i++) {
                    if (numbers.includes(i + 1)) {
                        weights[i] = 0;
                    } else {
                        // Reduce weight of numbers close to selected numbers
                        const distance = Math.abs((i + 1) - selectedNum);
                        if (distance <= 5) {
                            weights[i] *= 0.8;
                        } else if (distance <= 10) {
                            weights[i] *= 0.9;
                        }
                    }
                }
            }
            
            return numbers;
        }

        function generateRegressionPredictions(poolSize, count, gameType) {
            // In a real app, this would use actual regression coefficients
            // For this demo, we'll simulate with co-occurrence probabilities
            
            const history = appState.historicalData[gameType];
            const numbers = [];
            
            // Calculate co-occurrence frequencies
            const coOccurrence = Array(poolSize).fill().map(() => Array(poolSize).fill(0));
            
            history.forEach(draw => {
                const nums = draw.numbers;
                for (let i = 0; i < nums.length; i++) {
                    for (let j = i + 1; j < nums.length; j++) {
                        coOccurrence[nums[i] - 1][nums[j] - 1]++;
                        coOccurrence[nums[j] - 1][nums[i] - 1]++;
                    }
                }
            });
            
            // Calculate average co-occurrence for each number
            const avgCoOccurrence = Array(poolSize).fill(0);
            for (let i = 0; i < poolSize; i++) {
                avgCoOccurrence[i] = coOccurrence[i].reduce((sum, val) => sum + val, 0) / poolSize;
            }
            
            // Start with number that has highest average co-occurrence
            let currentNum = avgCoOccurrence.indexOf(Math.max(...avgCoOccurrence)) + 1;
            numbers.push(currentNum);
            
            // Add numbers that co-occur most with current numbers
            while (numbers.length < count) {
                // Calculate scores for remaining numbers
                const scores = Array(poolSize).fill(0);
                for (let i = 0; i < poolSize; i++) {
                    if (numbers.includes(i + 1)) continue;
                    
                    // Score is sum of co-occurrence with all selected numbers
                    scores[i] = numbers.reduce((sum, num) => sum + coOccurrence[num - 1][i], 0);
                }
                
                // Select number with highest score
                const maxScore = Math.max(...scores);
                if (maxScore <= 0) break; // No more co-occurrence data
                
                const nextNum = scores.indexOf(maxScore) + 1;
                numbers.push(nextNum);
            }
            
            // If we didn't get enough numbers, fill with random
            if (numbers.length < count) {
                const needed = count - numbers.length;
                const available = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !numbers.includes(n));
                
                for (let i = 0; i < needed && available.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * available.length);
                    numbers.push(available.splice(randomIndex, 1)[0]);
                }
            }
            
            return numbers;
        }

        function generateFrequencyPredictions(poolSize, count, gameType) {
            if (!appState.hotColdData[gameType]) {
                return generateRandomNumbers(poolSize, count, 'standard');
            }
            
            const frequencies = [...appState.hotColdData[gameType].frequencies];
            const numbers = [];
            
            // Sort by combined score of recent and all-time frequency
            frequencies.sort((a, b) => {
                const scoreA = (a.recent * 2) + a.allTime; // Weight recent more heavily
                const scoreB = (b.recent * 2) + b.allTime;
                return scoreB - scoreA;
            });
            
            // Select top numbers
            const topNumbers = frequencies.slice(0, Math.floor(poolSize * 0.4)) // Top 40%
                .map(item => item.number);
            
            // Select from top numbers with some randomness
            while (numbers.length < count && topNumbers.length > 0) {
                // Weight towards higher ranked numbers
                const index = Math.floor(Math.pow(Math.random(), 2) * topNumbers.length);
                const num = topNumbers.splice(index, 1)[0];
                numbers.push(num);
            }
            
            // If not enough, fill with random from remaining
            if (numbers.length < count) {
                const needed = count - numbers.length;
                const available = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !numbers.includes(n));
                
                for (let i = 0; i < needed && available.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * available.length);
                    numbers.push(available.splice(randomIndex, 1)[0]);
                }
            }
            
            return numbers;
        }

        function generateCombinedPredictions(poolSize, count, gameType) {
            // Combine predictions from all models with different weights
            const markov = generateMarkovPredictions(poolSize, count, gameType);
            const neural = generateNeuralPredictions(poolSize, count, gameType);
            const regression = generateRegressionPredictions(poolSize, count, gameType);
            const frequency = generateFrequencyPredictions(poolSize, count, gameType);
            
            // Count votes for each number
            const votes = Array(poolSize).fill(0);
            const models = [markov, neural, regression, frequency];
            
            models.forEach(model => {
                model.forEach(num => {
                    votes[num - 1]++;
                });
            });
            
            // Select numbers with most votes
            const numbers = [];
            const sorted = Array.from({length: poolSize}, (_, i) => i + 1)
                .sort((a, b) => votes[b - 1] - votes[a - 1]);
            
            for (let i = 0; i < count && i < sorted.length; i++) {
                numbers.push(sorted[i]);
            }
            
            return numbers;
        }

        function displayPredictionResults(predictions) {
            const container = document.getElementById('prediction-results');
            let html = '<h3>Predicted Numbers</h3>';
            
            predictions.forEach((prediction, index) => {
                html += `<div class="result" style="margin-bottom: 1rem;">
                    <h4>Prediction #${index + 1}</h4>
                    <div class="lotto-balls">`;
                
                // Main numbers
                prediction.numbers.forEach(num => {
                    html += `<div class="ball">${num}</div>`;
                });
                
                // Bonus numbers
                if (prediction.bonusNumbers && prediction.bonusNumbers.length > 0) {
                    prediction.bonusNumbers.forEach(num => {
                        const gameType = document.getElementById('predictor-game-type').value;
                        const ballClass = gameType === 'powerball' ? 'powerball' : 
                                          gameType === 'megamillions' ? 'megaball' : 'eurostar';
                        html += `<div class="ball ${ballClass}">${num}</div>`;
                    });
                }
                
                html += `</div></div>`;
            });
            
            container.innerHTML = html;
            
            // Update prediction chart
            updatePredictionChart(predictions);
        }

        function updatePredictionChart(predictions) {
            const ctx = document.getElementById('prediction-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (appState.charts.predictionChart) {
                appState.charts.predictionChart.destroy();
            }
            
            // Count frequency of each number in predictions
            const frequencyMap = {};
            predictions.forEach(pred => {
                pred.numbers.forEach(num => {
                    frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                });
            });
            
            // Convert to array and sort
            const frequencyArray = Object.keys(frequencyMap).map(num => ({
                number: parseInt(num),
                count: frequencyMap[num]
            })).sort((a, b) => b.count - a.count);
            
            // Prepare data for chart
            const labels = frequencyArray.map(item => item.number);
            const data = frequencyArray.map(item => item.count);
            
            appState.charts.predictionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Prediction Frequency',
                        data: data,
                        backgroundColor: 'rgba(74, 107, 255, 0.7)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Number'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Appears in ${context.raw} prediction${context.raw !== 1 ? 's' : ''}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function analyzePredictions() {
            const predictionsContainer = document.getElementById('prediction-results');
            if (!predictionsContainer.textContent.trim() || 
                predictionsContainer.textContent.includes('Generate predictions to see results')) {
                showToast('No predictions to analyze', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('predictor-game-type').value;
            if (!appState.historicalData[gameType] || appState.historicalData[gameType].length === 0) {
                showToast('No historical data to compare against', 'warning', 'exclamation-triangle');
                return;
            }
            
            showToast('Analyzing predictions against historical data...', 'info', 'spinner fa-spin');
            
            // Simulate processing delay
            setTimeout(() => {
                // Get all predicted numbers
                const predictedNumbers = [];
                document.querySelectorAll('#prediction-results .ball:not(.powerball):not(.megaball):not(.eurostar)')
                    .forEach(ball => {
                        predictedNumbers.push(parseInt(ball.textContent));
                    });
                
                const uniqueNumbers = [...new Set(predictedNumbers)];
                
                // Calculate historical frequency of predicted numbers
                const history = appState.historicalData[gameType];
                const frequencyMap = {};
                
                uniqueNumbers.forEach(num => {
                    frequencyMap[num] = 0;
                });
                
                history.forEach(draw => {
                    draw.numbers.forEach(num => {
                        if (uniqueNumbers.includes(num)) {
                            frequencyMap[num]++;
                        }
                    });
                });
                
                // Convert to array and sort
                const frequencyArray = Object.keys(frequencyMap).map(num => ({
                    number: parseInt(num),
                    count: frequencyMap[num],
                    percentage: (frequencyMap[num] / history.length * 100).toFixed(2)
                })).sort((a, b) => b.count - a.count);
                
                // Display analysis
                const container = document.getElementById('prediction-analysis');
                let html = `
                    <h3>Historical Performance of Predicted Numbers</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Number</th>
                                <th>Times Drawn</th>
                                <th>Percentage of Draws</th>
                                <th>Last Drawn</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                frequencyArray.forEach(item => {
                    // Find when this number was last drawn
                    let lastDrawn = 'Never';
                    for (let i = history.length - 1; i >= 0; i--) {
                        if (history[i].numbers.includes(item.number)) {
                            lastDrawn = history[i].date;
                            break;
                        }
                    }
                    
                    html += `
                        <tr>
                            <td>${item.number}</td>
                            <td>${item.count}</td>
                            <td>${item.percentage}%</td>
                            <td>${lastDrawn}</td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
                showToast('Prediction analysis completed', 'success', 'chart-bar');
            }, 1000);
        }

        function clearPredictions() {
            document.getElementById('prediction-results').innerHTML = '<p>Generate predictions to see results</p>';
            document.getElementById('prediction-analysis').innerHTML = '<p>Generate predictions to see analysis</p>';
            
            // Clear chart
            if (appState.charts.predictionChart) {
                appState.charts.predictionChart.destroy();
                appState.charts.predictionChart = null;
            }
        }

        // Utility functions
        function loadSampleData() {
            // Load sample historical data for Powerball
            if (!appState.historicalData['powerball']) {
                appState.historicalData['powerball'] = generateMockHistory('powerball', 100);
                processHotColdNumbers('powerball', appState.historicalData['powerball']);
            }
            
            // Load sample historical data for Mega Millions
            if (!appState.historicalData['megamillions']) {
                appState.historicalData['megamillions'] = generateMockHistory('megamillions', 100);
                processHotColdNumbers('megamillions', appState.historicalData['megamillions']);
            }
            
            // Load sample historical data for EuroMillions
            if (!appState.historicalData['euromillions']) {
                appState.historicalData['euromillions'] = generateMockHistory('euromillions', 100);
                processHotColdNumbers('euromillions', appState.historicalData['euromillions']);
            }
            
            // Load sample historical data for Lotto 6/49
            if (!appState.historicalData['lotto649']) {
                appState.historicalData['lotto649'] = generateMockHistory('lotto649', 100);
                processHotColdNumbers('lotto649', appState.historicalData['lotto649']);
            }
            
            showToast('Sample data loaded for all games', 'success', 'database');
        }

        // Initialize the application
        initTheme();
    </script>
</body>
</html>
