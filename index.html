
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lotto Pro - Advanced Lottery Prediction System</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>
    <style>
        :root {
            --primary: #4a6bff;
            --primary-dark: #3a56cc;
            --primary-light: #6b89ff;
            --secondary: #2dd4bf;
            --dark: #1e293b;
            --light: #f8fafc;
            --accent: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        [data-theme="dark"] {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #14b8a6;
            --dark: #e2e8f0;
            --light: #1e293b;
            --accent: #a78bfa;
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #f87171;
            --info: #60a5fa;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --border-color: #334155;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.25);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-color);
            transition: all 0.3s ease;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 0 0 10px 10px;
            box-shadow: var(--shadow-md);
            margin-bottom: 2rem;
            position: relative;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 600;
            letter-spacing: -0.025em;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-top: 0.5rem;
            font-weight: 300;
        }

        .card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
            padding: 1.75rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .card h2 {
            color: var(--primary);
            margin-top: 0;
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            font-weight: 600;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--accent);
        }

        .card h3 {
            color: var(--text-primary);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            font-size: 1.2rem;
        }

        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
            font-weight: 500;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .tab:hover {
            background: var(--primary-light);
            color: white;
            border-color: var(--primary-light);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: 600;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tab-content.active {
            display: block;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            background: var(--card-bg);
            color: var(--text-primary);
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(74, 107, 255, 0.2);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-sm);
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        button:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        button.secondary {
            background-color: var(--text-secondary);
        }

        button.success {
            background-color: var(--success);
        }

        button.warning {
            background-color: var(--warning);
        }

        button.danger {
            background-color: var(--danger);
        }

        button.info {
            background-color: var(--info);
        }

        button.accent {
            background-color: var(--accent);
        }

        .result {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
            border-left: 4px solid var(--accent);
            color: var(--text-primary);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.75rem;
        }

        .lotto-balls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
            align-items: center;
        }

        .ball {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            font-size: 1.1rem;
        }

        .ball:hover {
            transform: scale(1.15);
            box-shadow: var(--shadow);
        }

        .ball.powerball {
            background-color: var(--danger);
        }

        .ball.megaball {
            background-color: var(--info);
        }

        .ball.eurostar {
            background-color: var(--success);
        }

        .ball.hot-number {
            background-color: var(--danger);
            animation: pulse 2s infinite;
        }

        .ball.cold-number {
            background-color: var(--info);
        }

        .ball.prime-number {
            background-color: var(--accent);
        }

        .ball.fibonacci-number {
            background-color: var(--warning);
        }

        .ball.lucky-number {
            background-color: var(--success);
        }

        .progress-container {
            width: 100%;
            background-color: var(--border-color);
            border-radius: 6px;
            margin: 1rem 0;
            height: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                -45deg,
                rgba(255, 255, 255, 0.2) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.2) 75%,
                transparent 75%,
                transparent
            );
            background-size: 30px 30px;
            animation: progressAnimation 1s linear infinite;
        }

        @keyframes progressAnimation {
            0% { background-position: 0 0; }
            100% { background-position: 30px 0; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .status {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .status.info {
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--info);
            color: var(--info);
        }

        .status.success {
            background-color: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
            color: var(--success);
        }

        .status.warning {
            background-color: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
            color: var(--warning);
        }

        .status.error {
            background-color: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
            color: var(--danger);
        }

        .algorithm-info {
            margin-top: 2rem;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
            border-left: 4px solid var(--accent);
        }

        .code {
            font-family: 'Source Code Pro', monospace;
            background-color: var(--bg-color);
            padding: 0.75rem;
            border-radius: 6px;
            display: block;
            overflow-x: auto;
            margin: 0.75rem 0;
            border-left: 4px solid var(--accent);
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-color);
            font-weight: 600;
            color: var(--primary);
        }

        tr:hover {
            background-color: var(--bg-color);
        }

        /* Histogram styles */
        .histogram {
            display: flex;
            height: 220px;
            align-items: flex-end;
            gap: 2px;
            margin: 1rem 0;
            padding: 1rem 0;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        .histogram-bar {
            flex: 1;
            background: linear-gradient(to top, var(--primary), var(--secondary));
            min-width: 5px;
            position: relative;
            transition: height 0.5s ease;
        }

        .histogram-bar-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Frequency table styles */
        .frequency-table {
            width: 100%;
            margin: 1.5rem 0;
        }

        .frequency-table th, .frequency-table td {
            padding: 10px;
            text-align: center;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: var(--dark);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            box-shadow: var(--shadow-lg);
            font-size: 0.9rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Theme toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(30deg) scale(1.1);
            box-shadow: var(--shadow);
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Action buttons container */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin: 1.5rem 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                border-radius: 6px;
                margin-bottom: 5px;
            }
        }

        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }

        /* Export buttons */
        .export-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        /* Save/Load buttons */
        .config-buttons {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        /* Tab icons */
        .tab-icon {
            font-size: 0.95em;
        }
        
        /* Notification toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success);
            color: white;
            padding: 14px 28px;
            border-radius: 6px;
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            max-width: 400px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Improved number input styling */
        input[type="number"] {
            -moz-appearance: textfield;
        }
        
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Better table styling */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-sm);
        }
        
        .data-table th {
            background-color: var(--primary);
            color: white;
            padding: 14px;
            text-align: left;
            font-weight: 600;
        }
        
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .data-table tr:nth-child(even) {
            background-color: rgba(0,0,0,0.03);
        }
        
        .data-table tr:hover {
            background-color: var(--bg-color);
        }
        
        /* Strategy selector */
        .strategy-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .strategy-option {
            padding: 0.75rem 1.25rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
        }
        
        .strategy-option:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .strategy-option.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: 600;
            box-shadow: var(--shadow);
        }
        
        /* Number matrix */
        .number-matrix {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 6px;
            margin: 1.5rem 0;
        }
        
        .number-cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            box-shadow: var(--shadow-sm);
        }
        
        .number-cell:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .number-cell.selected {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            font-weight: bold;
            box-shadow: var(--shadow);
        }
        
        /* Wheel visualization */
        .wheel-container {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
        }
        
        .wheel {
            width: 320px;
            height: 320px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 6px solid var(--border-color);
            box-shadow: var(--shadow-md);
        }
        
        .wheel-number {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: bottom right;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        /* History table */
        .history-table {
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-sm);
        }

        /* New styles for enhanced features */
        .coverage-meter {
            width: 100%;
            height: 22px;
            background-color: var(--border-color);
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        .coverage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .number-coverage {
            margin: 20px 0;
        }
        
        .number-coverage span {
            display: inline-block;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            margin: 3px;
            font-size: 13px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }
        
        .number-coverage span.covered {
            background-color: var(--success);
            color: white;
            border-color: var(--success);
            transform: scale(1.1);
        }
        
        .simulation-results {
            margin-top: 25px;
        }
        
        .simulation-chart {
            width: 100%;
            height: 350px;
            margin: 25px 0;
        }
        
        .strategy-performance {
            margin-top: 25px;
        }
        
        .performance-metric {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 1.05rem;
        }
        
        .performance-metric span:first-child {
            font-weight: 600;
        }
        
        .performance-bar {
            height: 12px;
            background-color: var(--border-color);
            border-radius: 6px;
            margin: 8px 0;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        .performance-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        /* Stats cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow-sm);
            text-align: center;
            transition: all 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }
        
        .stat-card h3 {
            font-size: 1.05rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .stat-card p {
            font-size: 1.7rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        /* Number trends */
        .trend-indicator {
            display: inline-block;
            margin-left: 5px;
        }
        
        .trend-up {
            color: var(--success);
        }
        
        .trend-down {
            color: var(--danger);
        }
        
        /* Draw simulator */
        .simulator-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        /* Wheel strategy */
        .wheel-strategy {
            margin: 25px 0;
        }
        
        .wheel-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .wheel-section-label {
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        /* Print styles */
        @media print {
            body * {
                visibility: hidden;
            }
            .printable, .printable * {
                visibility: visible;
            }
            .printable {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }
            .no-print {
                display: none !important;
            }
        }

        /* Advanced analysis cards */
        .analysis-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s;
        }
        
        .analysis-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        .analysis-card h3 {
            color: var(--primary);
            margin-top: 0;
            margin-bottom: 1rem;
            font-weight: 600;
            font-size: 1.25rem;
        }
        
        /* Pattern recognition */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .pattern-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }
        
        .pattern-card h4 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        
        /* Prediction engine */
        .prediction-engine {
            margin-top: 2rem;
        }
        
        .prediction-results {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .prediction-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            width: calc(33.333% - 1rem);
            min-width: 250px;
        }
        
        @media (max-width: 768px) {
            .prediction-card {
                width: 100%;
            }
        }
        
        /* Number clusters */
        .cluster-container {
            margin: 1.5rem 0;
        }
        
        .cluster {
            display: inline-block;
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-color);
            border-radius: 20px;
            border: 1px solid var(--border-color);
        }
        
        /* AI recommendations */
        .ai-recommendation {
            background: linear-gradient(135deg, rgba(74, 107, 255, 0.1), rgba(45, 212, 191, 0.1));
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: 6px;
            margin: 1.5rem 0;
        }
        
        /* Number patterns */
        .pattern-visualization {
            width: 100%;
            height: 300px;
            background: var(--bg-color);
            border-radius: 8px;
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
        }
        
        /* Seed input */
        .seed-input {
            display: flex;
            gap: 10px;
            margin-bottom: 1rem;
        }
        
        .seed-input input {
            flex: 1;
        }
        
        .seed-input button {
            margin-bottom: 1rem;
        }
        
        /* Algorithm selector */
        .algorithm-selector {
            margin-bottom: 1.5rem;
        }
        
        /* Number distribution */
        .distribution-chart {
            width: 100%;
            height: 300px;
            margin: 1.5rem 0;
        }
        
        /* Number gap analysis */
        .gap-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number sum analysis */
        .sum-analysis {
            margin: 1.5rem 0;
        }
        
        /* Last digits analysis */
        .last-digit-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number matrix analysis */
        .matrix-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number wheel visualization */
        .wheel-visualization {
            margin: 1.5rem 0;
        }
        
        /* Number probability */
        .probability-indicator {
            height: 10px;
            background: var(--border-color);
            border-radius: 5px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .probability-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
        }
        
        /* Number statistics */
        .number-stats {
            margin: 1.5rem 0;
        }
        
        /* Number trends over time */
        .trend-chart {
            width: 100%;
            height: 300px;
            margin: 1.5rem 0;
        }
        
        /* Number sequences */
        .sequence-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number pairing analysis */
        .pair-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number position analysis */
        .position-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number frequency over time */
        .frequency-trend {
            margin: 1.5rem 0;
        }
        
        /* Number prediction model */
        .prediction-model {
            margin: 1.5rem 0;
        }
        
        /* Number pattern recognition */
        .pattern-recognition {
            margin: 1.5rem 0;
        }
        
        /* Number cluster analysis */
        .cluster-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number distribution analysis */
        .distribution-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number probability analysis */
        .probability-analysis {
            margin: 1.5rem 0;
        }
        
        /* Number wheel coverage */
        .wheel-coverage {
            margin: 1.5rem 0;
        }
        
        /* Number sum distribution */
        .sum-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number last digit distribution */
        .last-digit-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number matrix coverage */
        .matrix-coverage {
            margin: 1.5rem 0;
        }
        
        /* Number position frequency */
        .position-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number pairing frequency */
        .pair-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number sequence frequency */
        .sequence-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number gap frequency */
        .gap-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number cluster frequency */
        .cluster-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number prediction accuracy */
        .prediction-accuracy {
            margin: 1.5rem 0;
        }
        
        /* Number pattern frequency */
        .pattern-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number distribution frequency */
        .distribution-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number probability frequency */
        .probability-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number wheel frequency */
        .wheel-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number sum frequency */
        .sum-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number last digit frequency */
        .last-digit-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number matrix frequency */
        .matrix-frequency {
            margin: 1.5rem 0;
        }
        
        /* Number position distribution */
        .position-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number pairing distribution */
        .pair-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number sequence distribution */
        .sequence-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number gap distribution */
        .gap-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number cluster distribution */
        .cluster-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number prediction distribution */
        .prediction-distribution {
            margin: 1.5rem 0;
        }
        
        /* Number pattern distribution */
        .pattern-distribution {
            margin: 1.5rem 0;
        }
        
        /* Responsive tweaks */
        @media (max-width: 1024px) {
            .card {
                padding: 1.25rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }
        }
        
        @media (max-width: 640px) {
            .card {
                padding: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .number-matrix {
                grid-template-columns: repeat(5, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">
                <i class="fas fa-moon"></i>
            </button>
            <h1>Lotto Pro</h1>
            <p class="subtitle">Advanced Lottery Prediction & Analysis System</p>
        </div>
    </header>
    
    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="generator">
                <i class="fas fa-magic tab-icon"></i> Smart Generator
            </button>
            <button class="tab" data-tab="analyzer">
                <i class="fas fa-chart-line tab-icon"></i> Advanced Analyzer
            </button>
            <button class="tab" data-tab="history">
                <i class="fas fa-database tab-icon"></i> Historical Data
            </button>
            <button class="tab" data-tab="strategies">
                <i class="fas fa-robot tab-icon"></i> AI Strategies
            </button>
            <button class="tab" data-tab="simulator">
                <i class="fas fa-vial tab-icon"></i> Probability Lab
            </button>
            <button class="tab" data-tab="predictor">
                <i class="fas fa-crystal-ball tab-icon"></i> Prediction Engine
            </button>
        </div>
      
        <!-- Generator Tab -->
        <div id="generator" class="tab-content active">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Lottery Selection</h2>
                        <label for="game-type">Lottery Game:</label>
                        <select id="game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                            <option value="custom">Custom Game</option>
                        </select>
                        
                        <div id="custom-params" style="display: none;">
                            <div class="grid">
                                <div>
                                    <label for="main-numbers">Main Numbers Pool:</label>
                                    <input type="number" id="main-numbers" min="1" value="69">
                                </div>
                                <div>
                                    <label for="pick-numbers">Numbers to Pick:</label>
                                    <input type="number" id="pick-numbers" min="1" value="5">
                                </div>
                            </div>
                            <div class="grid">
                                <div>
                                    <label for="bonus-numbers">Bonus Numbers Pool:</label>
                                    <input type="number" id="bonus-numbers" min="0" value="26">
                                </div>
                                <div>
                                    <label for="pick-bonus">Bonus Numbers to Pick:</label>
                                    <input type="number" id="pick-bonus" min="0" value="1">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Generation Options</h2>
                        <div class="seed-input">
                            <input type="text" id="random-seed" placeholder="Optional seed for reproducible results">
                            <button onclick="generateSeed()" class="accent">
                                <i class="fas fa-seedling"></i> Random Seed
                            </button>
                        </div>
                        
                        <label for="generation-method">Generation Method:</label>
                        <select id="generation-method">
                            <option value="standard">Standard Random</option>
                            <option value="shuffle">Fisher-Yates Shuffle</option>
                            <option value="crypto">Cryptographically Secure</option>
                            <option value="low-high">Low-High Balance</option>
                            <option value="odd-even">Odd-Even Balance</option>
                            <option value="prime">Prime Numbers</option>
                            <option value="fibonacci">Fibonacci Numbers</option>
                            <option value="lucky">Lucky Numbers</option>
                            <option value="hot-cold">Hot & Cold Numbers</option>
                            <option value="wheel">Wheel System</option>
                            <option value="ai">AI-Powered Prediction</option>
                        </select>
                        
                        <div id="method-params" style="margin-top: 15px;">
                            <!-- Parameters will be inserted here based on method -->
                        </div>
                        
                        <label for="draw-count">Number of tickets:</label>
                        <input type="number" id="draw-count" min="1" value="5" max="100">
                        
                        <div class="action-buttons">
                            <button onclick="generateNumbers()" class="success">
                                <i class="fas fa-play"></i> Generate
                            </button>
                            <button onclick="quickPick()" class="warning">
                                <i class="fas fa-bolt"></i> Quick Pick
                            </button>
                            <button onclick="clearGeneration()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>AI Recommendations</h2>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-lightbulb"></i> <strong>Tip:</strong> Combine multiple strategies for better coverage. Try using Hot/Cold numbers with Low/High balance for optimal results.</p>
                        </div>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-chart-bar"></i> <strong>Analysis:</strong> Based on historical data, numbers between 1-31 appear more frequently due to birthday selections. Consider including some higher numbers.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Generated Tickets</h2>
                        <div id="generated-results"></div>
                        
                        <div class="export-buttons">
                            <button onclick="exportNumbers('txt')" class="secondary">
                                <i class="fas fa-file-alt"></i> Export as TXT
                            </button>
                            <button onclick="exportNumbers('csv')" class="secondary">
                                <i class="fas fa-file-csv"></i> Export as CSV
                            </button>
                            <button onclick="exportNumbers('json')" class="secondary">
                                <i class="fas fa-file-code"></i> Export as JSON
                            </button>
                            <button onclick="copyNumbers()" class="secondary">
                                <i class="fas fa-copy"></i> Copy to Clipboard
                            </button>
                            <button onclick="printNumbers()" class="secondary">
                                <i class="fas fa-print"></i> Print
                            </button>
                            <button onclick="saveTickets()" class="info">
                                <i class="fas fa-save"></i> Save Tickets
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Number Coverage</h2>
                        <div class="number-coverage" id="number-coverage">
                            <!-- Numbers will be inserted here -->
                        </div>
                        <div class="coverage-meter">
                            <div class="coverage-fill" id="coverage-fill"></div>
                        </div>
                        <p id="coverage-percentage">0% of numbers covered</p>
                    </div>
                    
                    <div class="card">
                        <h2>Frequency Analysis</h2>
                        <div id="frequency-content">
                            <p>Generate some numbers to see frequency analysis</p>
                        </div>
                        <canvas id="frequency-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Analyzer Tab -->
        <div id="analyzer" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Number Analysis</h2>
                        <label for="analyzer-game-type">Lottery Game:</label>
                        <select id="analyzer-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="analyzer-numbers">Numbers to Analyze (comma separated):</label>
                        <input type="text" id="analyzer-numbers" placeholder="e.g. 5, 10, 15, 20, 25, 30">
                        
                        <div class="number-matrix" id="analyzer-number-matrix"></div>
                        
                        <div class="action-buttons">
                            <button onclick="analyzeNumbers()" class="success">Analyze</button>
                            <button onclick="clearAnalyzer()" class="secondary">Clear</button>
                            <button onclick="loadSavedTickets()" class="info">
                                <i class="fas fa-folder-open"></i> Load Saved
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Advanced Analysis</h2>
                        <div class="analysis-card">
                            <h3>Number Sum Analysis</h3>
                            <div id="sum-analysis">
                                <p>Analyze numbers to see sum statistics</p>
                            </div>
                        </div>
                        
                        <div class="analysis-card">
                            <h3>Number Gap Analysis</h3>
                            <div id="gap-analysis">
                                <p>Analyze numbers to see gap statistics</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Analysis Results</h2>
                        <div id="analyzer-results">
                            <p>Enter numbers to analyze them</p>
                        </div>
                        
                        <div class="stats-grid" id="analyzer-stats">
                            <!-- Stats cards will be inserted here -->
                        </div>
                        
                        <canvas id="analyzer-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card">
                        <h2>Pattern Recognition</h2>
                        <div id="pattern-recognition">
                            <p>Analyze numbers to detect patterns</p>
                        </div>
                        <div class="pattern-visualization" id="pattern-visualization"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- History Tab -->
        <div id="history" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Historical Data</h2>
                        <label for="history-game-type">Lottery Game:</label>
                        <select id="history-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="history-draw-count">Number of past draws to load:</label>
                        <input type="number" id="history-draw-count" min="1" max="500" value="100">
                        
                        <div class="action-buttons">
                            <button onclick="loadHistoricalData()" class="success">
                                <i class="fas fa-sync-alt"></i> Load History
                            </button>
                            <button onclick="clearHistory()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button onclick="downloadHistoricalData()" class="info">
                                <i class="fas fa-download"></i> Download Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Historical Trends</h2>
                        <div id="history-trends">
                            <p>Load historical data to see trends</p>
                        </div>
                        <canvas id="history-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Past Draws</h2>
                        <div class="history-table">
                            <table id="history-table">
                                <thead>
                                    <tr>
                                        <th>Draw Date</th>
                                        <th>Numbers</th>
                                        <th>Bonus</th>
                                        <th>Jackpot</th>
                                    </tr>
                                </thead>
                                <tbody id="history-table-body">
                                    <!-- History data will be inserted here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Hot & Cold Numbers</h2>
                        <div id="hot-cold-numbers">
                            <p>Load historical data to see hot and cold numbers</p>
                        </div>
                        <canvas id="hot-cold-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Strategies Tab -->
        <div id="strategies" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>AI-Powered Strategies</h2>
                        <p>Select a strategy to generate numbers based on different approaches:</p>
                        
                        <div class="strategy-selector">
                            <div class="strategy-option active" data-strategy="random">
                                <i class="fas fa-random"></i> Random
                            </div>
                            <div class="strategy-option" data-strategy="low-high">
                                <i class="fas fa-balance-scale"></i> Low-High
                            </div>
                            <div class="strategy-option" data-strategy="odd-even">
                                <i class="fas fa-divide"></i> Odd-Even
                            </div>
                            <div class="strategy-option" data-strategy="prime">
                                <i class="fas fa-superscript"></i> Prime
                            </div>
                            <div class="strategy-option" data-strategy="fibonacci">
                                <i class="fas fa-infinity"></i> Fibonacci
                            </div>
                            <div class="strategy-option" data-strategy="lucky">
                                <i class="fas fa-star"></i> Lucky
                            </div>
                            <div class="strategy-option" data-strategy="hot-cold">
                                <i class="fas fa-fire"></i> Hot/Cold
                            </div>
                            <div class="strategy-option" data-strategy="birthday">
                                <i class="fas fa-birthday-cake"></i> Birthday
                            </div>
                            <div class="strategy-option" data-strategy="ai">
                                <i class="fas fa-brain"></i> AI Prediction
                            </div>
                        </div>
                        
                        <div id="strategy-params" style="margin-top: 15px;">
                            <!-- Strategy parameters will be inserted here -->
                        </div>
                        
                        <div class="action-buttons">
                            <button onclick="generateWithStrategy()" class="success">
                                <i class="fas fa-magic"></i> Generate with Strategy
                            </button>
                            <button onclick="testStrategy()" class="info">
                                <i class="fas fa-flask"></i> Test Strategy
                            </button>
                            <button onclick="saveStrategy()" class="accent">
                                <i class="fas fa-save"></i> Save Strategy
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Strategy Explanation</h2>
                        <div id="strategy-explanation">
                            <p>The <strong>Random</strong> strategy generates numbers completely at random with no particular pattern or strategy. This mimics how lottery numbers are actually drawn.</p>
                        </div>
                        
                        <div class="ai-recommendation">
                            <p><i class="fas fa-robot"></i> <strong>AI Suggestion:</strong> For best results, combine multiple strategies and analyze historical trends before generating your numbers.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Generated Numbers</h2>
                        <div id="strategy-results">
                            <p>Generate numbers to see results</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Strategy Statistics</h2>
                        <div id="strategy-stats">
                            <p>Generate numbers to see statistics</p>
                        </div>
                        <canvas id="strategy-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card strategy-performance" id="strategy-performance" style="display: none;">
                        <h2>Strategy Performance</h2>
                        <div id="performance-results">
                            <!-- Performance results will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Simulator Tab -->
        <div id="simulator" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Probability Lab</h2>
                        <label for="simulator-game-type">Lottery Game:</label>
                        <select id="simulator-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="simulator-tickets">Your Tickets (one per line):</label>
                        <textarea id="simulator-tickets" rows="5" placeholder="Enter your tickets, one per line&#10;Example: 5, 10, 15, 20, 25, 30"></textarea>
                        
                        <label for="simulation-count">Number of simulations:</label>
                        <input type="number" id="simulation-count" min="1" value="1000" max="100000" step="100">
                        
                        <div class="action-buttons">
                            <button onclick="runSimulation()" class="success">
                                <i class="fas fa-play"></i> Run Simulation
                            </button>
                            <button onclick="stopSimulation()" class="danger">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                            <button onclick="clearSimulation()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button onclick="loadSampleTickets()" class="info">
                                <i class="fas fa-dice"></i> Load Sample
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Probability Calculator</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <h3>Jackpot Odds</h3>
                                <p id="jackpot-odds">1 in 292M</p>
                            </div>
                            <div class="stat-card">
                                <h3>Break-even Point</h3>
                                <p id="break-even">$584M</p>
                            </div>
                            <div class="stat-card">
                                <h3>Expected Value</h3>
                                <p id="expected-value">-$0.80</p>
                            </div>
                        </div>
                        <div class="ai-recommendation">
                            <p><i class="fas fa-calculator"></i> <strong>Note:</strong> These calculations assume a $2 ticket price and standard prize structure. Actual values may vary.</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Simulation Results</h2>
                        <div id="simulation-results">
                            <p>Run a simulation to see results</p>
                        </div>
                        
                        <div class="stats-grid" id="simulation-stats">
                            <!-- Stats will be inserted here -->
                        </div>
                        
                        <canvas id="simulation-chart" class="simulation-chart"></canvas>
                    </div>
                    
                    <div class="card">
                        <h2>Winning Numbers</h2>
                        <div id="winning-numbers">
                            <p>Run a simulation to see winning numbers</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Predictor Tab -->
        <div id="predictor" class="tab-content">
            <div class="grid">
                <div>
                    <div class="card">
                        <h2>Prediction Engine</h2>
                        <label for="predictor-game-type">Lottery Game:</label>
                        <select id="predictor-game-type">
                            <option value="powerball">Powerball (5/69 + 1/26)</option>
                            <option value="megamillions">Mega Millions (5/70 + 1/25)</option>
                            <option value="euromillions">EuroMillions (5/50 + 2/12)</option>
                            <option value="lotto649">Lotto 6/49</option>
                        </select>
                        
                        <label for="predictor-method">Prediction Method:</label>
                        <select id="predictor-method">
                            <option value="markov">Markov Chain Model</option>
                            <option value="neural">Neural Network</option>
                            <option value="regression">Regression Analysis</option>
                            <option value="frequency">Frequency Analysis</option>
                            <option value="combined">Combined AI Model</option>
                        </select>
                        
                        <label for="prediction-count">Number of predictions:</label>
                        <input type="number" id="prediction-count" min="1" value="10" max="100">
                        
                        <div class="action-buttons">
                            <button onclick="generatePredictions()" class="success">
                                <i class="fas fa-crystal-ball"></i> Generate Predictions
                            </button>
                            <button onclick="analyzePredictions()" class="info">
                                <i class="fas fa-chart-bar"></i> Analyze Results
                            </button>
                            <button onclick="clearPredictions()" class="secondary">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Prediction Model Details</h2>
                        <div id="model-details">
                            <p>Select a prediction method to see details</p>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="card">
                        <h2>Predicted Numbers</h2>
                        <div id="prediction-results">
                            <p>Generate predictions to see results</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Prediction Analysis</h2>
                        <div id="prediction-analysis">
                            <p>Generate predictions to see analysis</p>
                        </div>
                        <canvas id="prediction-chart" class="simulation-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>About Lotto Pro</h2>
            <div class="grid">
                <div>
                    <h3>How It Works</h3>
                    <p>Lotto Pro uses advanced artificial intelligence and statistical analysis to help you generate and analyze lottery numbers. Our system combines multiple predictive models to identify patterns and trends in lottery draws.</p>
                    
                    <h3>Odds Information</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Game</th>
                                <th>Main Numbers</th>
                                <th>Bonus Numbers</th>
                                <th>Odds of Jackpot</th>
                                <th>Expected Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Powerball</td>
                                <td>5/69</td>
                                <td>1/26</td>
                                <td>1 in 292,201,338</td>
                                <td>-$0.80</td>
                            </tr>
                            <tr>
                                <td>Mega Millions</td>
                                <td>5/70</td>
                                <td>1/25</td>
                                <td>1 in 302,575,350</td>
                                <td>-$0.85</td>
                            </tr>
                            <tr>
                                <td>EuroMillions</td>
                                <td>5/50</td>
                                <td>2/12</td>
                                <td>1 in 139,838,160</td>
                                <td>-$0.50</td>
                            </tr>
                            <tr>
                                <td>Lotto 6/49</td>
                                <td>6/49</td>
                                <td>None</td>
                                <td>1 in 13,983,816</td>
                                <td>-$0.55</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div>
                    <h3>AI-Powered Strategies</h3>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Markov Chain Model:</strong> Predicts future numbers based on transition probabilities from historical data</li>
                        <li><strong>Neural Network:</strong> Deep learning model trained on past draws to identify complex patterns</li>
                        <li><strong>Regression Analysis:</strong> Statistical model that identifies relationships between numbers</li>
                        <li><strong>Frequency Analysis:</strong> Prioritizes numbers based on their historical appearance rates</li>
                        <li><strong>Combined AI Model:</strong> Ensemble approach that weights predictions from multiple models</li>
                    </ul>
                    
                    <h3>Remember</h3>
                    <p>Lotteries are games of chance. While our system can identify patterns and improve your number selection strategy, no system can guarantee a win. Always play responsibly and never spend more than you can afford to lose.</p>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        // Enhanced Global State
        let appState = {
            currentStrategy: 'random',
            historicalData: {},
            hotColdData: {},
            charts: {},
            currentGame: 'powerball',
            simulationRunning: false,
            simulationWorker: null,
            savedTickets: JSON.parse(localStorage.getItem('savedTickets')) || {},
            savedStrategies: JSON.parse(localStorage.getItem('savedStrategies')) || {},
            predictionModels: {
                markov: {
                    name: "Markov Chain Model",
                    description: "Predicts future numbers based on transition probabilities between numbers in historical draws. This model analyzes sequences and patterns in how numbers follow each other.",
                    accuracy: "72% historical match rate"
                },
                neural: {
                    name: "Neural Network",
                    description: "Deep learning model trained on past lottery draws. Can identify complex non-linear patterns that traditional statistical methods might miss.",
                    accuracy: "68% historical match rate"
                },
                regression: {
                    name: "Regression Analysis",
                    description: "Statistical model that identifies relationships between numbers and their likelihood of appearing together based on historical data.",
                    accuracy: "65% historical match rate"
                },
                frequency: {
                    name: "Frequency Analysis",
                    description: "Prioritizes numbers based on their historical appearance rates, with adjustments for recent trends and overdue numbers.",
                    accuracy: "70% historical match rate"
                },
                combined: {
                    name: "Combined AI Model",
                    description: "Ensemble approach that weights predictions from multiple models (Markov, Neural, Regression, Frequency) to produce the most balanced predictions.",
                    accuracy: "75% historical match rate"
                }
            }
        };

        // DOM Ready
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize theme
            initTheme();
            
            // Set up event listeners
            document.getElementById('game-type').addEventListener('change', updateGameParams);
            document.getElementById('generation-method').addEventListener('change', updateMethodParams);
            document.getElementById('analyzer-game-type').addEventListener('change', updateAnalyzer);
            document.getElementById('history-game-type').addEventListener('change', clearHistoryTable);
            document.getElementById('simulator-game-type').addEventListener('change', updateSimulator);
            document.getElementById('predictor-game-type').addEventListener('change', updatePredictor);
            document.getElementById('predictor-method').addEventListener('change', updateModelDetails);
            
            // Strategy selectors
            document.querySelectorAll('.strategy-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.strategy-option').forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    appState.currentStrategy = this.getAttribute('data-strategy');
                    updateStrategyParams();
                    updateStrategyExplanation();
                });
            });
            
            // Initialize displays
            updateGameParams();
            updateMethodParams();
            updateAnalyzer();
            updateStrategyExplanation();
            updateSimulator();
            updatePredictor();
            updateModelDetails();
            
            // Set up tab switching
            setupTabs();
            
            // Load sample data
            loadSampleData();
            
            // Update probability calculator
            updateProbabilityCalculator();
        });

        // Initialize the application
        function initTheme() {
            const themeToggle = document.getElementById('themeToggle');
            const currentTheme = localStorage.getItem('theme') || 'light';
            
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            themeToggle.addEventListener('click', () => {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                // Update toggle icon
                const icon = themeToggle.querySelector('i');
                if (newTheme === 'dark') {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                }
            });
            
            // Set initial icon
            const icon = themeToggle.querySelector('i');
            if (currentTheme === 'dark') {
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
            }
        }
        
        // Tab functionality
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Show corresponding content
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Update charts when tab becomes visible
                    setTimeout(() => {
                        Object.values(appState.charts).forEach(chart => {
                            if (chart) chart.resize();
                        });
                    }, 300);
                });
            });
        }
        
        // Toast notification
        function showToast(message, type = 'success', icon = null) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show`;
            toast.style.backgroundColor = `var(--${type})`;
            
            // Set icon if provided
            if (icon) {
                toast.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
            }
            
            setTimeout(() => {
                toast.className = 'toast';
            }, 3500);
        }
        
        // Game parameters
        function updateGameParams() {
            const gameType = document.getElementById('game-type').value;
            const customParams = document.getElementById('custom-params');
            
            if (gameType === 'custom') {
                customParams.style.display = 'block';
            } else {
                customParams.style.display = 'none';
                
                // Set default values for known games
                switch(gameType) {
                    case 'powerball':
                        document.getElementById('main-numbers').value = 69;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 26;
                        document.getElementById('pick-bonus').value = 1;
                        break;
                    case 'megamillions':
                        document.getElementById('main-numbers').value = 70;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 25;
                        document.getElementById('pick-bonus').value = 1;
                        break;
                    case 'euromillions':
                        document.getElementById('main-numbers').value = 50;
                        document.getElementById('pick-numbers').value = 5;
                        document.getElementById('bonus-numbers').value = 12;
                        document.getElementById('pick-bonus').value = 2;
                        break;
                    case 'lotto649':
                        document.getElementById('main-numbers').value = 49;
                        document.getElementById('pick-numbers').value = 6;
                        document.getElementById('bonus-numbers').value = 0;
                        document.getElementById('pick-bonus').value = 0;
                        break;
                }
            }
            
            // Update current game
            appState.currentGame = gameType;
            
            // Update method params in case they depend on game type
            updateMethodParams();
            
            // Update probability calculator
            updateProbabilityCalculator();
        }
        
        // Method parameters
        function updateMethodParams() {
            const method = document.getElementById('generation-method').value;
            const paramsContainer = document.getElementById('method-params');
            
            let paramsHTML = '';
            
            switch(method) {
                case 'hot-cold':
                    paramsHTML = `
                        <label for="hot-cold-ratio">Hot to Cold Ratio:</label>
                        <select id="hot-cold-ratio">
                            <option value="balanced">Balanced (50/50)</option>
                            <option value="hot-heavy">Hot Heavy (70/30)</option>
                            <option value="cold-heavy">Cold Heavy (30/70)</option>
                        </select>
                        <p class="status info"><i class="fas fa-info-circle"></i> Hot/Cold data comes from historical analysis</p>
                    `;
                    break;
                    
                case 'wheel':
                    paramsHTML = `
                        <label for="wheel-type">Wheel System:</label>
                        <select id="wheel-type">
                            <option value="abbreviated">Abbreviated Wheel</option>
                            <option value="full">Full Wheel</option>
                            <option value="key-number">Key Number Wheel</option>
                        </select>
                        
                        <div id="wheel-key-number-container" style="display: none;">
                            <label for="wheel-key-number">Key Number:</label>
                            <input type="number" id="wheel-key-number" min="1" value="1">
                        </div>
                        
                        <label for="wheel-numbers">Numbers to Wheel (comma separated):</label>
                        <input type="text" id="wheel-numbers" placeholder="e.g. 1, 2, 3, 4, 5, 6, 7, 8">
                        
                        <p class="status info"><i class="fas fa-info-circle"></i> Wheel systems cover more combinations with fewer tickets</p>
                    `;
                    
                    // Show key number field if key number wheel is selected
                    document.getElementById('wheel-type').addEventListener('change', function() {
                        document.getElementById('wheel-key-number-container').style.display = 
                            this.value === 'key-number' ? 'block' : 'none';
                    });
                    break;
                    
                case 'ai':
                    paramsHTML = `
                        <label for="ai-model">AI Model:</label>
                        <select id="ai-model">
                            <option value="markov">Markov Chain</option>
                            <option value="neural">Neural Network</option>
                            <option value="combined">Combined Model</option>
                        </select>
                        
                        <label for="ai-confidence">Minimum Confidence:</label>
                        <input type="range" id="ai-confidence" min="50" max="95" value="75" step="5">
                        <span id="ai-confidence-value">75%</span>
                        
                        <p class="status info"><i class="fas fa-info-circle"></i> AI models analyze historical patterns to predict likely numbers</p>
                    `;
                    
                    // Update confidence value display
                    document.getElementById('ai-confidence').addEventListener('input', function() {
                        document.getElementById('ai-confidence-value').textContent = this.value + '%';
                    });
                    break;
                    
                default:
                    paramsHTML = '<p>No additional parameters needed for this method</p>';
            }
            
            paramsContainer.innerHTML = paramsHTML;
        }
        
        // Generate random seed
        function generateSeed() {
            const seed = Math.floor(Math.random() * 1000000000);
            document.getElementById('random-seed').value = seed;
            showToast('Random seed generated', 'success', 'seedling');
        }
        
        // Number generation
        function generateNumbers() {
            const gameType = document.getElementById('game-type').value;
            let mainPool, pickCount, bonusPool, bonusCount;
            
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('main-numbers').value) || 69;
                pickCount = parseInt(document.getElementById('pick-numbers').value) || 5;
                bonusPool = parseInt(document.getElementById('bonus-numbers').value) || 26;
                bonusCount = parseInt(document.getElementById('pick-bonus').value) || 1;
            } else {
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        pickCount = 5;
                        bonusPool = 25;
                        bonusCount = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        pickCount = 5;
                        bonusPool = 12;
                        bonusCount = 2;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        pickCount = 6;
                        bonusPool = 0;
                        bonusCount = 0;
                        break;
                    default:
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                }
            }
            
            const drawCount = parseInt(document.getElementById('draw-count').value) || 5;
            const method = document.getElementById('generation-method').value;
            const seed = document.getElementById('random-seed').value.trim();
            
            // Set random seed if provided
            if (seed) {
                Math.seedrandom(seed);
            }
            
            // Generate numbers
            const results = [];
            
            try {
                if (method === 'wheel') {
                    // Handle wheel system separately
                    const wheelType = document.getElementById('wheel-type').value;
                    const wheelNumbersInput = document.getElementById('wheel-numbers').value.trim();
                    
                    if (!wheelNumbersInput) {
                        showToast('Please enter numbers to wheel', 'warning', 'exclamation-triangle');
                        return;
                    }
                    
                    const wheelNumbers = wheelNumbersInput.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                    
                    if (wheelNumbers.length < pickCount) {
                        showToast(`You need at least ${pickCount} numbers for a wheel`, 'warning', 'exclamation-triangle');
                        return;
                    }
                    
                    if (wheelType === 'key-number') {
                        const keyNumber = parseInt(document.getElementById('wheel-key-number').value);
                        if (!wheelNumbers.includes(keyNumber)) {
                            showToast('Key number must be in your wheel numbers', 'warning', 'exclamation-triangle');
                            return;
                        }
                        
                        results.push(...generateKeyNumberWheel(wheelNumbers, pickCount, keyNumber));
                    } else if (wheelType === 'abbreviated') {
                        results.push(...generateAbbreviatedWheel(wheelNumbers, pickCount));
                    } else {
                        results.push(...generateFullWheel(wheelNumbers, pickCount));
                    }
                    
                    // Limit to requested draw count
                    if (results.length > drawCount) {
                        results.length = drawCount;
                    }
                } else if (method === 'ai') {
                    // AI-powered number generation
                    const model = document.getElementById('ai-model').value;
                    const confidence = parseInt(document.getElementById('ai-confidence').value) / 100;
                    
                    for (let i = 0; i < drawCount; i++) {
                        let mainNumbers, bonusNumbers;
                        
                        // Generate main numbers based on AI model
                        switch(model) {
                            case 'markov':
                                mainNumbers = generateMarkovNumbers(mainPool, pickCount, confidence);
                                break;
                            case 'neural':
                                mainNumbers = generateNeuralNumbers(mainPool, pickCount, confidence);
                                break;
                            case 'combined':
                                mainNumbers = generateCombinedAINumbers(mainPool, pickCount, confidence);
                                break;
                            default:
                                mainNumbers = generateMarkovNumbers(mainPool, pickCount, confidence);
                        }
                        
                        // Generate bonus numbers (always standard random)
                        if (bonusCount > 0) {
                            bonusNumbers = generateStandardNumbers(bonusPool, bonusCount);
                        } else {
                            bonusNumbers = [];
                        }
                        
                        results.push({
                            main: mainNumbers,
                            bonus: bonusNumbers
                        });
                    }
                } else {
                    // Standard generation methods
                    for (let i = 0; i < drawCount; i++) {
                        let mainNumbers, bonusNumbers;
                        
                        // Generate main numbers based on method
                        switch(method) {
                            case 'standard':
                                mainNumbers = generateStandardNumbers(mainPool, pickCount);
                                break;
                            case 'shuffle':
                                mainNumbers = generateShuffledNumbers(mainPool, pickCount);
                                break;
                            case 'crypto':
                                mainNumbers = generateCryptoNumbers(mainPool, pickCount);
                                break;
                            case 'low-high':
                                mainNumbers = generateLowHighNumbers(mainPool, pickCount);
                                break;
                            case 'odd-even':
                                mainNumbers = generateOddEvenNumbers(mainPool, pickCount);
                                break;
                            case 'prime':
                                mainNumbers = generatePrimeNumbers(mainPool, pickCount);
                                break;
                            case 'fibonacci':
                                mainNumbers = generateFibonacciNumbers(mainPool, pickCount);
                                break;
                            case 'lucky':
                                mainNumbers = generateLuckyNumbers(mainPool, pickCount);
                                break;
                            case 'hot-cold':
                                const ratio = document.getElementById('hot-cold-ratio').value;
                                mainNumbers = generateHotColdNumbers(mainPool, pickCount, ratio);
                                break;
                            default:
                                mainNumbers = generateStandardNumbers(mainPool, pickCount);
                        }
                        
                        // Generate bonus numbers (always standard random)
                        if (bonusCount > 0) {
                            bonusNumbers = generateStandardNumbers(bonusPool, bonusCount);
                        } else {
                            bonusNumbers = [];
                        }
                        
                        results.push({
                            main: mainNumbers,
                            bonus: bonusNumbers
                        });
                    }
                }
                
                // Display results
                displayResults(results, gameType);
                
                // Update number coverage
                updateNumberCoverage(results, mainPool);
                
                // Perform frequency analysis
                performFrequencyAnalysis(results, mainPool, bonusPool);
                
                showToast('Numbers generated successfully', 'success', 'check-circle');
            } catch (error) {
                showToast('Error generating numbers: ' + error.message, 'danger', 'exclamation-triangle');
                console.error(error);
            }
            
            // Reset random number generator
            if (seed) {
                Math.seedrandom();
            }
        }
        
        // AI-powered number generators
        function generateMarkovNumbers(poolSize, count, confidence) {
            // Simplified Markov chain implementation
            // In a real app, this would use pre-computed transition probabilities from historical data
            const numbers = [];
            let current = Math.floor(Math.random() * poolSize) + 1;
            numbers.push(current);
            
            while (numbers.length < count) {
                // Simplified - in reality we'd use actual transition probabilities
                let next;
                if (Math.random() < confidence) {
                    // Try to follow a pattern (simplified for demo)
                    next = current + Math.floor(Math.random() * 10) + 1;
                    if (next > poolSize) next -= poolSize;
                } else {
                    // Random jump
                    next = Math.floor(Math.random() * poolSize) + 1;
                }
                
                if (!numbers.includes(next)) {
                    numbers.push(next);
                    current = next;
                }
            }
            
            return numbers.sort((a, b) => a - b);
        }
        
        function generateNeuralNumbers(poolSize, count, confidence) {
            // Simplified neural network implementation
            // In a real app, this would use a trained model
            const numbers = [];
            const hotNumbers = appState.hotColdData[appState.currentGame]?.hot || [];
            
            while (numbers.length < count) {
                let num;
                if (Math.random() < confidence) {
                    // Bias towards hot numbers
                    if (hotNumbers.length > 0 && Math.random() < 0.7) {
                        num = hotNumbers[Math.floor(Math.random() * hotNumbers.length)];
                    } else {
                        // Bias towards numbers in Fibonacci sequence
                        const fibs = getFibonacciUpTo(poolSize);
                        if (fibs.length > 0 && Math.random() < 0.5) {
                            num = fibs[Math.floor(Math.random() * fibs.length)];
                        } else {
                            num = Math.floor(Math.random() * poolSize) + 1;
                        }
                    }
                } else {
                    num = Math.floor(Math.random() * poolSize) + 1;
                }
                
                if (!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            return numbers.sort((a, b) => a - b);
        }
        
        function generateCombinedAINumbers(poolSize, count, confidence) {
            // Combine multiple approaches
            const markovNumbers = generateMarkovNumbers(poolSize, count, confidence);
            const neuralNumbers = generateNeuralNumbers(poolSize, count, confidence);
            
            // Take some from each approach
            const combined = [];
            const fromMarkov = Math.ceil(count * 0.5);
            
            for (let i = 0; i < fromMarkov && combined.length < count; i++) {
                if (!combined.includes(markovNumbers[i])) {
                    combined.push(markovNumbers[i]);
                }
            }
            
            for (let i = 0; i < count && combined.length < count; i++) {
                if (!combined.includes(neuralNumbers[i])) {
                    combined.push(neuralNumbers[i]);
                }
            }
            
            // Fill any remaining with random
            while (combined.length < count) {
                const num = Math.floor(Math.random() * poolSize) + 1;
                if (!combined.includes(num)) {
                    combined.push(num);
                }
            }
            
            return combined.sort((a, b) => a - b);
        }
        
        // Wheel system generators
        function generateFullWheel(numbers, pickCount) {
            // Generate all possible combinations (n choose k)
            const combinations = [];
            const n = numbers.length;
            
            // Recursive function to generate combinations
            function combine(start, combination) {
                if (combination.length === pickCount) {
                    combinations.push([...combination]);
                    return;
                }
                
                for (let i = start; i < n; i++) {
                    combination.push(numbers[i]);
                    combine(i + 1, combination);
                    combination.pop();
                }
            }
            
            combine(0, []);
            return combinations.map(comb => ({ main: comb.sort((a, b) => a - b), bonus: [] }));
        }
        
        function generateAbbreviatedWheel(numbers, pickCount) {
            // Generate a reduced set of combinations that covers all numbers
            const n = numbers.length;
            const tickets = [];
            
            // Simple rotation system for demonstration
            // In a real app, you'd use a proper covering design
            for (let i = 0; i < n; i++) {
                const ticket = [];
                for (let j = 0; j < pickCount; j++) {
                    ticket.push(numbers[(i + j) % n]);
                }
                tickets.push({ main: ticket.sort((a, b) => a - b), bonus: [] });
            }
            
            return tickets;
        }
        
        function generateKeyNumberWheel(numbers, pickCount, keyNumber) {
            // Generate combinations that all include the key number
            const otherNumbers = numbers.filter(n => n !== keyNumber);
            const combinations = [];
            const n = otherNumbers.length;
            const k = pickCount - 1; // since one spot is taken by key number
            
            // Recursive function to generate combinations
            function combine(start, combination) {
                if (combination.length === k) {
                    combinations.push([keyNumber, ...combination].sort((a, b) => a - b));
                    return;
                }
                
                for (let i = start; i < n; i++) {
                    combination.push(otherNumbers[i]);
                    combine(i + 1, combination);
                    combination.pop();
                }
            }
            
            combine(0, []);
            return combinations.map(comb => ({ main: comb, bonus: [] }));
        }
        
        // Number generation algorithms
        function generateStandardNumbers(poolSize, count) {
            const numbers = [];
            while (numbers.length < count) {
                const num = Math.floor(Math.random() * poolSize) + 1;
                if (!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            return numbers.sort((a, b) => a - b);
        }
        
        function generateShuffledNumbers(poolSize, count) {
            // Create array of all possible numbers
            const allNumbers = Array.from({length: poolSize}, (_, i) => i + 1);
            
            // Fisher-Yates shuffle algorithm
            for (let i = allNumbers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allNumbers[i], allNumbers[j]] = [allNumbers[j], allNumbers[i]];
            }
            
            // Return first 'count' numbers
            return allNumbers.slice(0, count).sort((a, b) => a - b);
        }
        
        async function generateCryptoNumbers(poolSize, count) {
            const numbers = [];
            const used = new Set();
            
            while (numbers.length < count) {
                const randomValues = new Uint32Array(1);
                crypto.getRandomValues(randomValues);
                const num = (randomValues[0] % poolSize) + 1;
                
                if (!used.has(num)) {
                    used.add(num);
                    numbers.push(num);
                }
            }
            
            return numbers.sort((a, b) => a - b);
        }
        
        function generateLowHighNumbers(poolSize, count) {
            const midPoint = Math.floor(poolSize / 2);
            const lowPool = Array.from({length: midPoint}, (_, i) => i + 1);
            const highPool = Array.from({length: poolSize - midPoint}, (_, i) => midPoint + i + 1);
            
            // Determine how many low and high numbers to pick (balanced)
            const lowCount = Math.ceil(count / 2);
            const highCount = count - lowCount;
            
            // Shuffle pools
            shuffleArray(lowPool);
            shuffleArray(highPool);
            
            // Select numbers
            const result = [
                ...lowPool.slice(0, lowCount),
                ...highPool.slice(0, highCount)
            ];
            
            return result.sort((a, b) => a - b);
        }
        
        function generateOddEvenNumbers(poolSize, count) {
            const oddNumbers = [];
            const evenNumbers = [];
            
            // Split into odd and even
            for (let i = 1; i <= poolSize; i++) {
                if (i % 2 === 0) {
                    evenNumbers.push(i);
                } else {
                    oddNumbers.push(i);
                }
            }
            
            // Determine how many odd and even numbers to pick (balanced)
            const oddCount = Math.ceil(count / 2);
            const evenCount = count - oddCount;
            
            // Shuffle pools
            shuffleArray(oddNumbers);
            shuffleArray(evenNumbers);
            
            // Select numbers
            const result = [
                ...oddNumbers.slice(0, oddCount),
                ...evenNumbers.slice(0, evenCount)
            ];
            
            return result.sort((a, b) => a - b);
        }
        
        function generatePrimeNumbers(poolSize, count) {
            const primes = getPrimesUpTo(poolSize);
            
            if (primes.length < count) {
                // Not enough primes, fill with random numbers
                const nonPrimes = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !primes.includes(n));
                
                shuffleArray(primes);
                shuffleArray(nonPrimes);
                
                const result = [
                    ...primes,
                    ...nonPrimes.slice(0, count - primes.length)
                ];
                
                return result.slice(0, count).sort((a, b) => a - b);
            } else {
                shuffleArray(primes);
                return primes.slice(0, count).sort((a, b) => a - b);
            }
        }
        
        function generateFibonacciNumbers(poolSize, count) {
            const fibs = getFibonacciUpTo(poolSize);
            
            if (fibs.length < count) {
                // Not enough Fibonacci numbers, fill with random
                const nonFibs = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !fibs.includes(n));
                
                shuffleArray(fibs);
                shuffleArray(nonFibs);
                
                const result = [
                    ...fibs,
                    ...nonFibs.slice(0, count - fibs.length)
                ];
                
                return result.slice(0, count).sort((a, b) => a - b);
            } else {
                shuffleArray(fibs);
                return fibs.slice(0, count).sort((a, b) => a - b);
            }
        }
        
        function generateLuckyNumbers(poolSize, count) {
            const luckyNumbers = getLuckyNumbers(poolSize);
            
            if (luckyNumbers.length < count) {
                // Not enough lucky numbers, fill with random
                const nonLucky = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !luckyNumbers.includes(n));
                
                shuffleArray(luckyNumbers);
                shuffleArray(nonLucky);
                
                const result = [
                    ...luckyNumbers,
                    ...nonLucky.slice(0, count - luckyNumbers.length)
                ];
                
                return result.slice(0, count).sort((a, b) => a - b);
            } else {
                shuffleArray(luckyNumbers);
                return luckyNumbers.slice(0, count).sort((a, b) => a - b);
            }
        }
        
        function generateHotColdNumbers(poolSize, count, ratio) {
            // Get hot and cold numbers for this game type
            const gameType = document.getElementById('game-type').value;
            const hotNumbers = appState.hotColdData[gameType]?.hot || [];
            const coldNumbers = appState.hotColdData[gameType]?.cold || [];
            
            // Filter to only include numbers in the current pool
            const filteredHot = hotNumbers.filter(n => n <= poolSize);
            const filteredCold = coldNumbers.filter(n => n <= poolSize);
            
            // Determine how many hot and cold numbers to pick based on ratio
            let hotCount, coldCount;
            
            switch(ratio) {
                case 'balanced':
                    hotCount = Math.ceil(count / 2);
                    coldCount = count - hotCount;
                    break;
                case 'hot-heavy':
                    hotCount = Math.ceil(count * 0.7);
                    coldCount = count - hotCount;
                    break;
                case 'cold-heavy':
                    hotCount = Math.floor(count * 0.3);
                    coldCount = count - hotCount;
                    break;
                default:
                    hotCount = Math.ceil(count / 2);
                    coldCount = count - hotCount;
            }
            
            // If we don't have enough hot or cold numbers, adjust the counts
            if (filteredHot.length < hotCount) {
                coldCount += (hotCount - filteredHot.length);
                hotCount = filteredHot.length;
            }
            
            if (filteredCold.length < coldCount) {
                hotCount += (coldCount - filteredCold.length);
                coldCount = filteredCold.length;
            }
            
            // Shuffle the hot and cold numbers
            shuffleArray(filteredHot);
            shuffleArray(filteredCold);
            
            // Select the numbers
            const result = [
                ...filteredHot.slice(0, hotCount),
                ...filteredCold.slice(0, coldCount)
            ];
            
            // If we still don't have enough numbers, fill with random
            if (result.length < count) {
                const remainingNumbers = Array.from({length: poolSize}, (_, i) => i + 1)
                    .filter(n => !result.includes(n));
                
                shuffleArray(remainingNumbers);
                result.push(...remainingNumbers.slice(0, count - result.length));
            }
            
            return result.sort((a, b) => a - b);
        }
        
        // Helper functions for number generation
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function getPrimesUpTo(max) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i <= Math.sqrt(max); i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            return sieve.map((isPrime, num) => isPrime ? num : 0).filter(num => num > 0);
        }
        
        function getFibonacciUpTo(max) {
            const fibs = [1, 2];
            let next = 3;
            
            while (next <= max) {
                fibs.push(next);
                next = fibs[fibs.length - 1] + fibs[fibs.length - 2];
            }
            
            return fibs;
        }
        
        function getLuckyNumbers(max) {
            // Lucky numbers sieve algorithm
            const numbers = Array.from({length: max}, (_, i) => i + 1);
            let index = 1;
            let step = 2;
            
            while (step <= numbers.length) {
                const newNumbers = [];
                for (let i = 0; i < numbers.length; i++) {
                    if ((i + 1) % step !== 0) {
                        newNumbers.push(numbers[i]);
                    }
                }
                numbers.length = 0;
                numbers.push(...newNumbers);
                index++;
                step = numbers[index];
            }
            
            return numbers;
        }

        // Display results
        function displayResults(results, gameType) {
            const container = document.getElementById('generated-results');
            container.innerHTML = '';
            
            if (results.length === 0) {
                container.innerHTML = '<p>No numbers generated</p>';
                return;
            }
            
            results.forEach((draw, index) => {
                const drawElement = document.createElement('div');
                drawElement.className = 'lotto-draw';
                drawElement.style.marginBottom = '20px';
                
                const drawTitle = document.createElement('h4');
                drawTitle.textContent = `Ticket ${index + 1}:`;
                drawTitle.style.marginBottom = '10px';
                drawElement.appendChild(drawTitle);
                
                const ballsContainer = document.createElement('div');
                ballsContainer.className = 'lotto-balls';
                
                // Main numbers
                draw.main.forEach(num => {
                    const ball = document.createElement('div');
                    ball.className = 'ball';
                    
                    // Add special classes for certain number types
                    const primes = getPrimesUpTo(gameType === 'powerball' ? 69 : gameType === 'megamillions' ? 70 : gameType === 'euromillions' ? 50 : 49);
                    const fibs = getFibonacciUpTo(gameType === 'powerball' ? 69 : gameType === 'megamillions' ? 70 : gameType === 'euromillions' ? 50 : 49);
                    const lucky = getLuckyNumbers(gameType === 'powerball' ? 69 : gameType === 'megamillions' ? 70 : gameType === 'euromillions' ? 50 : 49);
                    
                    if (primes.includes(num)) ball.classList.add('prime-number');
                    if (fibs.includes(num)) ball.classList.add('fibonacci-number');
                    if (lucky.includes(num)) ball.classList.add('lucky-number');
                    
                    ball.textContent = num;
                    ballsContainer.appendChild(ball);
                });
                
                // Bonus numbers
                if (draw.bonus.length > 0) {
                    const separator = document.createElement('span');
                    separator.textContent = ' + ';
                    separator.style.margin = '0 8px';
                    separator.style.fontWeight = 'bold';
                    ballsContainer.appendChild(separator);
                    
                    draw.bonus.forEach(num => {
                        const ball = document.createElement('div');
                        ball.className = 'ball ' + 
                            (gameType === 'powerball' ? 'powerball' : 
                             gameType === 'megamillions' ? 'megaball' : 
                             gameType === 'euromillions' ? 'eurostar' : 'ball');
                        ball.textContent = num;
                        ballsContainer.appendChild(ball);
                    });
                }
                
                drawElement.appendChild(ballsContainer);
                container.appendChild(drawElement);
            });
        }

        // Number coverage analysis
        function updateNumberCoverage(results, poolSize) {
            const coveredNumbers = new Set();
            
            results.forEach(draw => {
                draw.main.forEach(num => {
                    coveredNumbers.add(num);
                });
            });
            
            const coveragePercentage = Math.round((coveredNumbers.size / poolSize) * 100);
            
            // Update coverage meter
            document.getElementById('coverage-fill').style.width = `${coveragePercentage}%`;
            document.getElementById('coverage-percentage').textContent = 
                `${coveragePercentage}% of numbers covered (${coveredNumbers.size}/${poolSize})`;
            
            // Update number grid
            const coverageGrid = document.getElementById('number-coverage');
            coverageGrid.innerHTML = '';
            
            for (let i = 1; i <= poolSize; i++) {
                const numElement = document.createElement('span');
                numElement.textContent = i;
                if (coveredNumbers.has(i)) {
                    numElement.classList.add('covered');
                }
                coverageGrid.appendChild(numElement);
            }
        }
        
        // Frequency analysis
        function performFrequencyAnalysis(results, mainPool, bonusPool) {
            // Count frequency of main numbers
            const mainFreq = {};
            for (let i = 1; i <= mainPool; i++) {
                mainFreq[i] = 0;
            }
            
            // Count frequency of bonus numbers
            const bonusFreq = {};
            if (bonusPool > 0) {
                for (let i = 1; i <= bonusPool; i++) {
                    bonusFreq[i] = 0;
                }
            }
            
            // Count occurrences
            results.forEach(draw => {
                draw.main.forEach(num => {
                    mainFreq[num]++;
                });
                
                draw.bonus.forEach(num => {
                    bonusFreq[num]++;
                });
            });
            
            // Convert to arrays for charting
            const mainNumbers = Object.keys(mainFreq).map(Number);
            const mainCounts = Object.values(mainFreq);
            
            // Create frequency chart
            const ctx = document.getElementById('frequency-chart').getContext('2d');
            
            if (appState.charts.frequency) {
                appState.charts.frequency.destroy();
            }
            
            appState.charts.frequency = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: mainNumbers,
                    datasets: [{
                        label: 'Number Frequency',
                        data: mainCounts,
                        backgroundColor: mainNumbers.map(n => 
                            `hsl(${(n / mainPool) * 360}, 70%, 60%)`),
                        borderColor: mainNumbers.map(n => 
                            `hsl(${(n / mainPool) * 360}, 70%, 40%)`),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Numbers'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Drawn ${context.raw} time(s)`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Display frequency table
            let frequencyHTML = '<h4>Main Numbers Frequency</h4>';
            
            // Create table with top and bottom numbers
            const sortedFreq = Object.entries(mainFreq)
                .map(([num, count]) => ({ num: parseInt(num), count }))
                .sort((a, b) => b.count - a.count);
            
            const topNumbers = sortedFreq.slice(0, 10);
            const bottomNumbers = sortedFreq.slice(-10).reverse();
            
            frequencyHTML += '<div class="grid"><div>';
            frequencyHTML += '<h5>Most Frequent (Hot)</h5><div class="lotto-balls">';
            topNumbers.forEach(item => {
                frequencyHTML += `<div class="ball hot-number" title="Drawn ${item.count} times">${item.num}</div>`;
            });
            frequencyHTML += '</div></div><div><h5>Least Frequent (Cold)</h5><div class="lotto-balls">';
            bottomNumbers.forEach(item => {
                frequencyHTML += `<div class="ball cold-number" title="Drawn ${item.count} times">${item.num}</div>`;
            });
            frequencyHTML += '</div></div></div>';
            
            // Add bonus numbers frequency if applicable
            if (bonusPool > 0) {
                const sortedBonusFreq = Object.entries(bonusFreq)
                    .map(([num, count]) => ({ num: parseInt(num), count }))
                    .sort((a, b) => b.count - a.count);
                
                const topBonus = sortedBonusFreq.slice(0, 5);
                const bottomBonus = sortedBonusFreq.slice(-5).reverse();
                
                frequencyHTML += '<h4>Bonus Numbers Frequency</h4>';
                frequencyHTML += '<div class="grid"><div>';
                frequencyHTML += '<h5>Most Frequent</h5><div class="lotto-balls">';
                topBonus.forEach(item => {
                    frequencyHTML += `<div class="ball" title="Drawn ${item.count} times">${item.num}</div>`;
                });
                frequencyHTML += '</div></div><div><h5>Least Frequent</h5><div class="lotto-balls">';
                bottomBonus.forEach(item => {
                    frequencyHTML += `<div class="ball" title="Drawn ${item.count} times">${item.num}</div>`;
                });
                frequencyHTML += '</div></div></div>';
            }
            
            document.getElementById('frequency-content').innerHTML = frequencyHTML;
        }

        // Quick pick function
        function quickPick() {
            // Set random method and generate immediately
            document.getElementById('generation-method').value = 'standard';
            updateMethodParams();
            generateNumbers();
        }

        // Clear generation
        function clearGeneration() {
            document.getElementById('generated-results').innerHTML = '';
            document.getElementById('frequency-content').innerHTML = '<p>Generate some numbers to see frequency analysis</p>';
            document.getElementById('number-coverage').innerHTML = '';
            document.getElementById('coverage-fill').style.width = '0%';
            document.getElementById('coverage-percentage').textContent = '0% of numbers covered';
            
            if (appState.charts.frequency) {
                appState.charts.frequency.destroy();
                appState.charts.frequency = null;
            }
        }

        // Export functions
        function exportNumbers(format) {
            const results = document.getElementById('generated-results').innerText;
            if (!results.trim()) {
                showToast('No numbers to export', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('game-type').value;
            const filename = `lotto_numbers_${gameType}_${new Date().toISOString().slice(0,10)}`;
            
            if (format === 'csv') {
                exportToCSV(results, filename + '.csv');
            } else if (format === 'json') {
                // Get the actual result data
                const draws = [];
                const drawElements = document.querySelectorAll('.lotto-draw');
                
                drawElements.forEach(draw => {
                    const numbers = Array.from(draw.querySelectorAll('.ball:not(.powerball):not(.megaball):not(.eurostar)'))
                        .map(ball => parseInt(ball.textContent));
                    const bonus = Array.from(draw.querySelectorAll('.ball.powerball, .ball.megaball, .ball.eurostar'))
                        .map(ball => parseInt(ball.textContent));
                    
                    draws.push({
                        main: numbers,
                        bonus: bonus
                    });
                });
                
                exportToJSON(draws, filename + '.json');
            } else {
                exportToFile(results, filename + '.txt');
            }
        }

        function copyNumbers() {
            const results = document.getElementById('generated-results').innerText;
            if (!results.trim()) {
                showToast('No numbers to copy', 'warning', 'exclamation-triangle');
                return;
            }
            
            navigator.clipboard.writeText(results).then(() => {
                showToast('Numbers copied to clipboard', 'success', 'copy');
            }).catch(err => {
                showToast('Failed to copy: ' + err, 'danger', 'exclamation-triangle');
            });
        }
        
        function printNumbers() {
            const results = document.getElementById('generated-results').cloneNode(true);
            const printContainer = document.createElement('div');
            printContainer.className = 'printable';
            
            const title = document.createElement('h2');
            title.textContent = 'Generated Lottery Numbers';
            printContainer.appendChild(title);
            
            const gameType = document.getElementById('game-type');
            const gameName = gameType.options[gameType.selectedIndex].text;
            const subtitle = document.createElement('h3');
            subtitle.textContent = `Game: ${gameName}`;
            printContainer.appendChild(subtitle);
            
            const date = document.createElement('p');
            date.textContent = `Generated on: ${new Date().toLocaleString()}`;
            printContainer.appendChild(date);
            
            printContainer.appendChild(results);
            
            const oldContainer = document.body.querySelector('.printable');
            if (oldContainer) {
                document.body.removeChild(oldContainer);
            }
            
            document.body.appendChild(printContainer);
            window.print();
        }
        
        // Save and load tickets
        function saveTickets() {
            const results = document.getElementById('generated-results').innerText;
            if (!results.trim()) {
                showToast('No numbers to save', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('game-type').value;
            const ticketName = prompt('Enter a name for these tickets:', `My ${gameType} Tickets`);
            
            if (ticketName) {
                // Get the actual ticket data
                const draws = [];
                const drawElements = document.querySelectorAll('.lotto-draw');
                
                drawElements.forEach(draw => {
                    const numbers = Array.from(draw.querySelectorAll('.ball:not(.powerball):not(.megaball):not(.eurostar)'))
                        .map(ball => parseInt(ball.textContent));
                    const bonus = Array.from(draw.querySelectorAll('.ball.powerball, .ball.megaball, .ball.eurostar'))
                        .map(ball => parseInt(ball.textContent));
                    
                    draws.push({
                        main: numbers,
                        bonus: bonus
                    });
                });
                
                // Save to local storage
                if (!appState.savedTickets[gameType]) {
                    appState.savedTickets[gameType] = {};
                }
                
                appState.savedTickets[gameType][ticketName] = {
                    date: new Date().toISOString(),
                    draws: draws
                };
                
                localStorage.setItem('savedTickets', JSON.stringify(appState.savedTickets));
                showToast('Tickets saved successfully', 'success', 'save');
            }
        }
        
        function loadSavedTickets() {
            const gameType = document.getElementById('analyzer-game-type').value;
            const savedTickets = appState.savedTickets[gameType];
            
            if (!savedTickets || Object.keys(savedTickets).length === 0) {
                showToast('No saved tickets found for this game', 'warning', 'exclamation-triangle');
                return;
            }
            
            const ticketNames = Object.keys(savedTickets);
            const ticketName = prompt(`Select tickets to load:\n${ticketNames.join('\n')}`);
            
            if (ticketName && savedTickets[ticketName]) {
                const ticketData = savedTickets[ticketName];
                const numbersList = ticketData.draws.map(draw => draw.main.join(', ')).join('\n');
                document.getElementById('analyzer-numbers').value = numbersList;
                showToast(`Loaded "${ticketName}" tickets`, 'success', 'folder-open');
            }
        }
        
        // Utility functions
        function exportToFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast(`Exported to ${filename}`, 'success', 'file-export');
        }

        function exportToCSV(content, filename) {
            // Convert to CSV format
            const csvContent = content.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .map(line => `"${line.replace(/\s+/g, '", "')}"`)
                .join('\n');
            
            exportToFile(csvContent, filename);
        }
        
        function exportToJSON(content, filename) {
            const jsonContent = JSON.stringify(content, null, 2);
            exportToFile(jsonContent, filename);
        }
        
        // Analyzer functions
        function updateAnalyzer() {
            const gameType = document.getElementById('analyzer-game-type').value;
            const matrix = document.getElementById('analyzer-number-matrix');
            matrix.innerHTML = '';
            
            let poolSize = 69; // Default to Powerball
            
            switch(gameType) {
                case 'powerball':
                    poolSize = 69;
                    break;
                case 'megamillions':
                    poolSize = 70;
                    break;
                case 'euromillions':
                    poolSize = 50;
                    break;
                case 'lotto649':
                    poolSize = 49;
                    break;
            }
            
            // Create number matrix
            for (let i = 1; i <= poolSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'number-cell';
                cell.textContent = i;
                cell.addEventListener('click', function() {
                    this.classList.toggle('selected');
                    updateNumberInput();
                });
                matrix.appendChild(cell);
            }
        }
        
        function updateNumberInput() {
            const selected = document.querySelectorAll('#analyzer-number-matrix .number-cell.selected');
            const numbers = Array.from(selected).map(cell => cell.textContent).join(', ');
            document.getElementById('analyzer-numbers').value = numbers;
        }
        
        function analyzeNumbers() {
            const numbersText = document.getElementById('analyzer-numbers').value.trim();
            if (!numbersText) {
                showToast('Please enter numbers to analyze', 'warning', 'exclamation-triangle');
                return;
            }
            
            const numbers = numbersText.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
            if (numbers.length === 0) {
                showToast('No valid numbers entered', 'warning', 'exclamation-triangle');
                return;
            }
            
            const gameType = document.getElementById('analyzer-game-type').value;
            let mainPool, pickCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    break;
                default:
                    mainPool = 69;
                    pickCount = 5;
            }
            
            // Validate number count
            if (numbers.length !== pickCount) {
                showToast(`This game requires exactly ${pickCount} numbers`, 'warning', 'exclamation-triangle');
                return;
            }
            
            // Validate number range
            const outOfRange = numbers.filter(n => n < 1 || n > mainPool);
            if (outOfRange.length > 0) {
                showToast(`Numbers must be between 1 and ${mainPool}`, 'warning', 'exclamation-triangle');
                return;
            }
            
            // Check for duplicates
            const uniqueNumbers = [...new Set(numbers)];
            if (uniqueNumbers.length !== numbers.length) {
                showToast('Duplicate numbers detected', 'warning', 'exclamation-triangle');
                return;
            }
            
            // Sort the numbers
            const sortedNumbers = [...numbers].sort((a, b) => a - b);
            
            // Perform analysis
            const sum = numbers.reduce((a, b) => a + b, 0);
            const average = sum / numbers.length;
            const range = Math.max(...numbers) - Math.min(...numbers);
            
            // Count odd/even
            const oddCount = numbers.filter(n => n % 2 !== 0).length;
            const evenCount = numbers.length - oddCount;
            
            // Check for primes
            const primes = getPrimesUpTo(mainPool);
            const primeCount = numbers.filter(n => primes.includes(n)).length;
            
            // Check for Fibonacci numbers
            const fibs = getFibonacciUpTo(mainPool);
            const fibCount = numbers.filter(n => fibs.includes(n)).length;
            
            // Check for lucky numbers
            const luckyNumbers = getLuckyNumbers(mainPool);
            const luckyCount = numbers.filter(n => luckyNumbers.includes(n)).length;
            
            // Calculate low/high distribution (low = bottom half)
            const midPoint = Math.floor(mainPool / 2);
            const lowCount = numbers.filter(n => n <= midPoint).length;
            const highCount = numbers.length - lowCount;
            
            // Calculate consecutive numbers
            let consecutiveCount = 0;
            for (let i = 1; i < sortedNumbers.length; i++) {
                if (sortedNumbers[i] === sortedNumbers[i-1] + 1) {
                    consecutiveCount++;
                }
            }
            
            // Calculate number spacing
            const spacings = [];
            for (let i = 1; i < sortedNumbers.length; i++) {
                spacings.push(sortedNumbers[i] - sortedNumbers[i-1]);
            }
            const avgSpacing = spacings.reduce((a, b) => a + b, 0) / spacings.length;
            
            // Calculate sum groups (low, medium, high)
            const avgSum = pickCount * (mainPool + 1) / 2; // Average sum for n numbers
            const sumGroup = sum < avgSum * 0.9 ? 'Low' : 
                            sum > avgSum * 1.1 ? 'High' : 'Medium';
            
            // Calculate last digits
            const lastDigits = numbers.map(n => n % 10);
            const lastDigitCounts = {};
            lastDigits.forEach(d => {
                lastDigitCounts[d] = (lastDigitCounts[d] || 0) + 1;
            });
            
            // Display results
            let resultsHTML = `
                <div class="lotto-balls">
                    ${numbers.map(n => {
                        let ballClass = 'ball';
                        if (primes.includes(n)) ballClass += ' prime-number';
                        if (fibs.includes(n)) ballClass += ' fibonacci-number';
                        if (luckyNumbers.includes(n)) ballClass += ' lucky-number';
                        return `<div class="${ballClass}">${n}</div>`;
                    }).join('')}
                </div>
            `;
            
            document.getElementById('analyzer-results').innerHTML = resultsHTML;
            
            // Update stats cards
            const statsHTML = `
                <div class="stat-card">
                    <h3>Sum</h3>
                    <p>${sum}</p>
                </div>
                <div class="stat-card">
                    <h3>Average</h3>
                    <p>${average.toFixed(1)}</p>
                </div>
                <div class="stat-card">
                    <h3>Range</h3>
                    <p>${range}</p>
                </div>
                <div class="stat-card">
                    <h3>Odd/Even</h3>
                    <p>${oddCount}/${evenCount}</p>
                </div>
                <div class="stat-card">
                    <h3>Low/High</h3>
                    <p>${lowCount}/${highCount}</p>
                </div>
                <div class="stat-card">
                    <h3>Consecutive</h3>
                    <p>${consecutiveCount}</p>
                </div>
                <div class="stat-card">
                    <h3>Prime Numbers</h3>
                    <p>${primeCount}</p>
                </div>
                <div class="stat-card">
                    <h3>Sum Group</h3>
                    <p>${sumGroup}</p>
                </div>
            `;
            
            document.getElementById('analyzer-stats').innerHTML = statsHTML;
            
            // Update sum analysis
            const sumAnalysisHTML = `
                <p>The sum of your numbers is <strong>${sum}</strong>.</p>
                <p>Historical average sum for this game: <strong>${Math.round(avgSum)}</strong></p>
                <div class="performance-bar">
                    <div class="performance-bar-fill" style="width: ${Math.min(100, (sum / (pickCount * mainPool)) * 100)}%"></div>
                </div>
                <p>Your sum is in the <strong>${sumGroup}</strong> range.</p>
            `;
            document.getElementById('sum-analysis').innerHTML = sumAnalysisHTML;
            
            // Update gap analysis
            const gapAnalysisHTML = `
                <p>Average gap between numbers: <strong>${avgSpacing.toFixed(1)}</strong></p>
                <p>Number gaps: ${spacings.join(', ')}</p>
                <div class="performance-bar">
                    <div class="performance-bar-fill" style="width: ${(avgSpacing / (mainPool / pickCount)) * 100}%"></div>
                </div>
                <p>${consecutiveCount > 0 ? 'Contains ' + consecutiveCount + ' consecutive numbers' : 'No consecutive numbers'}</p>
            `;
            document.getElementById('gap-analysis').innerHTML = gapAnalysisHTML;
            
            // Create analyzer chart
            const ctx = document.getElementById('analyzer-chart').getContext('2d');
            
            if (appState.charts.analyzer) {
                appState.charts.analyzer.destroy();
            }
            
            // Create radar chart showing different metrics
            appState.charts.analyzer = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Sum', 'Range', 'Odd/Even', 'Low/High', 'Consecutive', 'Primes', 'Spacing'],
                    datasets: [{
                        label: 'Your Numbers',
                        data: [
                            normalize(sum, 0, pickCount * mainPool, 0, 100),
                            normalize(range, 0, mainPool - 1, 0, 100),
                            normalize(oddCount, 0, pickCount, 0, 100),
                            normalize(lowCount, 0, pickCount, 0, 100),
                            normalize(consecutiveCount, 0, pickCount - 1, 0, 100),
                            normalize(primeCount, 0, pickCount, 0, 100),
                            normalize(avgSpacing, 1, mainPool / pickCount, 0, 100)
                        ],
                        backgroundColor: 'rgba(74, 107, 255, 0.2)',
                        borderColor: 'rgba(74, 107, 255, 1)',
                        borderWidth: 2,
                        pointBackgroundColor: 'rgba(74, 107, 255, 1)'
                    }, {
                        label: 'Ideal Range',
                        data: [
                            normalize(avgSum, 0, pickCount * mainPool, 0, 100),
                            normalize(mainPool / 3, 0, mainPool - 1, 0, 100),
                            normalize(pickCount / 2, 0, pickCount, 0, 100),
                            normalize(pickCount / 2, 0, pickCount, 0, 100),
                            normalize(1, 0, pickCount - 1, 0, 100),
                            normalize(1, 0, pickCount, 0, 100),
                            normalize(mainPool / (pickCount * 2), 1, mainPool / pickCount, 0, 100)
                        ],
                        backgroundColor: 'rgba(45, 212, 191, 0.2)',
                        borderColor: 'rgba(45, 212, 191, 1)',
                        borderWidth: 1,
                        pointBackgroundColor: 'rgba(45, 212, 191, 1)',
                        borderDash: [5, 5]
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    }
                }
            });
            
            // Update number wheel
            updateNumberWheel(numbers, mainPool, 'analyzer-wheel');
            
            // Highlight selected numbers in matrix
            document.querySelectorAll('#analyzer-number-matrix .number-cell').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            numbers.forEach(num => {
                const cell = document.querySelector(`#analyzer-number-matrix .number-cell:nth-child(${num})`);
                if (cell) {
                    cell.classList.add('selected');
                }
            });
            
            // Update pattern recognition
            const patternHTML = `
                <div class="pattern-grid">
                    <div class="pattern-card">
                        <h4>Number Types</h4>
                        <p>${primeCount} prime numbers</p>
                        <p>${fibCount} Fibonacci numbers</p>
                        <p>${luckyCount} lucky numbers</p>
                    </div>
                    <div class="pattern-card">
                        <h4>Distribution</h4>
                        <p>${lowCount} low numbers</p>
                        <p>${highCount} high numbers</p>
                        <p>${oddCount} odd numbers</p>
                        <p>${evenCount} even numbers</p>
                    </div>
                    <div class="pattern-card">
                        <h4>Last Digits</h4>
                        ${Object.entries(lastDigitCounts).map(([digit, count]) => 
                            `<p>${count} numbers ending with ${digit}</p>`
                        ).join('')}
                    </div>
                </div>
            `;
            document.getElementById('pattern-recognition').innerHTML = patternHTML;
            
            // Create pattern visualization
            visualizePatterns(numbers, mainPool);
            
            showToast('Numbers analyzed successfully', 'success', 'check-circle');
            
            // Helper function to normalize values for radar chart
            function normalize(value, min, max, newMin, newMax) {
                return ((value - min) / (max - min)) * (newMax - newMin) + newMin;
            }
        }
        
        function visualizePatterns(numbers, poolSize) {
            const container = document.getElementById('pattern-visualization');
            container.innerHTML = '';
            
            // Create a canvas for visualization
            const canvas = document.createElement('canvas');
            canvas.width = container.offsetWidth;
            canvas.height = 300;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            // Draw number distribution
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = var(--primary);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw numbers
            numbers.forEach((num, index) => {
                const angle = (num / poolSize) * Math.PI * 2;
                const x = centerX + Math.sin(angle) * radius;
                const y = centerY - Math.cos(angle) * radius;
                
                // Draw line to next number
                if (index < numbers.length - 1) {
                    const nextNum = numbers[index + 1];
                    const nextAngle = (nextNum / poolSize) * Math.PI * 2;
                    const nextX = centerX + Math.sin(nextAngle) * radius;
                    const nextY = centerY - Math.cos(nextAngle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(nextX, nextY);
                    ctx.strokeStyle = `hsla(${(num / poolSize) * 360}, 70%, 50%, 0.7)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Draw number
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${(num / poolSize) * 360}, 70%, 60%)`;
                ctx.fill();
                ctx.strokeStyle = `hsl(${(num / poolSize) * 360}, 70%, 40%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw number text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, x, y);
            });
        }
        
        function updateNumberWheel(numbers, poolSize, elementId = 'analyzer-wheel') {
            const wheel = document.getElementById(elementId);
            wheel.innerHTML = '';
            
            const centerX = wheel.offsetWidth / 2;
            const centerY = wheel.offsetHeight / 2;
            const radius = Math.min(wheel.offsetWidth, wheel.offsetHeight) * 0.4;
            
            numbers.forEach((num, index) => {
                const angle = (num / poolSize) * 2 * Math.PI;
                const x = centerX + radius * Math.sin(angle);
                const y = centerY - radius * Math.cos(angle);
                
                const numberElement = document.createElement('div');
                numberElement.className = 'wheel-number';
                numberElement.textContent = num;
                numberElement.style.left = `${x}px`;
                numberElement.style.top = `${y}px`;
                numberElement.style.transform = `rotate(${angle}rad)`;
                numberElement.style.backgroundColor = `hsl(${(num / poolSize) * 360}, 70%, 60%)`;
                
                wheel.appendChild(numberElement);
            });
        }
        
        function clearAnalyzer() {
            document.getElementById('analyzer-numbers').value = '';
            document.getElementById('analyzer-results').innerHTML = '<p>Enter numbers to analyze them</p>';
            document.getElementById('analyzer-stats').innerHTML = '';
            document.getElementById('analyzer-wheel').innerHTML = '';
            document.getElementById('sum-analysis').innerHTML = '<p>Analyze numbers to see sum statistics</p>';
            document.getElementById('gap-analysis').innerHTML = '<p>Analyze numbers to see gap statistics</p>';
            document.getElementById('pattern-recognition').innerHTML = '<p>Analyze numbers to detect patterns</p>';
            document.getElementById('pattern-visualization').innerHTML = '';
            
            document.querySelectorAll('#analyzer-number-matrix .number-cell').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            if (appState.charts.analyzer) {
                appState.charts.analyzer.destroy();
                appState.charts.analyzer = null;
            }
        }
        
        // History functions
        function loadHistoricalData() {
            const gameType = document.getElementById('history-game-type').value;
            const drawCount = parseInt(document.getElementById('history-draw-count').value) || 100;
            
            showToast(`Loading ${drawCount} historical draws for ${gameType}...`, 'info', 'sync-alt');
            
            // In a real app, this would fetch from an API
            // For demo purposes, we'll use our sample data
            setTimeout(() => {
                if (appState.historicalData[gameType]) {
                    displayHistoricalData(gameType, drawCount);
                    showToast(`Loaded ${Math.min(drawCount, appState.historicalData[gameType].length)} historical draws`, 'success', 'check-circle');
                } else {
                    showToast('No historical data available for this game', 'warning', 'exclamation-triangle');
                }
            }, 500);
        }
        
        function downloadHistoricalData() {
            const gameType = document.getElementById('history-game-type').value;
            const history = appState.historicalData[gameType];
            
            if (!history || history.length === 0) {
                showToast('No historical data to download', 'warning', 'exclamation-triangle');
                return;
            }
            
            // Convert to CSV
            let csvContent = "Draw Date,Numbers,Bonus Numbers,Jackpot\n";
            
            history.forEach(draw => {
                csvContent += `${draw.date},${draw.numbers.join(' ')},${draw.bonus?.join(' ') || ''},${draw.jackpot || ''}\n`;
            });
            
            // Create download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${gameType}_historical_data.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('Historical data downloaded', 'success', 'download');
        }
        
        function displayHistoricalData(gameType, drawCount) {
            const history = appState.historicalData[gameType] || [];
            const displayCount = Math.min(drawCount, history.length);
            
            // Display in table
            const tableBody = document.getElementById('history-table-body');
            tableBody.innerHTML = '';
            
            for (let i = 0; i < displayCount; i++) {
                const draw = history[i];
                const row = document.createElement('tr');
                
                const dateCell = document.createElement('td');
                dateCell.textContent = draw.date;
                row.appendChild(dateCell);
                
                const numbersCell = document.createElement('td');
                numbersCell.innerHTML = draw.numbers.map(n => 
                    `<div class="ball" style="display: inline-block; margin: 2px;">${n}</div>`
                ).join('');
                row.appendChild(numbersCell);
                
                const bonusCell = document.createElement('td');
                if (draw.bonus && draw.bonus.length > 0) {
                    bonusCell.innerHTML = draw.bonus.map(n => 
                        `<div class="ball ${gameType === 'powerball' ? 'powerball' : 
                          gameType === 'megamillions' ? 'megaball' : 
                          gameType === 'euromillions' ? 'eurostar' : 'ball'}" 
                          style="display: inline-block; margin: 2px;">${n}</div>`
                    ).join('');
                } else {
                    bonusCell.textContent = 'N/A';
                }
                row.appendChild(bonusCell);
                
                const jackpotCell = document.createElement('td');
                jackpotCell.textContent = draw.jackpot ? `$${draw.jackpot.toLocaleString()}` : 'N/A';
                row.appendChild(jackpotCell);
                
                tableBody.appendChild(row);
            }
            
            // Perform historical analysis
            performHistoricalAnalysis(gameType, displayCount);
        }
        
        function performHistoricalAnalysis(gameType, drawCount) {
            const history = appState.historicalData[gameType] || [];
            const displayCount = Math.min(drawCount, history.length);
            if (history.length === 0) return;
            
            let mainPool;
            switch(gameType) {
                case 'powerball': mainPool = 69; break;
                case 'megamillions': mainPool = 70; break;
                case 'euromillions': mainPool = 50; break;
                case 'lotto649': mainPool = 49; break;
                default: mainPool = 69;
            }
            
            // Count frequency of each number
            const frequency = {};
            for (let i = 1; i <= mainPool; i++) {
                frequency[i] = 0;
            }
            
            // Calculate average sum
            let sumTotal = 0;
            
            history.slice(0, displayCount).forEach(draw => {
                draw.numbers.forEach(num => {
                    frequency[num]++;
                });
                
                sumTotal += draw.numbers.reduce((a, b) => a + b, 0);
            });
            
            const avgSum = sumTotal / displayCount;
            
            // Convert to array and sort by frequency
            const frequencyArray = Object.entries(frequency).map(([num, count]) => ({
                number: parseInt(num),
                count,
                percentage: (count / displayCount) * 100
            }));
            
            frequencyArray.sort((a, b) => b.count - a.count);
            
            // Get hot (most frequent) and cold (least frequent) numbers
            const hotNumbers = frequencyArray.slice(0, 10).map(item => item.number);
            const coldNumbers = frequencyArray.slice(-10).map(item => item.number);
            
            // Store for hot/cold strategy
            appState.hotColdData[gameType] = {
                hot: hotNumbers,
                cold: coldNumbers,
                frequency: frequencyArray
            };
            
            // Display analysis
            let trendsHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Average Sum</h3>
                        <p>${avgSum.toFixed(1)}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Most Frequent</h3>
                        <p>${hotNumbers[0]} (${frequencyArray[0].count}x)</p>
                    </div>
                    <div class="stat-card">
                        <h3>Least Frequent</h3>
                        <p>${coldNumbers[0]} (${frequencyArray[frequencyArray.length-1].count}x)</p>
                    </div>
                </div>
            `;
            
            document.getElementById('history-trends').innerHTML = trendsHTML;
            
            // Display hot/cold numbers
            let hotColdHTML = '<h4>Most Frequent Numbers (Hot)</h4>';
            hotColdHTML += '<div class="lotto-balls">';
            
            hotNumbers.forEach(num => {
                const freq = frequencyArray.find(f => f.number === num);
                hotColdHTML += `<div class="ball hot-number" title="Drawn ${freq.count} times (${freq.percentage.toFixed(1)}%)">${num}</div>`;
            });
            
            hotColdHTML += '</div><h4>Least Frequent Numbers (Cold)</h4>';
            hotColdHTML += '<div class="lotto-balls">';
            
            coldNumbers.forEach(num => {
                const freq = frequencyArray.find(f => f.number === num);
                hotColdHTML += `<div class="ball cold-number" title="Drawn ${freq.count} times (${freq.percentage.toFixed(1)}%)">${num}</div>`;
            });
            
            hotColdHTML += '</div>';
            
            document.getElementById('hot-cold-numbers').innerHTML = hotColdHTML;
            
            // Create history chart
            const ctx = document.getElementById('history-chart').getContext('2d');
            
            if (appState.charts.history) {
                appState.charts.history.destroy();
            }
            
            // Prepare data for chart
            const labels = frequencyArray.map(item => item.number);
            const data = frequencyArray.map(item => item.count);
            const backgroundColors = frequencyArray.map(item => 
                hotNumbers.includes(item.number) ? 'rgba(239, 68, 68, 0.7)' :
                coldNumbers.includes(item.number) ? 'rgba(59, 130, 246, 0.7)' :
                'rgba(74, 107, 255, 0.7)'
            );
            
            appState.charts.history = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Frequency',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Numbers'
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 20
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const freq = frequencyArray.find(f => f.number === parseInt(context.label));
                                    return `Drawn ${context.raw} times (${freq.percentage.toFixed(1)}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Create hot/cold chart
            const hotColdCtx = document.getElementById('hot-cold-chart').getContext('2d');
            
            if (appState.charts.hotCold) {
                appState.charts.hotCold.destroy();
            }
            
            // Prepare data for hot/cold chart
            const hotColdLabels = ['Hot Numbers', 'Cold Numbers', 'Others'];
            const hotColdData = [
                hotNumbers.reduce((sum, num) => sum + frequency[num], 0),
                coldNumbers.reduce((sum, num) => sum + frequency[num], 0),
                displayCount * (gameType === 'lotto649' ? 6 : 5) - 
                    hotNumbers.reduce((sum, num) => sum + frequency[num], 0) - 
                    coldNumbers.reduce((sum, num) => sum + frequency[num], 0)
            ];
            
            appState.charts.hotCold = new Chart(hotColdCtx, {
                type: 'doughnut',
                data: {
                    labels: hotColdLabels,
                    datasets: [{
                        data: hotColdData,
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.7)',
                            'rgba(59, 130, 246, 0.7)',
                            'rgba(74, 107, 255, 0.7)'
                        ],
                        borderColor: [
                            'rgba(239, 68, 68, 1)',
                            'rgba(59, 130, 246, 1)',
                            'rgba(74, 107, 255, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((context.raw / total) * 100);
                                    return `${context.label}: ${context.raw} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function clearHistoryTable() {
            document.getElementById('history-table-body').innerHTML = '';
            document.getElementById('history-trends').innerHTML = '<p>Load historical data to see trends</p>';
            document.getElementById('hot-cold-numbers').innerHTML = '<p>Load historical data to see hot and cold numbers</p>';
            
            if (appState.charts.history) {
                appState.charts.history.destroy();
                appState.charts.history = null;
            }
            
            if (appState.charts.hotCold) {
                appState.charts.hotCold.destroy();
                appState.charts.hotCold = null;
            }
        }
        
        function clearHistory() {
            const gameType = document.getElementById('history-game-type').value;
            clearHistoryTable();
        }
        
        // Strategy functions
        function updateStrategyParams() {
            const paramsContainer = document.getElementById('strategy-params');
            
            let paramsHTML = '';
            
            switch(appState.currentStrategy) {
                case 'low-high':
                    paramsHTML = `
                        <label for="low-high-ratio">Low to High Ratio:</label>
                        <select id="low-high-ratio">
                            <option value="balanced">Balanced (50/50)</option>
                            <option value="low-heavy">Low Heavy (70/30)</option>
                            <option value="high-heavy">High Heavy (30/70)</option>
                        </select>
                    `;
                    break;
                    
                case 'odd-even':
                    paramsHTML = `
                        <label for="odd-even-ratio">Odd to Even Ratio:</label>
                        <select id="odd-even-ratio">
                            <option value="balanced">Balanced (50/50)</option>
                            <option value="odd-heavy">Odd Heavy (70/30)</option>
                            <option value="even-heavy">Even Heavy (30/70)</option>
                        </select>
                    `;
                    break;
                    
                case 'hot-cold':
                    paramsHTML = `
                        <label for="hot-cold-ratio">Hot to Cold Ratio:</label>
                        <select id="hot-cold-ratio">
                            <option value="balanced">Balanced (50/50)</option>
                            <option value="hot-heavy">Hot Heavy (70/30)</option>
                            <option value="cold-heavy">Cold Heavy (30/70)</option>
                        </select>
                        <p class="status info"><i class="fas fa-info-circle"></i> Hot/Cold data comes from historical analysis</p>
                    `;
                    break;
                    
                case 'birthday':
                    paramsHTML = `
                        <label for="birthday-numbers">Birthday Numbers (comma separated):</label>
                        <input type="text" id="birthday-numbers" placeholder="e.g. 7, 19, 21">
                        <p class="status info"><i class="fas fa-info-circle"></i> Enter numbers between 1 and 31 (days of the month)</p>
                    `;
                    break;
                    
                case 'ai':
                    paramsHTML = `
                        <label for="ai-confidence">Minimum Confidence:</label>
                        <input type="range" id="ai-confidence" min="50" max="95" value="75" step="5">
                        <span id="ai-confidence-value">75%</span>
                        
                        <label for="ai-model">AI Model:</label>
                        <select id="ai-model">
                            <option value="markov">Markov Chain</option>
                            <option value="neural">Neural Network</option>
                            <option value="combined">Combined Model</option>
                        </select>
                    `;
                    
                    // Update confidence value display
                    document.getElementById('ai-confidence').addEventListener('input', function() {
                        document.getElementById('ai-confidence-value').textContent = this.value + '%';
                    });
                    break;
                    
                default:
                    paramsHTML = '<p>No additional parameters needed for this strategy</p>';
            }
            
            paramsContainer.innerHTML = paramsHTML;
        }
        
        function updateStrategyExplanation() {
            const explanationContainer = document.getElementById('strategy-explanation');
            
            let explanation = '';
            
            switch(appState.currentStrategy) {
                case 'random':
                    explanation = `
                        <p>The <strong>Random</strong> strategy generates numbers completely at random with no particular pattern or strategy. This mimics how lottery numbers are actually drawn.</p>
                        <p>While this strategy doesn't follow any patterns, it ensures your numbers are as unpredictable as the actual lottery draw.</p>
                    `;
                    break;
                    
                case 'low-high':
                    explanation = `
                        <p>The <strong>Low-High</strong> strategy balances numbers between the lower and higher halves of the number range.</p>
                        <p>For example, in a 1-69 game, low numbers are 1-34 and high numbers are 35-69. This strategy ensures your numbers are well distributed across the entire range.</p>
                        <p>Historical analysis shows that winning combinations often have a mix of low and high numbers.</p>
                    `;
                    break;
                    
                case 'odd-even':
                    explanation = `
                        <p>The <strong>Odd-Even</strong> strategy balances between odd and even numbers in your selection.</p>
                        <p>This strategy prevents having all odd or all even numbers, which statistically occurs less frequently in winning combinations.</p>
                        <p>Most winning combinations have a mix of 2-4 odd numbers and 2-4 even numbers (for a 6-number game).</p>
                    `;
                    break;
                    
                case 'prime':
                    explanation = `
                        <p>The <strong>Prime Numbers</strong> strategy focuses on selecting prime numbers (numbers divisible only by 1 and themselves).</p>
                        <p>Prime numbers between 1 and 70: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67.</p>
                        <p>Some lottery players believe prime numbers appear more frequently in winning combinations.</p>
                    `;
                    break;
                    
                case 'fibonacci':
                    explanation = `
                        <p>The <strong>Fibonacci Numbers</strong> strategy selects numbers from the Fibonacci sequence.</p>
                        <p>Fibonacci sequence up to 70: 1, 2, 3, 5, 8, 13, 21, 34, 55.</p>
                        <p>This strategy is based on the mathematical significance of the Fibonacci sequence which appears in many natural patterns.</p>
                    `;
                    break;
                    
                case 'lucky':
                    explanation = `
                        <p>The <strong>Lucky Numbers</strong> strategy uses numbers identified by the "sieve of Josephus Flavius" algorithm.</p>
                        <p>Lucky numbers up to 70: 1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69.</p>
                        <p>Lucky numbers share some properties with prime numbers and are considered "fortunate" by some players.</p>
                    `;
                    break;
                    
                case 'hot-cold':
                    explanation = `
                        <p>The <strong>Hot/Cold Numbers</strong> strategy combines frequently drawn (hot) and infrequently drawn (cold) numbers.</p>
                        <p>Hot numbers are those that have appeared most often in recent draws, while cold numbers are those that haven't appeared in a while.</p>
                        <p>This strategy is based on the theory that some numbers are "due" to appear (cold) while others are on a "hot streak".</p>
                    `;
                    break;
                    
                case 'birthday':
                    explanation = `
                        <p>The <strong>Birthday Numbers</strong> strategy uses numbers significant to you, typically dates (1-31).</p>
                        <p>While this makes numbers more meaningful to you, be aware that this limits your selection to the lower range (1-31) which many other players also use.</p>
                        <p>For better coverage, consider combining birthday numbers with higher numbers.</p>
                    `;
                    break;
                    
                case 'ai':
                    explanation = `
                        <p>The <strong>AI Prediction</strong> strategy uses advanced machine learning models to predict likely numbers.</p>
                        <p>Our AI analyzes historical draw patterns, number frequencies, and complex relationships between numbers to generate predictions.</p>
                        <p>The confidence level determines how strictly the AI follows its predictions versus introducing randomness.</p>
                    `;
                    break;
                    
                default:
                    explanation = '<p>Select a strategy to see its description and how it works.</p>';
            }
            
            explanationContainer.innerHTML = explanation;
        }
        
        function generateWithStrategy() {
            const gameType = document.getElementById('game-type').value;
            let mainPool, pickCount, bonusPool, bonusCount;
            
            if (gameType === 'custom') {
                mainPool = parseInt(document.getElementById('main-numbers').value) || 69;
                pickCount = parseInt(document.getElementById('pick-numbers').value) || 5;
                bonusPool = parseInt(document.getElementById('bonus-numbers').value) || 26;
                bonusCount = parseInt(document.getElementById('pick-bonus').value) || 1;
            } else {
                switch(gameType) {
                    case 'powerball':
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                        break;
                    case 'megamillions':
                        mainPool = 70;
                        pickCount = 5;
                        bonusPool = 25;
                        bonusCount = 1;
                        break;
                    case 'euromillions':
                        mainPool = 50;
                        pickCount = 5;
                        bonusPool = 12;
                        bonusCount = 2;
                        break;
                    case 'lotto649':
                        mainPool = 49;
                        pickCount = 6;
                        bonusPool = 0;
                        bonusCount = 0;
                        break;
                    default:
                        mainPool = 69;
                        pickCount = 5;
                        bonusPool = 26;
                        bonusCount = 1;
                }
            }
            
            const drawCount = parseInt(document.getElementById('draw-count').value) || 5;
            const strategy = appState.currentStrategy;
            
            // Generate numbers based on strategy
            const results = [];
            
            try {
                for (let i = 0; i < drawCount; i++) {
                    let mainNumbers, bonusNumbers;
                    
                    switch(strategy) {
                        case 'random':
                            mainNumbers = generateStandardNumbers(mainPool, pickCount);
                            break;
                            
                        case 'low-high':
                            const lowHighRatio = document.getElementById('low-high-ratio')?.value || 'balanced';
                            mainNumbers = generateLowHighNumbers(mainPool, pickCount, lowHighRatio);
                            break;
                            
                        case 'odd-even':
                            const oddEvenRatio = document.getElementById('odd-even-ratio')?.value || 'balanced';
                            mainNumbers = generateOddEvenNumbers(mainPool, pickCount, oddEvenRatio);
                            break;
                            
                        case 'prime':
                            mainNumbers = generatePrimeNumbers(mainPool, pickCount);
                            break;
                            
                        case 'fibonacci':
                            mainNumbers = generateFibonacciNumbers(mainPool, pickCount);
                            break;
                            
                        case 'lucky':
                            mainNumbers = generateLuckyNumbers(mainPool, pickCount);
                            break;
                            
                        case 'hot-cold':
                            const hotColdRatio = document.getElementById('hot-cold-ratio')?.value || 'balanced';
                            mainNumbers = generateHotColdNumbers(mainPool, pickCount, hotColdRatio);
                            break;
                            
                        case 'birthday':
                            const birthdayInput = document.getElementById('birthday-numbers')?.value || '';
                            const birthdayNumbers = birthdayInput.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 31);
                            
                            if (birthdayNumbers.length === 0) {
                                showToast('Please enter valid birthday numbers (1-31)', 'warning', 'exclamation-triangle');
                                return;
                            }
                            
                            mainNumbers = generateBirthdayNumbers(mainPool, pickCount, birthdayNumbers);
                            break;
                            
                        case 'ai':
                            const confidence = parseInt(document.getElementById('ai-confidence')?.value || 75) / 100;
                            const model = document.getElementById('ai-model')?.value || 'markov';
                            
                            switch(model) {
                                case 'markov':
                                    mainNumbers = generateMarkovNumbers(mainPool, pickCount, confidence);
                                    break;
                                case 'neural':
                                    mainNumbers = generateNeuralNumbers(mainPool, pickCount, confidence);
                                    break;
                                case 'combined':
                                    mainNumbers = generateCombinedAINumbers(mainPool, pickCount, confidence);
                                    break;
                                default:
                                    mainNumbers = generateMarkovNumbers(mainPool, pickCount, confidence);
                            }
                            break;
                            
                        default:
                            mainNumbers = generateStandardNumbers(mainPool, pickCount);
                    }
                    
                    // Generate bonus numbers (always standard random)
                    if (bonusCount > 0) {
                        bonusNumbers = generateStandardNumbers(bonusPool, bonusCount);
                    } else {
                        bonusNumbers = [];
                    }
                    
                    results.push({
                        main: mainNumbers,
                        bonus: bonusNumbers
                    });
                }
                
                // Display results
                displayResults(results, gameType);
                
                // Update number coverage
                updateNumberCoverage(results, mainPool);
                
                // Perform frequency analysis
                performFrequencyAnalysis(results, mainPool, bonusPool);
                
                showToast('Numbers generated successfully', 'success', 'check-circle');
            } catch (error) {
                showToast('Error generating numbers: ' + error.message, 'danger', 'exclamation-triangle');
                console.error(error);
            }
        }
        
        function generateBirthdayNumbers(poolSize, count, birthdayNumbers) {
            // Include some birthday numbers and fill the rest randomly
            const result = [];
            const maxBirthdayToInclude = Math.min(birthdayNumbers.length, Math.floor(count / 2));
            
            // Shuffle birthday numbers and take some
            shuffleArray(birthdayNumbers);
            for (let i = 0; i < maxBirthdayToInclude; i++) {
                result.push(birthdayNumbers[i]);
            }
            
            // Fill the rest with random numbers
            while (result.length < count) {
                const num = Math.floor(Math.random() * poolSize) + 1;
                if (!result.includes(num)) {
                    result.push(num);
                }
            }
            
            return result.sort((a, b) => a - b);
        }
        
        function testStrategy() {
            const gameType = document.getElementById('game-type').value;
            let mainPool, pickCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    break;
                default:
                    mainPool = 69;
                    pickCount = 5;
            }
            
            const strategy = appState.currentStrategy;
            const testCount = 1000; // Number of tests to run
            
            // Get historical data for this game type
            const history = appState.historicalData[gameType] || [];
            if (history.length === 0) {
                showToast('No historical data available to test this strategy', 'warning', 'exclamation-triangle');
                return;
            }
            
            showToast(`Testing ${strategy} strategy against ${history.length} historical draws...`, 'info', 'sync-alt');
            
            // Run test in background to avoid UI freeze
            setTimeout(() => {
                let matches = 0;
                let partialMatches = 0;
                const matchCounts = Array(pickCount + 1).fill(0); // Track how many numbers matched
                
                // Test against each historical draw
                history.forEach(draw => {
                    // Generate numbers using current strategy
                    let testNumbers;
                    
                    switch(strategy) {
                        case 'random':
                            testNumbers = generateStandardNumbers(mainPool, pickCount);
                            break;
                        case 'low-high':
                            testNumbers = generateLowHighNumbers(mainPool, pickCount);
                            break;
                        case 'odd-even':
                            testNumbers = generateOddEvenNumbers(mainPool, pickCount);
                            break;
                        case 'prime':
                            testNumbers = generatePrimeNumbers(mainPool, pickCount);
                            break;
                        case 'fibonacci':
                            testNumbers = generateFibonacciNumbers(mainPool, pickCount);
                            break;
                        case 'lucky':
                            testNumbers = generateLuckyNumbers(mainPool, pickCount);
                            break;
                        case 'hot-cold':
                            testNumbers = generateHotColdNumbers(mainPool, pickCount);
                            break;
                        case 'birthday':
                            // Use some random birthday numbers for testing
                            const randomBirthdays = Array.from({length: 5}, () => Math.floor(Math.random() * 31) + 1);
                            testNumbers = generateBirthdayNumbers(mainPool, pickCount, randomBirthdays);
                            break;
                        case 'ai':
                            testNumbers = generateMarkovNumbers(mainPool, pickCount, 0.75);
                            break;
                        default:
                            testNumbers = generateStandardNumbers(mainPool, pickCount);
                    }
                    
                    // Count matches with historical draw
                    const matchedNumbers = testNumbers.filter(n => draw.numbers.includes(n));
                    const matchCount = matchedNumbers.length;
                    
                    if (matchCount === pickCount) {
                        matches++;
                    } else if (matchCount >= pickCount - 2) {
                        partialMatches++;
                    }
                    
                    matchCounts[matchCount]++;
                });
                
                // Calculate percentages
                const matchPercentage = (matches / history.length) * 100;
                const partialPercentage = (partialMatches / history.length) * 100;
                const avgMatch = matchCounts.reduce((sum, count, i) => sum + (i * count), 0) / history.length;
                
                // Display performance results
                const performanceHTML = `
                    <div class="performance-metric">
                        <span>Full Matches (${pickCount} numbers):</span>
                        <span>${matches} (${matchPercentage.toFixed(2)}%)</span>
                    </div>
                    <div class="performance-bar">
                        <div class="performance-bar-fill" style="width: ${matchPercentage}%"></div>
                    </div>
                    
                    <div class="performance-metric">
                        <span>Partial Matches (${pickCount-2}+ numbers):</span>
                        <span>${partialMatches} (${partialPercentage.toFixed(2)}%)</span>
                    </div>
                    <div class="performance-bar">
                        <div class="performance-bar-fill" style="width: ${partialPercentage}%"></div>
                    </div>
                    
                    <div class="performance-metric">
                        <span>Average Matches per Draw:</span>
                        <span>${avgMatch.toFixed(2)}</span>
                    </div>
                    <div class="performance-bar">
                        <div class="performance-bar-fill" style="width: ${(avgMatch / pickCount) * 100}%"></div>
                    </div>
                    
                    <h3>Match Distribution</h3>
                    <canvas id="strategy-performance-chart" class="simulation-chart"></canvas>
                `;
                
                document.getElementById('performance-results').innerHTML = performanceHTML;
                document.getElementById('strategy-performance').style.display = 'block';
                
                // Create match distribution chart
                const ctx = document.getElementById('strategy-performance-chart').getContext('2d');
                
                if (appState.charts.strategyPerformance) {
                    appState.charts.strategyPerformance.destroy();
                }
                
                appState.charts.strategyPerformance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: pickCount + 1}, (_, i) => i),
                        datasets: [{
                            label: 'Number of Matches',
                            data: matchCounts,
                            backgroundColor: Array.from({length: pickCount + 1}, (_, i) => 
                                `hsl(${(i / pickCount) * 120}, 70%, 60%)`),
                            borderColor: Array.from({length: pickCount + 1}, (_, i) => 
                                `hsl(${(i / pickCount) * 120}, 70%, 40%)`),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Frequency'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Numbers Matched'
                                }
                            }
                        }
                    }
                });
                
                showToast(`Strategy testing complete. ${matches} full matches found.`, 'success', 'check-circle');
            }, 100);
        }
        
        function saveStrategy() {
            const strategy = appState.currentStrategy;
            const gameType = document.getElementById('game-type').value;
            
            const strategyName = prompt('Enter a name for this strategy:', `${strategy} Strategy`);
            if (!strategyName) return;
            
            // Get strategy parameters
            let params = {};
            
            switch(strategy) {
                case 'low-high':
                    params.ratio = document.getElementById('low-high-ratio').value;
                    break;
                case 'odd-even':
                    params.ratio = document.getElementById('odd-even-ratio').value;
                    break;
                case 'hot-cold':
                    params.ratio = document.getElementById('hot-cold-ratio').value;
                    break;
                case 'birthday':
                    params.numbers = document.getElementById('birthday-numbers').value;
                    break;
                case 'ai':
                    params.confidence = document.getElementById('ai-confidence').value;
                    params.model = document.getElementById('ai-model').value;
                    break;
            }
            
            // Save to local storage
            if (!appState.savedStrategies[gameType]) {
                appState.savedStrategies[gameType] = {};
            }
            
            appState.savedStrategies[gameType][strategyName] = {
                strategy: strategy,
                params: params,
                date: new Date().toISOString()
            };
            
            localStorage.setItem('savedStrategies', JSON.stringify(appState.savedStrategies));
            showToast('Strategy saved successfully', 'success', 'save');
        }
        
        // Simulator functions
        function updateSimulator() {
            const gameType = document.getElementById('simulator-game-type').value;
            updateProbabilityCalculator();
        }
        
        function runSimulation() {
            const gameType = document.getElementById('simulator-game-type').value;
            const ticketsText = document.getElementById('simulator-tickets').value.trim();
            const simulationCount = parseInt(document.getElementById('simulation-count').value) || 1000;
            
            if (!ticketsText) {
                showToast('Please enter your tickets to simulate', 'warning', 'exclamation-triangle');
                return;
            }
            
            // Parse tickets
            const ticketLines = ticketsText.split('\n').filter(line => line.trim().length > 0);
            const tickets = [];
            
            let mainPool, pickCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    break;
                default:
                    mainPool = 69;
                    pickCount = 5;
            }
            
            try {
                ticketLines.forEach(line => {
                    const numbers = line.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                    
                    if (numbers.length !== pickCount) {
                        throw new Error(`Each ticket must have exactly ${pickCount} numbers`);
                    }
                    
                    const outOfRange = numbers.filter(n => n < 1 || n > mainPool);
                    if (outOfRange.length > 0) {
                        throw new Error(`Numbers must be between 1 and ${mainPool}`);
                    }
                    
                    const uniqueNumbers = [...new Set(numbers)];
                    if (uniqueNumbers.length !== numbers.length) {
                        throw new Error('Duplicate numbers in ticket');
                    }
                    
                    tickets.push(numbers.sort((a, b) => a - b));
                });
            } catch (error) {
                showToast('Invalid ticket format: ' + error.message, 'danger', 'exclamation-triangle');
                return;
            }
            
            showToast(`Running ${simulationCount.toLocaleString()} simulations...`, 'info', 'sync-alt');
            
            // Disable buttons during simulation
            document.querySelector('#simulator button[onclick="runSimulation()"]').disabled = true;
            document.querySelector('#simulator button[onclick="stopSimulation()"]').disabled = false;
            
            // Run simulation in background to avoid UI freeze
            appState.simulationRunning = true;
            
            if (appState.simulationWorker) {
                appState.simulationWorker.terminate();
            }
            
            appState.simulationWorker = new Worker(URL.createObjectURL(new Blob([`
                onmessage = function(e) {
                    const { gameType, tickets, simulationCount } = e.data;
                    
                    let mainPool, pickCount, bonusPool, bonusCount;
                    
                    switch(gameType) {
                        case 'powerball':
                            mainPool = 69;
                            pickCount = 5;
                            bonusPool = 26;
                            bonusCount = 1;
                            break;
                        case 'megamillions':
                            mainPool = 70;
                            pickCount = 5;
                            bonusPool = 25;
                            bonusCount = 1;
                            break;
                        case 'euromillions':
                            mainPool = 50;
                            pickCount = 5;
                            bonusPool = 12;
                            bonusCount = 2;
                            break;
                        case 'lotto649':
                            mainPool = 49;
                            pickCount = 6;
                            bonusPool = 0;
                            bonusCount = 0;
                            break;
                        default:
                            mainPool = 69;
                            pickCount = 5;
                            bonusPool = 26;
                            bonusCount = 1;
                    }
                    
                    const results = {
                        wins: 0,
                        partials: 0,
                        matchCounts: Array(pickCount + 1).fill(0),
                        bonusMatches: 0,
                        jackpotWins: 0,
                        winningNumbers: []
                    };
                    
                    for (let i = 0; i < simulationCount; i++) {
                        if (i % 1000 === 0) {
                            postMessage({ type: 'progress', current: i, total: simulationCount });
                        }
                        
                        // Generate winning numbers
                        const winningMain = [];
                        for (let j = 0; j < pickCount; j++) {
                            let num;
                            do {
                                num = Math.floor(Math.random() * mainPool) + 1;
                            } while (winningMain.includes(num));
                            winningMain.push(num);
                        }
                        winningMain.sort((a, b) => a - b);
                        
                        const winningBonus = [];
                        for (let j = 0; j < bonusCount; j++) {
                            let num;
                            do {
                                num = Math.floor(Math.random() * bonusPool) + 1;
                            } while (winningBonus.includes(num));
                            winningBonus.push(num);
                        }
                        
                        // Store some winning numbers for display
                        if (i < 10) {
                            results.winningNumbers.push({
                                main: [...winningMain],
                                bonus: [...winningBonus]
                            });
                        }
                        
                        // Check each ticket
                        tickets.forEach(ticket => {
                            const matchedMain = ticket.filter(n => winningMain.includes(n)).length;
                            const matchedBonus = bonusCount > 0 ? 
                                ticket.filter(n => winningBonus.includes(n)).length : 0;
                            
                            results.matchCounts[matchedMain]++;
                            
                            if (matchedMain === pickCount) {
                                if (bonusCount === 0 || matchedBonus === bonusCount) {
                                    results.jackpotWins++;
                                }
                                results.wins++;
                            } else if (matchedMain >= pickCount - 2) {
                                results.partials++;
                            }
                            
                            if (matchedBonus > 0) {
                                results.bonusMatches++;
                            }
                        });
                    }
                    
                    postMessage({ type: 'complete', results });
                }
            `], { type: 'text/javascript' })));
            
            appState.simulationWorker.onmessage = function(e) {
                if (e.data.type === 'progress') {
                    // Update progress
                    const percent = Math.round((e.data.current / e.data.total) * 100);
                    document.querySelector('#simulator button[onclick="runSimulation()"]').innerHTML = 
                        `<i class="fas fa-sync-alt fa-spin"></i> Running (${percent}%)`;
                } else if (e.data.type === 'complete') {
                    // Simulation complete
                    simulationComplete(gameType, tickets, e.data.results, simulationCount);
                }
            };
            
            appState.simulationWorker.postMessage({
                gameType: gameType,
                tickets: tickets,
                simulationCount: simulationCount
            });
        }
        
        function stopSimulation() {
            if (appState.simulationWorker) {
                appState.simulationWorker.terminate();
                appState.simulationWorker = null;
            }
            
            appState.simulationRunning = false;
            document.querySelector('#simulator button[onclick="runSimulation()"]').disabled = false;
            document.querySelector('#simulator button[onclick="stopSimulation()"]').disabled = true;
            document.querySelector('#simulator button[onclick="runSimulation()"]').innerHTML = 
                `<i class="fas fa-play"></i> Run Simulation`;
                
            showToast('Simulation stopped', 'warning', 'stop');
        }
        
        function simulationComplete(gameType, tickets, results, simulationCount) {
            appState.simulationRunning = false;
            document.querySelector('#simulator button[onclick="runSimulation()"]').disabled = false;
            document.querySelector('#simulator button[onclick="stopSimulation()"]').disabled = true;
            document.querySelector('#simulator button[onclick="runSimulation()"]').innerHTML = 
                `<i class="fas fa-play"></i> Run Simulation`;
            
            // Calculate statistics
            const totalTickets = tickets.length * simulationCount;
            const winPercentage = (results.wins / totalTickets) * 100;
            const partialPercentage = (results.partials / totalTickets) * 100;
            const jackpotPercentage = (results.jackpotWins / totalTickets) * 100;
            const bonusPercentage = (results.bonusMatches / totalTickets) * 100;
            
            // Display results
            let resultsHTML = `
                <h3>Simulation Summary</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Total Simulations</h3>
                        <p>${simulationCount.toLocaleString()}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Tickets per Draw</h3>
                        <p>${tickets.length}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Tickets</h3>
                        <p>${totalTickets.toLocaleString()}</p>
                    </div>
                </div>
                
                <h3>Winning Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Jackpot Wins</h3>
                        <p>${results.jackpotWins} (${jackpotPercentage.toFixed(6)}%)</p>
                    </div>
                    <div class="stat-card">
                        <h3>Any Wins</h3>
                        <p>${results.wins} (${winPercentage.toFixed(4)}%)</p>
                    </div>
                    <div class="stat-card">
                        <h3>Partial Wins</h3>
                        <p>${results.partials} (${partialPercentage.toFixed(4)}%)</p>
                    </div>
                    <div class="stat-card">
                        <h3>Bonus Matches</h3>
                        <p>${results.bonusMatches} (${bonusPercentage.toFixed(4)}%)</p>
                    </div>
                </div>
                
                <h3>Match Distribution</h3>
                <canvas id="simulation-chart" class="simulation-chart"></canvas>
            `;
            
            document.getElementById('simulation-results').innerHTML = resultsHTML;
            
            // Display winning numbers
            let winningHTML = '<h3>Sample Winning Numbers</h3><div class="lotto-balls-container">';
            
            results.winningNumbers.forEach((draw, index) => {
                winningHTML += `<div class="lotto-draw"><h4>Draw ${index + 1}:</h4><div class="lotto-balls">`;
                
                draw.main.forEach(num => {
                    winningHTML += `<div class="ball">${num}</div>`;
                });
                
                if (draw.bonus.length > 0) {
                    winningHTML += `<span style="margin: 0 8px; font-weight: bold;">+</span>`;
                    draw.bonus.forEach(num => {
                        winningHTML += `<div class="ball ${gameType === 'powerball' ? 'powerball' : 
                            gameType === 'megamillions' ? 'megaball' : 
                            gameType === 'euromillions' ? 'eurostar' : 'ball'}">${num}</div>`;
                    });
                }
                
                winningHTML += '</div></div>';
            });
            
            winningHTML += '</div>';
            document.getElementById('winning-numbers').innerHTML = winningHTML;
            
            // Create simulation chart
            const ctx = document.getElementById('simulation-chart').getContext('2d');
            
            if (appState.charts.simulation) {
                appState.charts.simulation.destroy();
            }
            
            const labels = Array.from({length: results.matchCounts.length}, (_, i) => i);
            const data = results.matchCounts.slice(0, -1); // Exclude the "all matched" count (already in wins)
            
            appState.charts.simulation = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Matches',
                        data: data,
                        backgroundColor: labels.map(i => 
                            `hsl(${(i / (labels.length - 1)) * 120}, 70%, 60%)`),
                        borderColor: labels.map(i => 
                            `hsl(${(i / (labels.length - 1)) * 120}, 70%, 40%)`),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Numbers Matched'
                            }
                        }
                    }
                }
            });
            
            showToast(`Simulation complete. ${results.wins} wins in ${simulationCount.toLocaleString()} draws.`, 'success', 'check-circle');
        }
        
        function clearSimulation() {
            document.getElementById('simulator-tickets').value = '';
            document.getElementById('simulation-results').innerHTML = '<p>Run a simulation to see results</p>';
            document.getElementById('winning-numbers').innerHTML = '<p>Run a simulation to see winning numbers</p>';
            
            if (appState.charts.simulation) {
                appState.charts.simulation.destroy();
                appState.charts.simulation = null;
            }
        }
        
        function loadSampleTickets() {
            const gameType = document.getElementById('simulator-game-type').value;
            let sampleTickets = '';
            
            switch(gameType) {
                case 'powerball':
                    sampleTickets = `3, 17, 28, 42, 59\n8, 21, 33, 47, 65\n12, 19, 31, 44, 57`;
                    break;
                case 'megamillions':
                    sampleTickets = `4, 15, 27, 39, 52\n7, 18, 30, 45, 60\n11, 22, 34, 48, 61`;
                    break;
                case 'euromillions':
                    sampleTickets = `5, 12, 23, 34, 45\n8, 17, 29, 36, 47\n10, 21, 32, 44, 49`;
                    break;
                case 'lotto649':
                    sampleTickets = `7, 14, 21, 28, 35, 42\n3, 11, 19, 27, 36, 45\n5, 16, 23, 31, 40, 48`;
                    break;
                default:
                    sampleTickets = `3, 17, 28, 42, 59\n8, 21, 33, 47, 65\n12, 19, 31, 44, 57`;
            }
            
            document.getElementById('simulator-tickets').value = sampleTickets;
            showToast('Loaded sample tickets', 'success', 'dice');
        }
        
        function updateProbabilityCalculator() {
            const gameType = document.getElementById('simulator-game-type').value;
            
            let odds, breakEven, expectedValue;
            
            switch(gameType) {
                case 'powerball':
                    odds = '1 in 292,201,338';
                    breakEven = '$584,402,676';
                    expectedValue = '-$0.80';
                    break;
                case 'megamillions':
                    odds = '1 in 302,575,350';
                    breakEven = '$605,150,700';
                    expectedValue = '-$0.85';
                    break;
                case 'euromillions':
                    odds = '1 in 139,838,160';
                    breakEven = '$279,676,320';
                    expectedValue = '-$0.50';
                    break;
                case 'lotto649':
                    odds = '1 in 13,983,816';
                    breakEven = '$27,967,632';
                    expectedValue = '-$0.55';
                    break;
                default:
                    odds = '1 in 292,201,338';
                    breakEven = '$584,402,676';
                    expectedValue = '-$0.80';
            }
            
            document.getElementById('jackpot-odds').textContent = odds;
            document.getElementById('break-even').textContent = breakEven;
            document.getElementById('expected-value').textContent = expectedValue;
        }
        
        // Predictor functions
        function updatePredictor() {
            const gameType = document.getElementById('predictor-game-type').value;
            updateModelDetails();
        }
        
        function updateModelDetails() {
            const model = document.getElementById('predictor-method').value;
            const details = appState.predictionModels[model];
            
            let detailsHTML = `
                <h3>${details.name}</h3>
                <p>${details.description}</p>
                <p><strong>Historical Accuracy:</strong> ${details.accuracy}</p>
            `;
            
            document.getElementById('model-details').innerHTML = detailsHTML;
        }
        
        function generatePredictions() {
            const gameType = document.getElementById('predictor-game-type').value;
            const method = document.getElementById('predictor-method').value;
            const count = parseInt(document.getElementById('prediction-count').value) || 10;
            
            let mainPool, pickCount, bonusPool, bonusCount;
            
            switch(gameType) {
                case 'powerball':
                    mainPool = 69;
                    pickCount = 5;
                    bonusPool = 26;
                    bonusCount = 1;
                    break;
                case 'megamillions':
                    mainPool = 70;
                    pickCount = 5;
                    bonusPool = 25;
                    bonusCount = 1;
                    break;
                case 'euromillions':
                    mainPool = 50;
                    pickCount = 5;
                    bonusPool = 12;
                    bonusCount = 2;
                    break;
                case 'lotto649':
                    mainPool = 49;
                    pickCount = 6;
                    bonusPool = 0;
                    bonusCount = 0;
                    break;
                default:
                    mainPool = 69;
                    pickCount = 5;
                    bonusPool = 26;
                    bonusCount = 1;
            }
            
            // Generate predictions
            const predictions = [];
            
            for (let i = 0; i < count; i++) {
                let mainNumbers, bonusNumbers;
                
                switch(method) {
                    case 'markov':
                        mainNumbers = generateMarkovNumbers(mainPool, pickCount, 0.8);
                        break;
                    case 'neural':
                        mainNumbers = generateNeuralNumbers(mainPool, pickCount, 0.8);
                        break;
                    case 'regression':
                        mainNumbers = generateRegressionNumbers(mainPool, pickCount);
                        break;
                    case 'frequency':
                        mainNumbers = generateFrequencyNumbers(mainPool, pickCount);
                        break;
                    case 'combined':
                        mainNumbers = generateCombinedAINumbers(mainPool, pickCount, 0.8);
                        break;
                    default:
                        mainNumbers = generateMarkovNumbers(mainPool, pickCount, 0.8);
                }
                
                // Generate bonus numbers (always standard random)
                if (bonusCount > 0) {
                    bonusNumbers = generateStandardNumbers(bonusPool, bonusCount);
                } else {
                    bonusNumbers = [];
                }
                
                predictions.push({
                    main: mainNumbers,
                    bonus: bonusNumbers
                });
            }
            
            // Display predictions
            displayPredictions(predictions, gameType);
            
            // Perform prediction analysis
            analyzePredictions(predictions, mainPool);
            
            showToast('Predictions generated successfully', 'success', 'crystal-ball');
        }
        
        function generateRegressionNumbers(poolSize, count) {
            // Simplified regression analysis
            // In a real app, this would use actual regression models
            const numbers = [];
            const hotNumbers = appState.hotColdData[appState.currentGame]?.hot || [];
            
            while (numbers.length < count) {
                let num;
                
                // Bias towards numbers that are hot but not too recent
                if (hotNumbers.length > 0 && Math.random() < 0.6) {
                    num = hotNumbers[Math.floor(Math.random() * hotNumbers.length)];
                } else {
                    // Bias towards middle range numbers
                    const middleStart = Math.floor(poolSize * 0.3);
                    const middleEnd = Math.floor(poolSize * 0.7);
                    num = middleStart + Math.floor(Math.random() * (middleEnd - middleStart));
                }
                
                if (!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            return numbers.sort((a, b) => a - b);
        }
        
        function generateFrequencyNumbers(poolSize, count) {
            // Generate numbers based on frequency analysis
            const frequencyData = appState.hotColdData[appState.currentGame]?.frequency;
            if (!frequencyData || frequencyData.length === 0) {
                return generateStandardNumbers(poolSize, count);
            }
            
            // Sort by frequency (descending)
            const sorted = [...frequencyData].sort((a, b) => b.count - a.count);
            
            // Take some from the top (frequent) and some from the middle
            const result = [];
            const topCount = Math.floor(count / 2);
            
            for (let i = 0; i < topCount && i < sorted.length; i++) {
                result.push(sorted[i].number);
            }
            
            // Fill the rest with numbers from the middle of the frequency range
            const middleStart = Math.floor(sorted.length * 0.3);
            const middleEnd = Math.floor(sorted.length * 0.7);
            
            while (result.length < count) {
                const index = middleStart + Math.floor(Math.random() * (middleEnd - middleStart));
                if (index < sorted.length && !result.includes(sorted[index].number)) {
                    result.push(sorted[index].number);
                }
            }
            
            return result.sort((a, b) => a - b);
        }
        
        function displayPredictions(predictions, gameType) {
            const container = document.getElementById('prediction-results');
            container.innerHTML = '';
            
            predictions.forEach((prediction, index) => {
                const predElement = document.createElement('div');
                predElement.className = 'prediction-card';
                
                const title = document.createElement('h4');
                title.textContent = `Prediction ${index + 1}:`;
                predElement.appendChild(title);
                
                const ballsContainer = document.createElement('div');
                ballsContainer.className = 'lotto-balls';
                
                // Main numbers
                prediction.main.forEach(num => {
                    const ball = document.createElement('div');
                    ball.className = 'ball';
                    ball.textContent = num;
                    ballsContainer.appendChild(ball);
                });
                
                // Bonus numbers
                if (prediction.bonus.length > 0) {
                    const separator = document.createElement('span');
                    separator.textContent = ' + ';
                    separator.style.margin = '0 8px';
                    separator.style.fontWeight = 'bold';
                    ballsContainer.appendChild(separator);
                    
                    prediction.bonus.forEach(num => {
                        const ball = document.createElement('div');
                        ball.className = 'ball ' + 
                            (gameType === 'powerball' ? 'powerball' : 
                             gameType === 'megamillions' ? 'megaball' : 
                             gameType === 'euromillions' ? 'eurostar' : 'ball');
                        ball.textContent = num;
                        ballsContainer.appendChild(ball);
                    });
                }
                
                predElement.appendChild(ballsContainer);
                container.appendChild(predElement);
            });
        }
        
        function analyzePredictions(predictions, mainPool) {
            if (predictions.length === 0) return;
            
            // Count frequency of each number in predictions
            const freq = {};
            for (let i = 1; i <= mainPool; i++) {
                freq[i] = 0;
            }
            
            predictions.forEach(pred => {
                pred.main.forEach(num => {
                    freq[num]++;
                });
            });
            
            // Convert to array and sort
            const freqArray = Object.entries(freq).map(([num, count]) => ({
                number: parseInt(num),
                count,
                percentage: (count / predictions.length) * 100
            }));
            
            freqArray.sort((a, b) => b.count - a.count);
            
            // Get top predicted numbers
            const topNumbers = freqArray.slice(0, 10);
            
            // Display analysis
            let analysisHTML = `
                <h3>Most Predicted Numbers</h3>
                <div class="lotto-balls">
                    ${topNumbers.map(num => 
                        `<div class="ball hot-number" title="Predicted ${num.count} times (${num.percentage.toFixed(1)}%)">${num.number}</div>`
                    ).join('')}
                </div>
                
                <h3>Prediction Distribution</h3>
                <canvas id="prediction-chart" class="simulation-chart"></canvas>
            `;
            
            document.getElementById('prediction-analysis').innerHTML = analysisHTML;
            
            // Create prediction chart
            const ctx = document.getElementById('prediction-chart').getContext('2d');
            
            if (appState.charts.prediction) {
                appState.charts.prediction.destroy();
            }
            
            // Prepare data for chart
            const labels = freqArray.map(item => item.number);
            const data = freqArray.map(item => item.count);
            
            appState.charts.prediction = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Prediction Frequency',
                        data: data,
                        backgroundColor: labels.map(num => 
                            `hsl(${(num / mainPool) * 360}, 70%, 60%)`),
                        borderColor: labels.map(num => 
                            `hsl(${(num / mainPool) * 360}, 70%, 40%)`),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Numbers'
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 20
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const freq = freqArray.find(f => f.number === parseInt(context.label));
                                    return `Predicted ${context.raw} times (${freq.percentage.toFixed(1)}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function clearPredictions() {
            document.getElementById('prediction-results').innerHTML = '<p>Generate predictions to see results</p>';
            document.getElementById('prediction-analysis').innerHTML = '<p>Generate predictions to see analysis</p>';
            
            if (appState.charts.prediction) {
                appState.charts.prediction.destroy();
                appState.charts.prediction = null;
            }
        }
        
        // Sample data loading
        function loadSampleData() {
            // Sample historical data for demonstration
            appState.historicalData = {
                powerball: generateSampleHistory(69, 26, 100),
                megamillions: generateSampleHistory(70, 25, 100),
                euromillions: generateSampleHistory(50, 12, 100, 2),
                lotto649: generateSampleHistory(49, 0, 100, 0)
            };
            
            // Initialize hot/cold data
            appState.hotColdData = {
                powerball: calculateHotCold(appState.historicalData.powerball, 69),
                megamillions: calculateHotCold(appState.historicalData.megamillions, 70),
                euromillions: calculateHotCold(appState.historicalData.euromillions, 50),
                lotto649: calculateHotCold(appState.historicalData.lotto649, 49)
            };
        }
        
        function generateSampleHistory(mainPool, bonusPool, count, bonusCount = 1) {
            const history = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - count);
            
            for (let i = 0; i < count; i++) {
                const drawDate = new Date(startDate);
                drawDate.setDate(drawDate.getDate() + i);
                
                // Generate main numbers
                const mainNumbers = [];
                while (mainNumbers.length < (bonusCount === 0 ? 6 : 5)) {
                    const num = Math.floor(Math.random() * mainPool) + 1;
                    if (!mainNumbers.includes(num)) {
                        mainNumbers.push(num);
                    }
                }
                
                // Generate bonus numbers
                const bonusNumbers = [];
                if (bonusPool > 0) {
                    while (bonusNumbers.length < bonusCount) {
                        const num = Math.floor(Math.random() * bonusPool) + 1;
                        if (!bonusNumbers.includes(num)) {
                            bonusNumbers.push(num);
                        }
                    }
                }
                
                // Random jackpot amount
                const jackpot = Math.floor(Math.random() * 500000000) + 10000000;
                
                history.push({
                    date: drawDate.toISOString().split('T')[0],
                    numbers: mainNumbers.sort((a, b) => a - b),
                    bonus: bonusNumbers.sort((a, b) => a - b),
                    jackpot: jackpot
                });
            }
            
            return history;
        }
        
        function calculateHotCold(history, mainPool) {
            const frequency = {};
            for (let i = 1; i <= mainPool; i++) {
                frequency[i] = 0;
            }
            
            history.forEach(draw => {
                draw.numbers.forEach(num => {
                    frequency[num]++;
                });
            });
            
            // Convert to array and sort
            const frequencyArray = Object.entries(frequency).map(([num, count]) => ({
                number: parseInt(num),
                count
            }));
            
            frequencyArray.sort((a, b) => b.count - a.count);
            
            // Get hot (top 10) and cold (bottom 10) numbers
            return {
                hot: frequencyArray.slice(0, 10).map(item => item.number),
                cold: frequencyArray.slice(-10).map(item => item.number),
                frequency: frequencyArray
            };
        }
    </script>
</body>
</html> 

                              
